P:0000:convertNumber:-------------------------------------------------------------------------------------\n Convert the value in the A register to decimal digits\n $00 hundreds digit\n $01 tens digit\n $02 ones digit
P:0025:: replace digit with space if 0, starting from leftmost digit
P:0028:: exit routine if not 0
P:0035:decimalPlaceValues
P:0038:OperModeExecutionTree:hexTable:\n    .db $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0a, $0b, $0c, $0d, $0e, $0f\ninclude code\lagmaker.asm                  \n-------------------------------------------------------------------------------------\n$00 - vram buffer address table low, also used for pseudorandom bit\n$01 - vram buffer address table high\n-------------------------------------------------------------------------------------\nNoPlease1: jmp NoPlease
P:0055::this is the heart of the entire program,
P:0058::most of what goes on starts here
P:0063:TitleScreenMode:-------------------------------------------------------------------------------------
P:0073:ContinueWord:-------------------------------------------------------------------------------------
P:0080:WSelectBufferTemplate
P:0089:NullJoypadJMP
P:008C:MenuContinue
P:0096::write template for world select in vram buffer
P:0099::do this until all bytes are written
P:00A5:GameMenuRoutine
P:00AA::check to see if either player pressed
P:00B1:StartGame
P:00BB::if either start or A + start, execute here
P:00C1:ChkSelect
P:00C5::check select/B button timer
P:00C8::if not expired, branch
P:00CA::otherwise reset select button timer
P:0128::check to see if the select button was pressed
P:012A::if so, branch reset demo timer
P:0134:ChkWorldSel:ldx DemoTimer               ;otherwise check demo timer\nbne ChkWorldSel             ;if demo timer not expired, branch to check world selection\nsta SelectTimer             ;set controller bits here if running demo\njsr DemoEngine              ;run through the demo actions\nbcs ResetTitle              ;if carry flag set, demo over, thus branch\njmp Rundemo                 ;otherwise, run game engine for demo\ncheck to see if world selection has been enabled
P:0139::if so, check to see if the B button was pressed
P:013D::if so, increment Y and execute same code as select
P:013E:SelectLogic:lda DemoTimer               ;if select or B pressed, check demo timer one last time\nbeq ResetTitle              ;if demo timer expired, branch to reset title screen mode\nlda #$18                    ;otherwise reset demo timer\nsta DemoTimer\ncheck select/B button timer
P:0144::if not expired, branch
P:0146::otherwise reset select button timer
P:014B::was the B button pressed earlier?  if so, branch
P:014D::note this will not be run if world selection is disabled
P:014F::inc CurrentPlayer\nif no, must have been the select button, therefore
P:015D:IncWorldSel
P:0173::increment world select number
P:018C:UpdateShroom:write template for world select in vram buffer
P:018F::do this until all bytes are written
P:0197::get world number from variable and increment for
P:019A::proper display, and put in blank byte before
P:019B::null terminator
P:01AE:NullJoypad
P:01B4::clear joypad bits for player 1
P:01B9:RunDemo:run game engine
P:01BC::check to see if we're running lose life routine
P:01C0::if not, do not do all the resetting below
P:01C2:ResetTitle:reset game modes, disable
P:01C4::sprite 0 check and disable
P:01C7::screen output
P:01D0:ExitMenu1
P:01D1:SizeTable
P:01D4:OldStatusTable
P:01D7:ChkContinue
P:0205::load previously saved world number for secret
P:0218:StartWorld1
P:0220::set 1-up box flag for both players
P:0223::set fetch new game timer flag
P:0226::set next game mode
P:022E::set game mode here, and clear demo timer
P:023D:InitScores:clear player scores and coin displays
P:0243:ExitMenu
P:0244:GoContinue:start both players at the first area
P:0247::of the previously saved world number
P:0257::will make no difference
P:025E:MushroomIconData:sta OffScr_WorldNumber\nsta OffScr_AreaNumber\n-------------------------------------------------------------------------------------
P:0266:DrawMushroomIcon:read eight bytes to be read by transfer routine
P:0268:IconDataRead:note that the default position is set for a
P:026B::1-player game
P:0276::check number of players
P:0279::if set to 1-player game, we're done
P:027B::otherwise, load blank tile in 1-player position
P:0280::then load shroom icon tile in 2-player position
P:0285:ExitIcon
P:0286:VictoryMode:-------------------------------------------------------------------------------------\nrun victory mode subroutines
P:0289::get current task of victory mode
P:028C::if on bridge collapse, skip enemy processing
P:0290::otherwise reset enemy object offset 
P:0292::and run enemy code
P:0295:AutoPlayer:get player's relative coordinates
P:0298::draw the player, then leave
P:029B:VictoryModeSubroutines
P:02B7:Okso:-------------------------------------------------------------------------------------\n.dw "CREDITS TO"-55\n.dw "TEST - TEST"-55
P:02B7:WipeTheFuckingScreen
P:02C8:SetupVictoryMode:get page location of right side of screen
P:02CB::increment to next page
P:02CC::store here
P:02D0::play win castle music
P:02F1::lda #$19\nsta VRAM_Buffer1+3,y
P:02FE::apparently this sometimes refuses to work correctly lmao
P:0303::jump to set next major task in victory mode
P:0306:DisplayCredits
P:0318:WriteCredits
P:0329:Nothing
P:032D:CheckForThing
P:0362::exit, write routine is in another part and bank
P:036F:PlayerVictoryWalk:-------------------------------------------------------------------------------------\nset value here to not walk player by default
P:037A::get player's page location
P:037C::compare with destination page location
P:037E::if page locations don't match, branch
P:0380::otherwise get player's horizontal position
P:0382::compare with preset horizontal position
P:0384::if still on other page, branch ahead
P:0386:PerformWalk:otherwise increment value and Y
P:0388::note Y will be used to walk the player
P:0389:DontWalk:put contents of Y in A and
P:038A::use A to move player to the right or not
P:038D::check page location of left side of screen
P:0390::against set value here
P:0392::branch if equal to change modes if necessary
P:0397::do fixed point math on fractional part of scroll
P:039A::save fractional movement amount
P:039D::set 1 pixel per frame
P:039F::add carry from previous addition
P:03A1::use as scroll amount
P:03A2::do sub to scroll the screen
P:03A5::do another sub to update screen and scroll variables
P:03A8::increment value to stay in this routine
P:03AA:ExitVWalk:load value set here
P:03AC::if zero, branch to change modes
P:03AE::otherwise leave
P:03AF:IncModeTask_A1
P:03B3:PrintVictoryMessages:-------------------------------------------------------------------------------------\nload secondary message counter
P:03B6::if set, branch to increment message counters
P:03B8::otherwise load primary message counter
P:03BB::if set to zero, branch to print first message
P:03C4::check world number
P:03C9::if not at world 8, skip to next part
P:03D5::check primary message counter again
P:03D7::if not at 3 yet (world 8 only), branch to increment
P:03D9::otherwise subtract one
P:03DB::and skip to next part
P:03DE:MRetainerMsg:check primary message counter
P:03E0::if not at 2 yet (world 1-7 only), branch
P:03E2:ThankPlayer:put primary message counter into Y
P:03E3::if counter nonzero, skip this part, do not print first message
P:03E5::otherwise get player currently on the screen
P:03EB:SecondPartMsg:increment Y to do world 8's message
P:03F6::check world number
P:03F8::if at world 8, branch to next part
P:0404::otherwise decrement Y for world 1-7's message
P:0405::if counter at 4 (world 1-7 only)
P:0407::branch to set victory end timer
P:0409::if counter at 3 (world 1-7 only)
P:040B::branch to keep counting
P:040D:EvalForMusic:if counter not yet at 3 (world 8 only), branch
P:040F::to print message only (note world 1-7 will only
P:0411::reach this code if counter = 0, and will always branch)
P:0413::otherwise load victory music first (world 8 only)
P:0415:PrintMsg:put primary message counter in A
P:0416::add $0c or 12 to counter thus giving an appropriate value,
P:0417::($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
P:0419::write message counter to vram address controller
P:041C:IncMsgCounter
P:0420::add four to secondary message counter
P:0428::add carry to primary message counter
P:042D::check primary counter one more time
P:042F:SetEndTimer:if not reached value yet, branch to leave
P:0442:Salir:lda WorldEndTimer\ncmp #$06\nbcs ExitMsgs\nldy WorldNumber\ncpy #FinalWorld\nbeq Salir\njsr AwardGameTimerPoints\nbeq ExitMsgs
P:0444::otherwise set world end timer
P:0447:IncModeTask_A:move onto next task in mode
P:044A:ExitMsgs:leave
P:044B:EndCastleAward:-------------------------------------------------------------------------------------\nif world end timer has not yet reached a certain point
P:044E::then go ahead and skip all of this
P:0455:ExEWA
P:0456:PlayerEndWorld:branch to leave if not\ncheck to see if world end timer expired
P:045B::check world number
P:045E::if on world 8, player is done with game, 
P:0460::thus branch to read controller
P:0462:Tumama
P:0464::otherwise initialize area number used as offset
P:0467::and level number control to start at area 1
P:046A::initialize secondary mode of operation
P:046D::increment world number to move onto the next world
P:0470::get area address offset for the next area
P:0473::set flag to load game timer from header
P:047B::set mode of operation to game mode
P:047E:EndExitOne:and leave
P:047F:EndChkBButton
P:0488:PressButtonB
P:048B::check to see if B button was pressed on
P:048E::either controller
P:0490::branch to leave if not
P:0495::remove onscreen player's lives
P:04A2::do sub to continue other player or end game
P:04A5:EndExitTwo:leave
P:04A6:FloateyNumTileData:-------------------------------------------------------------------------------------\ndata is used as tiles for numbers\nthat appear when you defeat enemies\ndummy
P:04A8:: "100"
P:04AA:: "200"
P:04AC:: "400"
P:04AE::.db $f9, $fb ; "500"\n "800"
P:04B0:: "1000"
P:04B2:: "2000"
P:04B4:: "4000"
P:04B6::.db $f9, $50 ; "5000"\n "8000"
P:04B8:: "1-UP"
P:04BA:ScoreUpdateData:high nybble is digit number, low nybble is number to\nadd to the digit of the player's score\ndummy
P:04C4:FloateyNumbersRoutine:if less than $0b, branch
P:04C8::otherwise set to $0b, thus keeping
P:04CA::it in range
P:04CD:ChkNumTimer:use as Y
P:04CE::check value here
P:04D1::if nonzero, branch ahead
P:04D6::initialize floatey number control and leave
P:04DA:DecNumTimer:decrement value here
P:04DD::if not reached a certain point, branch  
P:04E5::check offset for $0b
P:04E7::branch ahead if not founs
P:04EB::and play the 1-up sound
P:0503::give player one extra life (1-up)
P:050B::otherwise, check number of lives
P:050E::clc                          ;and increment by one for display   //uncommented as having 00 lifes is like having 1\nadc #$01\nmore than 9 lives?
P:0512::if so, subtract 10 and add one to the 10s digit
P:0514::instead of showing 100 lives, A0 will show, etc.
P:051D::if so, subtract 10 and add to the digit
P:051F::next to the difference
P:0528:PutLives3
P:0533::check highest digit of score
P:0536::bne +	                    ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-6,y
P:0538:LoadNumTiles:load point value here
P:053B::move high nybble to low
P:053F::use as X offset, essentially the digit
P:0540::load again and this time
P:0543::mask out the high nybble
P:0545::store as amount to add to the digit
P:054B:ChkTallEnemy:get OAM data offset for enemy object
P:0559::get enemy object identifier
P:055D::branch if spiny
P:0561::branch if piranha plant
P:0565::branch elsewhere if hammer bro
P:0569::branch if cheep-cheep of either color
P:057D::branch elsewhere if enemy object => $09
P:0581::if enemy state defeated or otherwise
P:0583::$02 or greater, branch beyond this part
P:0585:GetAltOffset:load some kind of control bit
P:0588::get alternate OAM data offset
P:058B::get enemy object offset again
P:058D:FloateyPart:get vertical coordinate for
P:0590::floatey number, if coordinate in the
P:0592::status bar, branch
P:0596::otherwise subtract one and store as new
P:0599:SetupNumSpr:get vertical coordinate
P:059C::subtract eight and dump into the
P:059E::and into first row sprites
P:05A1::and do sub to dump into first and second sprites
P:05A9::get horizontal coordinate
P:05B3::store into X coordinate of left sprite
P:05D5::get horizontal coordinate
P:05DF::store into X coordinate of left sprite
P:0602::load X coordinate of left sprite
P:0606::add eight pixels and store into X
P:0608::coordinate of right sprite
P:060D::set palette control in attribute bytes
P:0610::of left and right sprites
P:0616::multiply our floatey number control by 2
P:0617::and use as offset for look-up table
P:061B::display first half of number of points
P:0621::display the second half
P:0624::get enemy object offset and leave
P:0627:ScreenRoutines:-------------------------------------------------------------------------------------\nrun one of the following subroutines
P:064B:GetBackgroundColor1:-------------------------------------------------------------------------------------
P:0654:InitScreen:initialize all sprites including sprite #0
P:0657::and erase both name and attribute tables
P:065D::if mode still 0, do not load
P:065F::into buffer pointer
P:0664:SetupIntermediate:-------------------------------------------------------------------------------------\nsave current background color control
P:0667::and player status to stack
P:066C::set background color to black
P:066E::and player status to not fiery
P:0671::this is the ONLY time background color control
P:0673::is set to less than 4
P:0679::we only execute this routine for
P:067A::the intermediate lives display
P:067D::and once we're done, we return bg
P:067E::color ctrl and player status from stack
P:0681::then move onto the next task
P:0684:AreaPalette:-------------------------------------------------------------------------------------
P:0688:GetAreaPalette:select appropriate palette to load
P:068B::based on area type
P:068E:SetVRAMAddr_A:store offset into buffer control
P:0691:NextSubtask:move onto next task
P:0694:BGColorCtrl_Addr:-------------------------------------------------------------------------------------\n$00 - used as temp counter in GetPlayerColors
P:0698:BackgroundColors:used by area type if bg color ctrl not set
P:069C::used by background color control if set
P:06A4:PlayerColorsOffset:PlayerColors:\n      .db $22, $16, $27, $18 ;Mario's colors\n      .db $22, $30, $27, $19 ;Luigi's colors\n      .db $22, $37, $27, $16 ;Fiery (used by both)
P:06A6:MarioColors:Small
P:06A6:PlayerColors
P:06AA::Big
P:06AE::Fiery
P:06B2:LuigiColors:Small
P:06B6::Big
P:06BA::Fiery
P:06BE:GetBackgroundColor:check background color control
P:06C1::if not set, increment task and fetch palette
P:06C3::put appropriate palette into vram
P:06C6::note that if set to 5-7, $0301 will not be read
P:06C9:NoBGColor:increment to next subtask and plod on through
P:06CC:GetPlayerColors:get current buffer offset
P:06E0:StartClrGet:do four colors
P:06E4:ClrGetLoop:fetch player colors and store them
P:06E7::in the buffer
P:06F0::load original offset from before
P:06F3::if this value is four or greater, it will be set
P:06F6::therefore use it as offset to background color
P:0702::otherwise use area type bits from area offset as offset
P:0705:SetBGColor:to background color instead
P:070B::set for sprite palette address
P:070D::save to buffer
P:0715::write length byte to buffer
P:071A::now the null terminator
P:071F::move the buffer pointer ahead 7 bytes
P:0720::in case we want to write anything else later
P:0723:SetVRAMOffset:store as new vram buffer offset
P:0727:GetAlternatePalette1:-------------------------------------------------------------------------------------
P:072E::otherwise check world number
P:073C::check for mushroom level style
P:0743::if found, load appropriate palette
P:0745:SetVRAMAddr_B
P:0748:NoAltPal:now onto the next task
P:074B:WriteTopStatusLine:-------------------------------------------------------------------------------------\nselect main status barrel
P:074D::output it
P:0750::onto the next task
P:0753:WriteBottomStatusLine:-------------------------------------------------------------------------------------
P:077C::write player's score and coin tally to screen
P:078A::write address for world-area number on screen
P:0794::write length for it
P:07AB::first the world number
P:07B3::next the dash
P:07CA::next the level number
P:07CD::increment for proper number display
P:07DB::put null terminator on
P:07E0::move the buffer offset up by 6 bytes
P:07EA:DisplayTimeUp:-------------------------------------------------------------------------------------\nif game timer not expired, increment task
P:07ED::control 2 tasks forward, otherwise, stay here
P:07F1::reset timer expiration flag
P:07F4::output time-up screen to buffer
P:07F9:NoTimeUp:increment control task 2 tasks forward
P:07FF:DisplayIntermediate:-------------------------------------------------------------------------------------\ncheck primary mode of operation
P:0802::if in title screen mode, skip this
P:0804::are we in game over mode?
P:0806::if so, proceed to display game over screen
P:0808::otherwise check for mode of alternate entry
P:080B::and branch if found
P:080D::if this flag is set, skip intermediate lives display
P:0810::and jump to specific task, otherwise
P:0812:PlayerInter:put player in appropriate place for
P:0815::lives display, then output lives display to buffer
P:0817:OutputInter
P:081F::reenable screen output
P:0826:GameOverInter:set screen timer
P:082B::output game over screen to buffer
P:0833:NoInter:set for specific task and leave
P:0839:AreaParserTaskControl:-------------------------------------------------------------------------------------
P:0841::render column set of current area
P:084C:TaskLoop:render column set of current area
P:084F::check number of tasks
P:0852::if tasks still not all done, do another one
P:0854::do we need to render more column sets?
P:085C::if not, move on to the next task
P:085F::if not, move on to the next task
P:0865:OutputCol:set vram buffer to output rendered column set
P:0867::on next NMI
P:086B:ClearBuffersDrawIcon:-------------------------------------------------------------------------------------
P:086E::if not title screen mode, leave
P:0870::otherwise, clear buffer space
P:0872:TScrClear
P:087B::draw player select icon
P:087E:IncSubtask:move onto next task
P:0882:WriteTopScore:-------------------------------------------------------------------------------------
P:0885::run display routine to display top score on title
P:08A3::change the last 0 to a 9
P:08B2:IncModeTask_B:move onto next mode
P:08B6:GameText:-------------------------------------------------------------------------------------\n.db $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
P:08B6:TopStatusBarLine
P:08C7:: "WORLD"\n "WORLD  TIME"
P:08D5:: score trailing digit and coin display
P:08DD:: attribute table data, clears name table 0 to palette 2
P:08E1:: attribute table data, used for coin icon in status bar
P:08E5:: end of data block
P:08E6:WorldLivesDisplay: cross with spaces used on
P:08EB:: lives display
P:08F0:: "WORLD  - " used on lives display
P:08FD:: possibly used to clear time up
P:0901:: attribute table data for crown if more than 9 lives
P:0902:TwoPlayerTimeUp: "MARIO"
P:090A:OnePlayerTimeUp: "TIME UP"
P:0915:TwoPlayerGameOver: "MARIO"
P:091D:GameOver:"GAME OVER"
P:091D:OnePlayerGameOver
P:0929::"CONTINUE"
P:0938::"END"
P:093F:WarpZoneNumbers: "MARIO"\n "GAME OVER"\n  .db $25, $84, $15, $20, $0e, $15, $0c, $18, $16 ; "WELCOME TO WARP ZONE!"\n  .db $0e, $24, $1d, $18, $24, $20, $0a, $1b, $19\n  .db $24, $23, $18, $17, $0e, $2b\n  .db $26, $25, $01, $24         ; placeholder for left pipe\n  .db $26, $2d, $01, $24         ; placeholder for middle pipe\n  .db $26, $35, $01, $24         ; placeholder for right pipe\n  .db $27, $d9, $46, $aa         ; attribute data\n  .db $27, $e1, $45, $aa\n  .db $ff\nLuigiName:\n  .db $15, $1e, $12, $10, $12    ; "LUIGI", no address or length\n world 1-2
P:093F:WarpZoneWelcome
P:0943:: warp zone responsible for minus world
P:0947:: world 4-2
P:094B:: world 4-2 to world 5
P:094F:GameTextOffsets
P:0959:PrintWarpZoneNumbers1
P:095C:WriteGameText:save text number to stack
P:095E::multiply by 2 and use as offset
P:095F::if set to do top status bar or world/lives display,
P:0961::branch to use current offset as-is
P:0963::if set to do time-up or game over,
P:0965::branch to check players
P:0967::otherwise warp zone, therefore set offset
P:0969:Chk2Players:lda NumberOfPlayers     ;check for number of players\nbne LdGameText          ;if there are two, use current offset to also print name\notherwise increment offset by one to not print name
P:096A:LdGameText:get offset to message we want to print
P:096F:GameTextLoop:load message data
P:0972::check for terminator
P:0974::branch to end text if found
P:0976::otherwise write data to buffer
P:0979::and increment increment
P:097B::do this for 256 bytes if no terminator found
P:097D:EndGameText:put null terminator at end
P:0982::pull original text number from stack
P:0984::are we printing warp zone?
P:098C::are we printing the world/lives display?
P:098D::if not, branch to check player's name
P:0994::otherwise, check number of lives
P:0997::clc                       ;and increment by one for display //$01 = $00 lifes\nadc #$01\nmore than 9 lives?
P:099B::if so, subtract 10 and add one to the 10s digit
P:099D::instead of showing 100 lives, A0 will show, etc.
P:09A6::if so, subtract 10 and add to the digit
P:09A8::next to the difference
P:09B1:PutLives:more than 9 lives?\nif so, subtract 10 and put a crown tile\nnext to the difference...strange things happen if\nthe number of lives exceeds 19
P:09B4::write world and level numbers (incremented for display)
P:09B7::to the buffer in the spaces surrounding the dash
P:09BF::we're done here
P:09D6:ExitWPrint
P:09D7:HardModeDisplay
P:09D9:CheckPlayerName
P:09F0:NameLoop: replace "MARIO" (Including for Mario)
P:09F6::do this until each letter is replaced
P:0A05:FillB
P:0A13:ExitChkName
P:0A14:PrintWarpZoneNumbers:subtract 4 and then shift to the left
P:0A16::twice to get proper warp zone number
P:0A17::offset
P:0A1B:WarpNumLoop:print warp zone numbers into the
P:0A1E::placeholders from earlier
P:0A22::put a number in every fourth space
P:0A2A::load new buffer pointer at end of message
P:0A2F:PlayerIData
P:0A34:PlayerNamesCharLenght:-------------------------------------------------------------------------------------
P:0A39:ResetSpritesAndScreenTimer:check if screen timer has expired
P:0A3C::if not, branch to leave
P:0A3E::otherwise reset sprites now
P:0A41:ResetScreenTimer:reset timer again
P:0A46::move onto next task
P:0A49:NoReset
P:0A4A:BlockGfxData:-------------------------------------------------------------------------------------\n$00 - temp vram buffer offset\n$01 - temp metatile buffer offset\n$02 - temp metatile graphics table offset\n$03 - used to store attribute bits\n$04 - used to determine attribute table row\n$05 - used to determine attribute table column\n$06 - metatile graphics table address low\n$07 - metatile graphics table address high\n-------------------------------------------------------------------------------------\n$00 - used as temporary counter in ColorRotation\n-------------------------------------------------------------------------------------\n$00 - temp store for offset control bit\n$01 - temp vram buffer offset\n$02 - temp store for vertical high nybble in block buffer routine\n$03 - temp adder for high byte of name table address\n$04, $05 - name table address low/high\n$06, $07 - block buffer address low/high
P:0A67:RemoveCoin_Axe:ldy #$e1                 ;set low byte so offset points to $0341\nload offset for default blank metatile
P:0A69::check area type
P:0A6C::if not water type, use offset
P:0A6E::otherwise load offset for blank metatile used in water
P:0A70:WriteBlankMT:do a sub to write blank metatile to vram buffer
P:0A73:blank
P:0A77:IntermediatePlayerData
P:0A7D:DrawPlayer_Intermediate:store data into zero page memory
P:0A7F:PIntLoop:load data to display player as he always
P:0A82::appears on world/lives display
P:0A85::do this until all data is loaded
P:0A87::load offset for small standing
P:0A89::load sprite data offset
P:0A8B::draw player accordingly
P:0A8E::get empty sprite attributes
P:0A91::set horizontal flip bit for bottom-right sprite
P:0A93::store and leave
P:0A97:ReplaceBlockMetatile2
P:0AAA:ReplaceBlockMetatile
P:0AAD::write metatile to vram buffer to replace block object
P:0AB0:VineYes
P:0AB5:DestroyBlockMetatile
P:0ABF::force blank metatile if branched/jumped to this point
P:0AC1:WriteBlockMetatile:load offset for blank metatile
P:0AC3::check contents of A for blank metatile
P:0AC5::branch if found (unconditional if branched from 8a6b)
P:0AD3::load offset for brick metatile w/ line
P:0ADB::use offset if metatile is brick with coins (w/ line)
P:0ADF::use offset if metatile is breakable brick w/ line
P:0AE5::increment offset for brick metatile w/o line
P:0AE8::use offset if metatile is brick with coins (w/o line)
P:0AEC::use offset if metatile is breakable brick w/o line
P:0B11:UseBOffset:put Y in A
P:0B12:Hmm:get vram buffer offset
P:0B15::move onto next byte
P:0B16::get appropriate block data and write to vram buffer
P:0B19:MoveVOffset:decrement vram buffer offset
P:0B1A::add 10 bytes to it
P:0B1E::branch to store as new vram buffer offset
P:0B21:PutBlockMetatile:store control bit from SprDataOffset_Ctrl
P:0B23::store vram buffer offset for next byte
P:0B26::multiply A by four and use as X
P:0B28::load high byte for name table 0
P:0B2A::get low byte of block buffer pointer
P:0B30::if not, use current high byte
P:0B32::otherwise load high byte for name table 1
P:0B34:SaveHAdder:save high byte here
P:0B38::mask out high nybble of block buffer pointer
P:0B3A::multiply by 2 to get appropriate name table low byte
P:0B3B::and then store it here
P:0B3F::initialize temp high byte
P:0B41::get vertical high nybble offset used in block buffer routine
P:0B44::add 32 pixels for the status bar
P:0B47::shift and rotate d7 onto d0 and d6 into carry
P:0B4A::shift and rotate d6 onto d0 and d5 into carry
P:0B4C::add low byte of name table and carry to vertical high nybble
P:0B4E::and store here
P:0B50::get whatever was in d7 and d6 of vertical high nybble
P:0B52::add carry
P:0B55::then add high byte of name table
P:0B57::store here
P:0B59::get vram buffer offset to be used
P:0B5B:RemBridge:write top left and top right
P:0B5E::tile numbers into first spot
P:0B67::write bottom left and bottom
P:0B6A::right tiles numbers into
P:0B6D::second spot
P:0B75::write low byte of name table
P:0B78::into first slot as read
P:0B79::add 32 bytes to value
P:0B7B::write low byte of name table
P:0B7E::plus 32 bytes into second slot
P:0B80::write high byte of name
P:0B83::table address to both slots
P:0B88::put length of 2 in
P:0B8B::both slots
P:0B90::put null terminator at end
P:0B93::get offset control bit here
P:0B95::and leave
P:0B96:WaterPaletteData:-------------------------------------------------------------------------------------\nMETATILE GRAPHICS TABLE
P:0BBA:GroundPaletteData
P:0BDE:UndergroundPaletteData
P:0C02:CastlePaletteData
P:0C26:DaySnowPaletteData
P:0C2E:NightSnowPaletteData
P:0C36:MushroomPaletteData
P:0C5A:BowserPaletteData
P:0C62:MarioThanksMessage:"THANK YOU MARIO!"
P:0C76:LuigiThanksMessage:"THANK YOU LUIGI!"
P:0C8A:MushroomRetainerSaved:"BUT OUR PRINCESS IS IN"
P:0CA3::"ANOTHER CASTLE!"
P:0CB6:MushRoomRetainerGlitchWorld
P:0CE4:PrincessSaved1
P:0CFA:PrincessSaved2
P:0D10:WorldSelectMessage1
P:0D24:WorldSelectMessage2
P:0D35:PSBN:-------------------------------------------------------------------------------------\n$00 - used to store status bar nybbles\n$02 - used as temp vram offset\n$03 - used to store length of status bar number\nstatus bar name table offset and length data
P:0D39:PrintStatusBarNumbers:store player-specific offset
P:0D3B::use first nybble to print the coin display
P:0D3E::move high nybble to low
P:0D44:OutputNumbers:add 1 to low nybble
P:0D47::mask out high nybble
P:0D4D::save incremented value to stack for now and
P:0D4E::shift to left and use as offset
P:0D50::get current buffer pointer
P:0D57::put at top of screen by default
P:0D59::are we writing top score on title screen?
P:0D5D::if so, put further down on the screen
P:0D5F:SetupNums
P:0D62::write low vram address and length of thing
P:0D65::we're printing to the buffer
P:0D6E::save length byte in counter
P:0D72::pull original incremented value from stack
P:0D74::load offset to value we want to write
P:0D78::subtract from length byte we read before
P:0D7B::use value as offset to display digits
P:0D7E:DigitPLoop:write digits to the buffer
P:0D86::do this until all the digits are written
P:0D8A::put null terminator at end
P:0D8F::increment buffer pointer by 3
P:0D92::store it in case we want to use it again
P:0D95:ExitOutputN
P:0D9B:DigitsMathRoutine:-------------------------------------------------------------------------------------\ncheck mode of operation
P:0DA0::if in title screen mode, branch to lock score
P:0DA4:AddModLoop:load digit amount to increment
P:0DA8::add to current digit
P:0DAB::if result is a negative number, branch to subtract
P:0DAF::if digit greater than $09, branch to add
P:0DB1:StoreNewD:store as new score or game timer digit
P:0DB4::move onto next digits in score or game timer
P:0DB5::and digit amounts to increment
P:0DB6::loop back if we're not done yet
P:0DB8:EraseDMods:store zero here
P:0DBA::start with the last digit
P:0DBC:EraseMLoop:initialize the digit amounts to increment
P:0DC0::do this until they're all reset, then leave
P:0DC3:BorrowOne:decrement the previous digit, then put $09 in
P:0DC6::the game timer digit we're currently on to "borrow
P:0DC8::the one", then do an unconditional branch back
P:0DCA:CarryOne
P:0DD8::subtract ten from our digit to make it a
P:0DD9::proper BCD number, then increment the digit
P:0DDB::preceding current digit to "carry the one" properly
P:0DDE::go back to just after we branched here
P:0DE1:UpdateTopScore:-------------------------------------------------------------------------------------\n        ldx BowserFront_Offset\n        lda Enemy_ID,x\n        cmp #Bowser\n        bne +\n         lda Enemy_State,x\n        lda OperMode\n        cmp #$02\n        beq +\n        lda BowserHitPoints\n        beq CODE\n        cmp #$ff\n        beq CODE\n+\n        rts\n        CODE:\n        JMP HandleAxeMetatile\nrts
P:0DE2:DefaultSprOffsets:-------------------------------------------------------------------------------------
P:0DF1:InitializeGame:-------------------------------------------------------------------------------------\nclear all memory as in initialization procedure,
P:0DF3::but this time, clear only as far as $076f
P:0DF8:ClrSndLoop:clear out memory used
P:0DFB::by the sound engines
P:0E01::set demo timer
P:0E0E:InitializeArea
P:0E2B::sty HurryUp
P:0E31::clear all memory again, only as far as $074b
P:0E33::this is only necessary if branching from
P:0E44:ClrTimersLoop:clear out memory between
P:0E47::$0780 and $07a1
P:0E4D::if AltEntranceControl not set, use halfway page, if any found
P:0E52::otherwise use saved entry page number here
P:0E55:StartPage:set as value here
P:0E5B::set flag here if halfway page or saved entry page number found
P:0E60::also set as current page
P:0E63::get coordinate of screen's left boundary
P:0E67::add 255 pixels
P:0E69::store as coordinate of screen's right boundary
P:0E6C::get page number where left boundary is
P:0E6F::add carry from before
P:0E71::store as page number where right boundary is
P:0E74::lda EntrancePage\nbne +
P:0E7F::if on odd numbered page, use $2480 as start of rendering
P:0E81::otherwise use $2080, this address used later as name table
P:0E83::address for rendering of game area
P:0E87:SetInitNTHigh:store name table address
P:0E8C::ldx EntrancePage\nbeq +\nldy #$94
P:0E8F::store LSB of page number in high nybble
P:0E90::of block buffer column position
P:0EA0::set value for renderer to update 12 column sets
P:0EA2::12 column sets = 24 metatile columns = 1 1/2 screens
P:0EA5::get enemy and level addresses and load header
P:0EA8::check to see if primary hard mode has been activated
P:0EAB::if so, activate the secondary no matter where we're at
P:0EB0::if less than 5, do not activate secondary
P:0EB4::if not equal to, then world > 5, thus activate
P:0EB6::otherwise, world 5, so check level number
P:0EB9::if 1 or 2, do not set secondary hard mode flag
P:0EBD:SetSecHard:set secondary hard mode flag for areas 5-3 and beyond
P:0EC0:CheckHalfway
P:0ECA::if halfway page set, overwrite start position from header
P:0ECF:DoneInitArea:silence music
P:0EE2::disable screen output
P:0EF3::increment one of the modes
P:0F17::add #$01
P:0F33::			   ldy #$00\n			   lda #$00\n-:			   sta Saved_ID,y\n			   sta Saved_X_Position,y\n			   sta Saved_Y_Position,y\n			   sta Saved_PageLoc,y\n			   ;sta Saved_isDefeated,y\n			   iny\n			   cpy #$80\n			   bne -\n			   lda #$02\n			   sta Saved_isDefeated\n			   sta Saved_isDefeated+1\n			   sta Saved_isDefeated+2\n			   sta Saved_isDefeated+3\n			   sta Saved_isDefeated+4\n			   sta Saved_isDefeated+5\n			   lda #$00\n-:			   tya\n			   sta SavedOffset,y\n			   tay\n			   iny\n			   cpy #$06\n			   bne -
P:0F4C:PrimaryGameSetup:rts\n-------------------------------------------------------------------------------------
P:0F54::set flag to load game timer from header
P:0F57::set player's size to small
P:0F5C::give each player five lives
P:0F5F:SecondaryGameSetup:lda NumberofLives-OnscreenPlayerInfo\nsta OffScr_NumberofLives
P:0F61::enable screen output
P:0F65:ClearVRLoop:clear buffer at $0300-$03ff
P:0F6B:ClearVRLoo2:clear buffer at $0300-$03ff
P:0F71::clear game timer exp flag
P:0F74::clear skip lives display flag
P:0F77::clear value here
P:0F7C::initialize balance platform assignment flag
P:0F7F::get left side page location
P:0F82::mask out all but LSB of page location
P:0F84::this is to set the proper PPU name table
P:0F87::load proper music into queue
P:0F8A::load sprite shuffle amounts to be used later
P:0F99::load default OAM offsets into $06e4-$06f2
P:0F9B:ShufAmtLoop
P:0FA1::do this until they're all set
P:0FA7::increment to next task
P:0FC0::get player colors
P:0FC3:MusicSelectData
P:0FCA:GetAreaMusic:if in title screen mode, leave
P:0FCF::check for specific alternate mode of entry
P:0FD2::if found, branch without checking starting position
P:0FD4::from area object data header
P:0FD6::select music for pipe intro scene by default
P:0FD8::check value from level header for certain values
P:0FDD::load music for pipe intro scene if header
P:0FDF::start position either value $06 or $07
P:0FE3:ChkAreaType
P:0FF1::load area type as offset for music bit
P:0FF7::check for cloud type override
P:0FF9::select music for cloud type level if found
P:0FFB:StoreMusic:otherwise select appropriate music for level type
P:1007::store in queue and leave
P:1009:ExitGetM
P:100A:WorldNumberOffsetY:-------------------------------------------------------------------------------------
P:1013:Wo1
P:1013:YposLevelOffset
P:1018:Wo2
P:101D:Wo3
P:1021:Wo4
P:1025:Wo5
P:1029:Wo6
P:102D:Wo7
P:1032:Wo8
P:1036:Wo9
P:103B:Entrance_GameTimerSetup
P:103E::ldy EntrancePage\nbeq +\nlda ScreenLeft_PageLoc      ;set current page for area objects\nclc\nadc #$01\nas page location for player
P:1043::store value here
P:1046::for fractional movement downwards if necessary
P:1049::set high byte of player position and
P:104B::set facing direction so that player faces right
P:104F::set player state to on the ground by default
P:1052::initialize player's collision bits
P:1055::initialize halfway page
P:1059::check area type
P:105C::if water type, set swimming flag, otherwise do not set
P:105F:ChkStPos
P:1062::get starting position loaded from header
P:1065::check alternate mode of entry flag for 0 or 1
P:106E::if not 0 or 1, override $0710 with new offset in X
P:1071:SetStPos:load appropriate horizontal position
P:1074::and vertical positions for the player, using
P:1076::lda EntrancePage
P:1082::lda ScreenRight_PageLoc\nadc #$00\nsta ScreenRight_PageLoc
P:1095::set player sprite attributes using offset in X
P:1098::lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
P:10B3::or value that overwrote $0710 as offset for vertical
P:10B5::get appropriate player palette
P:10B8::get timer control value from header
P:10BB::if set to zero, branch (do not use dummy byte for this)
P:10BD::do we need to set the game timer? if not, use 
P:10C0::old game timer setting
P:10C2::if game timer is set and game timer flag is also set,
P:10C5::use value of game timer control for first digit of game timer
P:10D8::set last digit of game timer to 1
P:10DE::set second digit of game timer
P:10E3::clear flag for game timer reset
P:10E9::clear star mario timer
P:10EC:ChkOverR:if controller bits not set, branch to skip this part
P:10F1::set player state to climbing
P:10F5::set offset for first slot, for block object
P:10FA::set vertical coordinate for block object
P:10FE::set offset in X for last enemy object buffer slot
P:1100::set offset in Y for object coordinates used earlier
P:1102::do a sub to grow vine
P:1105:ChkSwimE:set to run player entrance subroutine
P:1105:SetPESub
P:1107::on the next frame of game engine
P:1111:putpspeeddisplay
P:1120::lda #$28\nsta VRAM_Buffer1+3,y
P:1133:FirstSprXPos
P:1137:FirstSprYPos
P:113B:SecondSprXPos
P:113F:SecondSprYPos
P:1143:FirstSprTilenum
P:1147:SecondSprTilenum
P:114B:HammerSprAttrib
P:114F:JumpingCoinTiles
P:1153:PlayerLoseLife:-------------------------------------------------------------------------------------\npage numbers are in order from -1 to -4\nHalfwayPageNybbles:\n      .db $56, $40\n      .db $65, $70\n      .db $66, $40\n      .db $66, $40\n      .db $66, $40\n      .db $66, $60\n      .db $65, $70\n      .db $00, $00\ndisable screen and sprite 0 check
P:115B::silence music
P:115F::take one life from player
P:1167::if player still has lives, branch
P:116B::initialize mode task,
P:116E::switch to game over mode
P:1170::and leave
P:1174:StillInGame:beginning of the level
P:1176::store as halfway page for player
P:1179::jsr TransposePlayers     ;switch players around if 2-player game\ncontinue the game
P:117C:GameOverMode:-------------------------------------------------------------------------------------
P:1188:SetupGameOver:-------------------------------------------------------------------------------------\nreset screen routine task control for title screen, game,
P:118A::and game over modes
P:118D::disable sprite 0 check
P:1190::set continue as default choice
P:1194::put game over music in secondary queue
P:1196::disable screen output
P:1199::set secondary mode to 1
P:119D:RunGameOver:-------------------------------------------------------------------------------------\nreenable screen
P:11A2::lda WorldNumber       ;if on world 8, branch on to end the game\ncmp #FinalWorld\nbeq W8End\notherwise run game over menu
P:11AD:W8End
P:11B2:TerminateGame:check controller for start pressed\nif not pressed, wait for\nscreen timer to expire\nsilence music
P:11B6::otherwise put world number of current
P:11B9::player into secret continue function variable
P:11BE::reset all modes to title screen and
P:11C1::leave
P:11D0:ExRGO
P:11D1:ContinueGame:update level pointer with
P:11D4::actual world and area numbers, then
P:11D6::reset player's size, status, and
P:11D9::set game timer flag to reload
P:11DC::game timer from header
P:11DE::also set flag for timers to count again
P:11E4::reset task for game core
P:11E6::set modes and leave
P:11E9::if in game over mode, switch back to
P:11EE::game mode, because game is still on
P:11F4:GameIsOn
P:11F5:ExTrans:           ldx #$06\nTransLoop: lda OnscreenPlayerInfo,x    ;transpose the information\n           pha                         ;of the onscreen player\n           lda OffscreenPlayerInfo,x   ;with that of the offscreen player\n           sta OnscreenPlayerInfo,x\n           pla\n           sta OffscreenPlayerInfo,x\n           dex\n           bpl TransLoop\nsec\nlda NumberOfPlayers       ;if only a 1 player game, leave\nbeq ExTrans\nclear carry flag to get game going\nrts\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n These two includes aren't quite as self-contained as They could be\n 0x1cc4, 0x1226\ninclude tools\output.txt\ninclude code\levelData.asm\ninclude code\levelData_great.asm
P:11F5:LevelDataStart
P:11F5:TransposePlayers
P:11F6:GameMode:-------------------------------------------------------------------------------------\nindirect jump routine called when\nOperMode is set to 1
P:120C:GameCoreRoutine:-------------------------------------------------------------------------------------\nlda CurrentPlayer\nand #%00000001\ntax\nldx CurrentPlayer          ;get which player is on the screen\nlda SavedJoypadBits;,x      ;use appropriate player's controller bits\nsta SavedJoypadBits        ;as the master controller bits\nexecute one of many possible subs
P:120F::check major task of operating mode
P:1212::if we are supposed to be here,
P:1214::branch to the game engine itself
P:1217:GameEngine:check player's status
P:121C::if not fiery, branch
P:121E::process fireballs and air bubbles
P:1223::put incremented offset in X as enemy object offset
P:1225::process enemy objects
P:1228::load control for floatey number
P:122D::process floatey numbers
P:1230::
P:1231::do these two subroutines until the whole buffer is done
P:1235::set offsets for player-specific variables
P:1237::save offscreen bits offset to stack for now
P:1239::do subroutine here
P:1240::store here
P:1249::mask together with previously saved low nybble
P:124B::store both here
P:124D::get offscreen bits offset from stack
P:124F::get value here and store elsewhere
P:1254::ldx ObjectOffset\nset offsets for relative cooordinates
P:1256::routine to correspond to player object
P:1258::load vertical coordinate low
P:125A::store here
P:125D::load horizontal coordinate
P:125F::subtract left edge coordinate
P:1263::store result here
P:1268::draw the player
P:126B::replace block objects with metatiles if necessary
P:1270::set offset for second
P:1272::process second block object
P:1276::set offset for first
P:1278::process first block object
P:127B::process misc objects (hammer, jumping coins)
P:127E::process bullet bill cannons
P:1281::lda FramesMissed\n beq +\n dec FramesMissed\nlda AreaType\nbne +\njsr ProcessWhirlpools      ;process whirlpools
P:12A1::if flagpole flag not found,
P:12A3::branch to leave
P:12AD::process the flagpole
P:12B0::count down the game timer
P:12B5::if player is below the screen, don't bother with the music
P:12C0::to re-attain appropriate level music
P:12CB::if star mario invincibility timer at zero,
P:12CE::skip this part
P:12E9::if not yet at a certain point, continue
P:12EB::if interval timer not yet expired,
P:12EE::branch ahead, don't bother with the music
P:12F0::to re-attain appropriate level music
P:12F3:NoChgMus:get invincibility timer
P:12F6::get frame counter
P:12F8::if timer still above certain point,
P:12FA::branch to cycle player's palette quickly
P:12FC::otherwise, divide by 8 to cycle every eighth frame
P:12FE:CycleTwo:if branched here, divide by 2 to cycle every other frame
P:12FF::do sub to cycle the palette (note: shares fire flower code)
P:1302::then skip this sub to finish up the game engine
P:1305:ClrPlrPal:do sub to clear player's palette bits in attributes
P:1308:SaveAB:save current A and B button
P:130A::into temp variable to be used on next frame
P:130E::nullify left and right buttons temp variable
P:1310:UpdScrollVar
P:1313::if vram address controller set to 6 (one of two $0341s)
P:1315::then branch to leave
P:1317::otherwise check number of tasks
P:1321::get horizontal scroll in 0-31 or $00-$20 range
P:1324::check to see if exceeded $21
P:1326::branch to leave if not
P:132B::otherwise subtract $20 to set appropriately
P:132D::and store
P:1341::reset vram buffer offset used in conjunction with
P:1343::level graphics buffer at $0341-$035f
P:1346:RunParser:update the name table with more level graphics
P:1349:ExitEng:and after all that, we're finally done!
P:134A:ScrollHandler:-------------------------------------------------------------------------------------\nload value saved here
P:134E::add value used by left/right platforms
P:1354::save as new value here to impose force on scroll
P:135C::check scroll lock flag
P:1362::skip a bunch of code here if set
P:1389:InitScrlAmt1
P:139B::check player's horizontal screen position
P:139D::if less than 80 pixels to the right, branch
P:13A6::if timer related to player's side collision
P:13A9::not expired, branch
P:13AB::get value and decrement by one
P:13AE::if value originally set to zero or otherwise
P:1451::get value and decrement by one
P:1454::if value originally set to zero or otherwise
P:1455::negative for left movement, branch
P:145A:oooooooooooooo
P:145D:ohnoeswillyrex1
P:1466::if value $01, branch and do not decrement
P:146A::otherwise decrement by one
P:146B:ChkNearMid:otherwise get original value undecremented
P:146E:ScrollScreen:lda IRQAckFlag\nbne ScrollScreen
P:147D::save value here
P:1481::add to value already set here
P:1484::save as new value here
P:1489::add to left side coordinate
P:148C::save as new left side coordinate
P:148F::save here also
P:1495::add carry to page location for left
P:1497::side of the screen
P:149A::get LSB of page location
P:149C::save as temp variable for PPU register 1 mirror
P:14E6::ldy FramesMissed\nbeq ++\nlda ParallaxOffset\nbeq ++\nlda ScrollAmount\nbeq ++\ndec ParallaxOffset
P:14E9:ohnoeswillyrex
P:14EA::save value here
P:14EE::add to value already set here
P:14F1::save as new value here
P:14F6::add to left side coordinate
P:14F9::save as new left side coordinate
P:14FF::ldy FramesMissed\nbeq +\ninc ParallaxOffset\nsave here also
P:1505::add carry to page location for left
P:1507::side of the screen
P:150A::get LSB of page location
P:150C::save as temp variable for PPU register 1 mirror
P:150F:llorica
P:1529::get coordinate of screen's left boundary
P:152D::add 255 pixels
P:152F::store as coordinate of screen's right boundary
P:1532::get page number where left boundary is
P:1535::add carry from before
P:1537::store as page number where right boundary is
P:153A::skip this part
P:153D:InitScrlAmt
P:153F::initialize value here
P:1542:ChkPOffscr:set X for player offset
P:1544::get horizontal offscreen bits for player
P:1547::save them here
P:1549::load default offset (left side)
P:154B::if d7 of offscreen bits are set,
P:154C::branch with default offset
P:154E::otherwise use different offset (right side)
P:1551::check offscreen bits for d5 set
P:1553::if not set, branch ahead of this part
P:1555:KeepOnscr:get left or right side coordinate based on offset
P:1559::subtract amount based on offset
P:155C::store as player position to prevent movement further
P:155E::get left or right page location based on offset
P:1561::subtract borrow
P:1563::save as player's page location
P:1565::check saved controller bits
P:1567::against bits based on offset
P:156A::if not equal, branch
P:156E::otherwise nullify horizontal speed of player
P:1570:InitPlatScrl:nullify platform force imposed on scroll
P:1576:X_SubtracterData
P:1578:OffscrJoypadBitsData
P:157A:GameRoutines:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\nrun routine based on number (a few of these routines are   
P:157C::merely placeholders as conditions for other routines)
P:157F::00
P:1581::01
P:1583::02
P:1585::03
P:1587::04
P:1589::05
P:158B::06
P:158D::07
P:158F::08
P:1591::09
P:1593::0a
P:1595::0b
P:1597::0c
P:1599::0d
P:159B:PlayerEntrance:.dw DoorEntry				;0e\n-------------------------------------------------------------------------------------\ncheck for mode of alternate entry
P:15A0::if found, branch to enter from pipe or with vine
P:15A4::if vertical position above a certain
P:15A6::point, nullify controller bits and continue
P:15A8::with player movement code, do not return
P:15AA::check player entry bits from header
P:15AF::if set to 6 or 7, execute pipe intro code
P:15B1::otherwise branch to normal entry
P:15B5:ChkBehPipe:check for sprite attributes
P:15B8::branch if found
P:15BC:AutoControlPlayer1
P:15CC::force player to walk to the right
P:15CF:IntroEntr:execute sub to move player to the right
P:15D2::decrement timer for change of area
P:15D5::branch to exit if not yet expired
P:15D7::set flag to skip world and lives display
P:15DA::jump to increment to next area and set modes
P:15DD:EntrMode2:if controller override bits set here,
P:15E0::branch to enter with vine
P:15E2::otherwise, set value here then execute sub
P:15E4::to move player upwards (note $ff = -1)
P:15E7::check to see if player is at a specific coordinate
P:15E9::if player risen to a certain point (this requires pipes
P:15EB::to be at specific height to look/function right) branch
P:15ED::to the last part, otherwise leave
P:15EE:VineEntr
P:15F1::check vine height
P:15F3::if vine not yet reached maximum height, branch to leave
P:15F5::get player's vertical coordinate
P:15F7::check player's vertical coordinate against preset value
P:15F9::load default values to be written to 
P:15FB::this value moves player to the right off the vine
P:15FD::if vertical coordinate < preset value, use defaults
P:1601::otherwise set player state to climbing
P:1603::increment value in Y
P:1604::set block in block buffer to cover hole, then 
P:1606::use same value to force player to climb
P:1609:OffVine:set collision detection disable flag
P:160C::use contents of A to move player up or right, execute sub
P:1611::check player's horizontal position
P:1613::if not far enough to the right, branch to leave
P:1615:PlayerRdy:set routine to be executed by game engine next frame
P:1619::set to face player to the right
P:161D::init A
P:161E::init mode of entry
P:1621::init collision detection disable flag
P:1624::nullify controller override bits
P:1637:ExitEntr:leave!
P:1638:AutoControlPlayer:-------------------------------------------------------------------------------------\n$07 - used to hold upper limit of high byte when player falls down hole\noverride controller bits with contents of A if executing here
P:163B:PlayerCtrlRoutine:check task here
P:163D::if certain value is set, branch to skip controller bit loading
P:164B::if not in vertical area between
P:164C::status bar and bottom, branch	
P:1650::if nearing the bottom of the screen or
P:1652::not in the vertical area between status bar or bottom,
P:1654:DisJoyp:disable controller bits
P:1659:SaveJoyp:otherwise store A and B buttons in $0a
P:1660::store left and right buttons in $0c
P:166C::store up and down buttons in $0b
P:1673::check for pressing down
P:1675::if not, branch
P:1677::check player's state
P:1679::if not on the ground, branch
P:167B::check left and right
P:167D::if neither pressed, branch
P:1681::if pressing down while on the ground,
P:1683::nullify directional bits
P:1685:SizeChk:run movement subroutines
P:1688::is player small?
P:1699::check for if crouching
P:169E::if not, branch ahead
P:16A0::if big and crouching, load y with 2
P:16A2:ChkMoveDir:set contents of Y as player's bounding box size control
P:16A5::set moving direction to right by default
P:16A7::check player's horizontal speed
P:16A9::if not moving at all horizontally, skip this part
P:16AB::if moving to the right, use default moving direction
P:16AD::otherwise change to move to the left
P:16AE:SetMoveDir:set moving direction
P:16B0:PlayerSubs:move the screen if necessary
P:16B3::set offsets for player-specific variables
P:16B5::and get offscreen information about player
P:16B7::save offscreen bits offset to stack for now
P:16B9::do subroutine here
P:16C0::store here
P:16C9::mask together with previously saved low nybble
P:16CB::store both here
P:16CD::get offscreen bits offset from stack
P:16CF::get value here and store elsewhere
P:16D6::get coordinates relative to the screen
P:16D9::set offset for player object
P:16DB::get player's bounding box coordinates
P:16DE::do collision detection and process
P:16F0::check to see if player is higher than 64th pixel
P:16F2::if so, branch ahead
P:16F6::if running end-of-level routine, branch ahead
P:16FA::if running player entrance routine, branch ahead
P:16FE::if running routines $00-$03, branch ahead
P:1709::otherwise nullify player's
P:170B::background priority flag
P:170E:PlayerHole:check player's vertical high byte
P:1710::for below the screen
P:1712::branch to leave if not that far down
P:1739::set scroll lock
P:1741::set value here
P:1743::use X as flag, and clear for cloud level
P:1745::check game timer expiration flag
P:1748::if set, branch
P:174A::check for cloud type override
P:174D::skip to last part if found
P:174F:HoleDie:set flag in X for player death
P:1752::check for some other routine running
P:1754::if so, branch ahead
P:175B::check value here
P:175E::if already set, branch to next part
P:1761::otherwise play death music
P:1763::and set value here
P:1766:HoleBottom
P:1768::change value here
P:176A:ChkHoleX:compare vertical high byte with value set here
P:176C::if less, branch to leave
P:176E::otherwise decrement flag in X
P:176F::if flag was clear, branch to set modes and other values
P:1771::check to see if music is still playing
P:1774::branch to leave if so
P:1776::otherwise set to run lose life routine
P:1778::on next frame
P:177A:ExitCtrl:leave
P:177B:CloudExit
P:177D::clear controller override bits if any are set
P:1780::do sub to set secondary mode
P:1783::set mode of entry to 3
P:1787:Vine_AutoClimb:-------------------------------------------------------------------------------------\ncheck to see whether player reached position
P:1789::above the status bar yet and if so, set modes
P:1791:AutoClimb:set controller bits override to up
P:1796::set player state to climbing
P:179D:SetEntr:set starting position to override
P:17A2::set modes
P:17A5:VerticalPipeEntry:-------------------------------------------------------------------------------------
P:17B3::set 1 as movement amount
P:17B5::do sub to move player downwards
P:17B8::do sub to scroll screen with saved force if necessary
P:17BB::load default mode of entry
P:17BD::check warp zone control variable/flag
P:17C0::if set, branch to use mode 0
P:17C3::check for castle level type
P:17C8::if not castle type level, use mode 1
P:17CB::otherwise use mode 2
P:17CE:MovePlayerYAxis
P:17CF::add contents of A to player position
P:17D4:UpsideDownPipeEntry
P:17E5::do sub to move player downwards
P:17E8::do sub to scroll screen with saved force if necessary
P:17EB::load default mode of entry
P:17ED::check warp zone control variable/flag
P:17F0::if set, branch to use mode 0
P:17F3::check for castle level type
P:17F8::if not castle type level, use mode 1
P:17FB::otherwise use mode 2
P:17FE:DoorEntry
P:1809::load default mode of entry
P:180B::check warp zone control variable/flag
P:180E::if set, branch to use mode 0
P:1811::check for castle level type
P:1816::if not castle type level, use mode 1
P:1819::otherwise use mode 2
P:181C:MovePlayerYAxisUp:add contents of A to player position
P:1824:SideExitPipeEntry:-------------------------------------------------------------------------------------\nexecute sub to move player to the right
P:1829:ChgAreaPipe:decrement timer for change of area
P:182E::when timer expires set mode of alternate entry
P:1831:ChgAreaMode:set flag to disable screen output
P:1836::set secondary mode of operation
P:1839::disable sprite 0 check
P:183C:ExitCAPipe:leave
P:183D:EnterSidePipe:set player's horizontal speed
P:1841::set controller right button by default
P:1843::mask out higher nybble of player's
P:1845::horizontal position
P:1849::if lower nybble = 0, set as horizontal speed
P:184B::and nullify controller bit override here
P:184C:RightPipe:use contents of Y to
P:184D::execute player control routine with ctrl bits nulled
P:1850:PlayerChangeSize:-------------------------------------------------------------------------------------\ncheck master timer control
P:1853::for specific moment in time
P:1855::branch if before or after that point
P:1857::otherwise run code to get growing/shrinking going
P:185A:EndChgSize:check again for another specific moment
P:185C::and branch to leave if before or after that point
P:185E::otherwise do sub to init timer control and set routine
P:1861:ExitChgSize:and then leave
P:1862:PlayerInjuryBlink:-------------------------------------------------------------------------------------\ncheck master timer control
P:1865::for specific moment in time
P:1867::branch if before that point
P:1869::check again for another specific point
P:186B::branch if at that point, and not before or after
P:186D::otherwise run player control routine
P:1870:ChangeSiz
P:1872:InitChangeSize:if growing/shrinking flag already set
P:1875::then branch to leave
P:1877::otherwise initialize player's animation frame control
P:1891:ExitBoth:leave
P:1892:PlayerDeath:-------------------------------------------------------------------------------------\n$00 - used in CyclePlayerPalette to store current palette to cycle\ncheck master timer control
P:1895::for specific moment in time
P:1897::branch to leave if before that point
P:18A6::otherwise run player control routine
P:18A9:DonePlayerTask
P:18AB::initialize master timer control to continue timers
P:18B0::set player control routine to run next frame
P:18B2::leave
P:18B3:PlayerFireFlower:check master timer control
P:18B6::for specific moment in time
P:18B8::branch if at moment, not before or after
P:18BA::get frame counter
P:18BD::divide by four to change every four frames
P:18BE:CyclePlayerPalette:mask out all but d1-d0 (previously d3-d2)
P:18C0::store result here to use as palette bits
P:18C2::get player attributes
P:18C5::save any other bits but palette bits
P:18C7::add palette bits
P:18C9::store as new player attributes
P:18CC::and leave
P:18CD:ResetPalFireFlower:do sub to init timer control and run player control routine
P:18D0:ResetPalStar:get player attributes
P:18D3::mask out palette bits to force palette 0
P:18D5::store as new player attributes
P:18D8:ExitDeath:leave from death routine
P:18D9:FlagpoleSlide:-------------------------------------------------------------------------------------
P:18DC::check special use enemy slot
P:18DE::for flagpole flag object
P:18E0::if not found, branch to something residual
P:18EA::load flagpole sound
P:18ED::into square 1's sfx queue
P:18EF::sta OldSquare1SoundBuffer
P:18F1::init flagpole sound queue
P:18F6::check to see if player has slid down
P:18F8::far enough, and if so, branch with no controller bits set
P:18FF::otherwise force player to climb down (to slide)
P:1901:SlidePlayer:jump to player control routine
P:1904:NoFPObj:increment to next routine (this may
P:1906::be residual code)
P:1907:Hidden1UpCoinAmts:-------------------------------------------------------------------------------------
P:190F:PlayerEndLevel
P:191A::force player to walk to the right
P:191F::check player's vertical position
P:1921::if player is not yet off the flagpole, skip this part
P:1923::if scroll lock not set, branch ahead to next part
P:1926::because we only need to do this part once
P:192A::load win level music in event music queue
P:192E::turn off scroll lock to skip this part later
P:1931:ChkStop:get player collision bits
P:1934::check for d0 set
P:1935::if d0 set, skip to next part
P:1937::if star flag task control already set,
P:193A::go ahead with the rest of the code
P:193C::otherwise set task control now (this gets ball rolling!)
P:193F:InCastle:set player's background priority bit to
P:1941::give illusion of being inside the castle
P:1947:RdyNextA
P:194D::if star flag task control not yet set
P:194F::beyond last valid task number, branch to leave
P:1951::increment level number used for game logic
P:1957::check to see if we have yet reached level -4
P:1959::and skip this last part here if not
P:195B:NextArea:inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
P:195E::increment area number used for address loader
P:1961::get new level pointer
P:1964::set flag to load new game timer
P:1967::do sub to set secondary mode, disable screen and sprite 0
P:196A::reset halfway page to 0 (beginning)
P:196F::silence music and leave
P:1971:ExitNA
P:1972:Testi:-------------------------------------------------------------------------------------
P:198A:PlayerMovementSubs:set A to init crouch flag by default
P:198C::is player small?
P:198F::if so, branch
P:1996::check state of player
P:1998::if not on the ground, branch
P:199A::load controller bits for up and down
P:199C::single out bit for down button
P:199E:SetCrouch:store value in crouch flag
P:19A4:ProcMove:run sub related to jumping and swimming
P:19A7::if growing/shrinking flag set,
P:19AA::branch to leave
P:19AE::get player state
P:19B0::if climbing, branch ahead, leave timer unset
P:19B4::otherwise reset timer now
P:19B7:MoveSubs
P:19C2:NoMoveSub
P:19C3:OnGroundStateSub:-------------------------------------------------------------------------------------\n$00 - used by ClimbingSub to store high vertical adder\ndo a sub to set animation frame timing
P:19C8::if left/right controller bits not set, skip instruction
P:19CA::otherwise set new facing direction
P:19CC:GndMove:do a sub to impose friction on player's walk/run
P:19CF::do another sub to move player horizontally
P:19D7::set returned value as player's movement speed for scroll
P:19DB:FallingSub:--------------------------------
P:19DE::dump vertical movement force for falling into main one
P:19E1::movement force, then skip ahead to process left/right movement
P:19E4:ChkWhat:--------------------------------
P:1A0A:JumpSwimSub:if player's vertical speed zero
P:1A0C::or moving downwards, branch to falling
P:1A10::check to see if A button is being pressed
P:1A12::and was pressed in previous frame
P:1A14::if so, branch elsewhere
P:1A23::get vertical position player jumped from
P:1A27::subtract current from original vertical coordinate
P:1A29::compare to value set here to see if player is in mid-jump
P:1A2C::or just starting to jump, if just starting, skip ahead
P:1A2E:DumpFall:otherwise dump falling into main fractional
P:1A34:ProcSwim:if swimming flag not set,
P:1A37::branch ahead to last part
P:1A3D:ExitMS:do a sub to get animation frame timing
P:1A40:LRWater:check left/right controller bits (check for swimming)
P:1A42::if not pressing any, skip
P:1A44::otherwise set facing direction accordingly
P:1A46:LRAir:check left/right controller bits (check for jumping/falling)
P:1A48::if not pressing any, skip
P:1A4A::otherwise process horizontal movement
P:1A4D:JSMove:do a sub to move player horizontally
P:1A50::set player's speed here, to be used for scroll later
P:1A55::check for specific routine selected
P:1A57::branch if not set to run
P:1A5B::otherwise set fractional
P:1A5E:ExitMov1
P:1A63::jump to move player vertically, then grab shell and leave
P:1A69::jump to move player vertically, then leave
P:1A6C:ClimbAdderLow:--------------------------------
P:1A70:ClimbAdderHigh
P:1A74:ClimbingSub
P:1A77::add movement force to dummy variable
P:1A78::save with carry
P:1A7E::set default adder here
P:1A80::get player's vertical speed
P:1A82::if not moving upwards, branch
P:1A84::otherwise set adder to $ff
P:1A85:MoveOnVine:store adder here
P:1A87::add carry to player's vertical position
P:1A89::and store to move player up or down
P:1A8D::add carry to player's page location
P:1A8F::and store
P:1A95::prevent l+r
P:1A9D::compare left/right controller bits
P:1A9F::to collision flag
P:1AA2::if not set, skip to end
P:1AA4::otherwise check timer 
P:1AA7::if timer not expired, branch to leave
P:1AAB::otherwise set timer now
P:1AAE::set default offset here
P:1AB0::get facing direction
P:1AB2::move right button controller bit to carry
P:1AB3::if controller right pressed, branch ahead
P:1AB5::otherwise increment offset by 2 bytes
P:1AB7:ClimbFD:check to see if facing right
P:1AB8::if so, branch, do not increment
P:1ABA::otherwise increment by 1 byte
P:1ABB:CSetFDir
P:1ABD::add or subtract from player's horizontal position
P:1ABE::using value here as adder and X as offset
P:1AC3::add or subtract carry or borrow using value here
P:1AC5::from the player's page location
P:1ACA::get left/right controller bits again
P:1ACC::invert them and store them while player
P:1ACE::is on vine to face player in opposite direction
P:1AD0:ExitCSub:then leave
P:1AD1:InitCSTimer:initialize timer here
P:1AD5:Luigi_JumpMForceData:-------------------------------------------------------------------------------------\n$00 - used to store offset to friction data\n Luigi
P:1ADC:Luigi_FallMForceData
P:1AE3:Luigi_FrictionData
P:1AE6:Enemy_PSwitch:.db $b4, $68, $a0
P:1B02::store in queue and leave
P:1B0B::initialize vertical speed and fractional
P:1B10:JumpMForceData
P:1B17:FallMForceData
P:1B1E:PlayerYSpdData
P:1B25:InitMForceData
P:1B2C:MaxLeftXSpdData
P:1B33:MaxRightXSpdData
P:1B3A::used for pipe intros
P:1B3B:FrictionData
P:1B3E:Climb_Y_SpeedData
P:1B41:Climb_Y_MForceData
P:1B44:PlayerPhysicsSub:check player state
P:1B48::if not climbing, branch
P:1B4C::get controller bits for up/down
P:1B4E::check against player's collision detection bits
P:1B51::if not pressing up or down, branch
P:1B54::check for pressing up
P:1B59:ProcClimb:load value here
P:1B5C::store as vertical movement force
P:1B5F::load default animation timing
P:1B61::load some other value here
P:1B64::store as vertical speed
P:1B66::if climbing down, use default animation timing value
P:1B68::otherwise divide timer setting by 2
P:1B69:SetCAnim:store animation timer setting and leave
P:1B85:CheckForJumping
P:1B8F::if jumpspring animating, 
P:1B92::skip ahead to something else
P:1B94::check for A button press
P:1B98::if not, branch to something else
P:1B9A::if button not pressed in previous frame, branch
P:1B9E:NoJump
P:1BA3::otherwise, jump to something else
P:1BA6:ProcJumping
P:1BAB::check player state
P:1BAD::if on the ground, branch
P:1BAF::if swimming flag not set, jump to do something else
P:1BB2::to prevent midair jumping, otherwise continue
P:1BB9::if jump/swim timer nonzero, branch
P:1BBE::check player's vertical speed
P:1BC0::if player's vertical speed motionless or down, branch
P:1BC2::if timer at zero and player still rising, do not swim
P:1BC5:InitJS:set jump/swim timer
P:1BCA::initialize vertical force and dummy variable
P:1BD2::get vertical high and low bytes of jump origin
P:1BD4::and store them next to each other here
P:1BDC::set player state to jumping/swimming
P:1BE0::check value related to walking/running speed
P:1BE5::branch if below certain values, increment Y
P:1BE7::for each amount equal or exceeded
P:1BF4::note that for jumping, range is 0-4 for Y
P:1BF7:ChkWtr:set value here (apparently always set to 1)
P:1BFC::if swimming flag disabled, branch
P:1C01::otherwise set Y to 5, range is 5-6
P:1C03::if whirlpool flag not set, branch
P:1C08::otherwise increment to 6
P:1C09:GetYPhy:check which player is on the screen
P:1C0E::store appropriate jump/swim
P:1C11::data here
P:1C1D::store appropriate jump/swim
P:1C20::data here
P:1C29::store appropriate jump/swim\ndata here
P:1C39::if swimming flag disabled, branch
P:1C3E::load swim/goomba stomp sound into
P:1C40::square 1's sfx queue
P:1C42::from swimming above water level
P:1C45:PJumpSnd:load big mario's jump sound by default
P:1C47::is mario big?
P:1C4C::if not, load small mario's jump sound
P:1C4E:SJumpSnd:store appropriate jump sound in square 1 sfx queue
P:1C50:JumpSubEnd
P:1C56:GetXPhy1
P:1C59:aercono
P:1C6A:X_Physics
P:1C6C::init value here
P:1C70::if not set to run player control routine
P:1C72::on next frame, branch to leave
P:1C92::lda Left_Right_Buttons\nand #Left_Dir\nbne ++
P:1CA3:joe
P:1CCA:vaercono:lda SwimmingFlag\nbeq ProcPRun
P:1CCE::check something that seems to be related
P:1CD1::to mario's speed
P:1CD3::if =>$19 branch here
P:1CDA::if not branch elsewhere
P:1CDC:ProcPRun:if mario on the ground, increment Y
P:1CE7::decrement Y by default for non-water type area
P:1CE8::get left/right controller bits
P:1CEA::check against moving direction
P:1CEC::if controller bits <> moving direction, skip this part
P:1CF7::check for b button pressed
P:1CFB::if pressed, skip ahead to set timer
P:1CFD::check for running timer set
P:1D00::if set, branch
P:1D02:ChkRFast:if running timer not set or level type is water, 
P:1D03::increment Y again and temp variable in memory
P:1D08::if running speed set here, branch
P:1D0D::otherwise check player's walking/running speed
P:1D0F::if less than a certain amount, branch ahead
P:1D11:FastXSp:if running speed set or speed => $21 increment $00
P:1D13::and jump ahead
P:1D16:SetRTmr:lda PreviousA_B_Buttons\nand #B_Button\nbeq +
P:1D54::if b button pressed, set running timer
P:1D59:GetXPhy:get maximum speed to the left
P:1D5F::check for specific routine running
P:1D61::(player entrance)
P:1D63::if not running, skip and use old value of Y
P:1D65::otherwise set Y to 3
P:1D67:GetXPhy2
P:1DA7::if not set to run player control routine
P:1DDD::if not set to run player control routine
P:1DEF:setstoopid
P:1DF5::get maximum speed to the right
P:1DFB::get other value in memory
P:1E04::check which player is on the screen
P:1E09::get value using value in memory as offset
P:1E0F::get value using value in memory as offset
P:1E12::get value using value in memory as offset
P:1E17::init something here
P:1E1C::check facing direction against moving direction
P:1E1E::if the same, branch to leave
P:1E20::otherwise shift d7 of friction adder low into carry
P:1E23::then rotate carry onto d0 of friction adder high
P:1E26:ExitPhy:and then leave
P:1E27:PlayerAnimTmrData:-------------------------------------------------------------------------------------
P:1E2A:GetPlayerAnimSpeed:initialize offset in Y
P:1E2C::check player's walking/running speed
P:1E2F::against preset amount
P:1E31::if greater than a certain amount, branch ahead
P:1E33::otherwise increment Y
P:1E34::compare against lower amount
P:1E36::if greater than this but not greater than first, skip increment
P:1E38::otherwise increment Y again
P:1E39:ChkSkid:get controller bits
P:1E3C::mask out A button
P:1E3E::if no other buttons pressed, branch ahead of all this
P:1E40::mask out all others except left and right
P:1E42::check against moving direction
P:1E44::if left/right controller bits <> moving direction, branch
P:1E46::otherwise set zero value here
P:1E48:SetRunSpd:store zero or running speed here
P:1E4E:ProcSkid:check player's walking/running speed
P:1E51::against one last amount
P:1E53::if greater than this amount, branch
P:1E57::otherwise use facing direction to set moving direction
P:1E5B::nullify player's horizontal speed
P:1E5D::and dummy variable for player
P:1E60:SetAnimSpd:get animation timer setting using Y as offset
P:1E67:ImposeFriction:-------------------------------------------------------------------------------------
P:1E72::perform AND between left/right controller bits and collision flag
P:1E75::cmp #$00                  ;then compare to zero (this instruction is redundant)\nif any bits set, branch to next part
P:1E79::if player has no horizontal speed, branch ahead to last part
P:1E7B::if player moving to the right, branch to slow
P:1E7D::otherwise logic dictates player moving left, branch to slow
P:1E7F:JoypFrict:put right controller bit into carry
P:1E80::if left button pressed, carry = 0, thus branch
P:1E82:LeftFrict:load value set here
P:1E86::add to it another value set here
P:1E89::store here
P:1E8E::add value plus carry to horizontal speed
P:1E91::set as new horizontal speed
P:1E93::compare against maximum value for right movement
P:1E96::if horizontal speed greater negatively, branch
P:1E98::otherwise set preset value as horizontal speed
P:1E9B::thus slowing the player's left movement down
P:1E9D::skip to the end
P:1EA0:RghtFrict:load value set here
P:1EA4::subtract from it another value set here
P:1EA7::store here
P:1EAC::subtract value plus borrow from horizontal speed
P:1EAF::set as new horizontal speed
P:1EB1::compare against maximum value for left movement
P:1EB4::if horizontal speed greater positively, branch
P:1EB6::otherwise set preset value as horizontal speed
P:1EB9::thus slowing the player's right movement down
P:1EBB:XSpdSign:if player not moving or moving to the right,
P:1EBD::branch and leave horizontal speed value unmodified
P:1EC1::otherwise get two's compliment to get absolute
P:1EC2::unsigned walking/running speed
P:1EC4:SetAbsSpd:store walking/running speed here and leave
P:1EC7:NoFBall3
P:1EC8:ProcFireball_Bubble:-------------------------------------------------------------------------------------\n$00 - used to store downward movement force in FireballObjCore\n$02 - used to store maximum vertical speed in FireballObjCore\n$07 - used to store pseudorandom bit in BubbleCheck\nCheckForACE:\n	  lda Enemy_X_Position\n	  sta $7001\n	  lda Up_Down_Buttons\n	  and #Up_Dir\n	  beq +\n	  lda Up_Down_Buttons\n	  and #Down_Dir\n	  beq + \n	  jmp $7002\n+:	  lda A_B_Buttons\n	  and #B_Button\n	  beq +\n	  and PreviousA_B_Buttons\n	  bne +\n	  lda Up_Down_Buttons\n	  and #Up_Dir\n	  beq +\n	  ldy $7000\n	  lda Enemy_X_Position\n	  sta $7002,y\n	  inc $7000\n+:	  rts
P:1ECA::check for b button pressed
P:1ECC::branch if not pressed
P:1ED0::if button pressed in previous frame, branch
P:1ED7::load fireball counter
P:1EDA::get LSB and use as offset for buffer
P:1EDD::load fireball state
P:1EDF::if not inactive, branch
P:1EE1::if player too high or too low, branch
P:1EE6::if player crouching, branch
P:1EEB::if player's state = climbing, branch
P:1EF1::play fireball sound effect
P:1EF5::load state
P:1EF9::copy animation frame timer setting
P:1EFC::into fireball throwing timer
P:1F00::decrement and store in player's animation timer
P:1F03::increment fireball counter
P:1F06:ProcFireballs
P:1F08::process first fireball object
P:1F0D::process second fireball object
P:1F10:FireballExplosion:then leave\nHammerObjCore:\n         stx ObjectOffset             ;store offset as current object\nRunHam:  txa                          ;add 7 to offset to use\n         clc                          ;as hammer offset for next routines\n         adc #$07\n         tax\n         jsr ImposeGravity            ;do sub here to impose gravity on hammer and move vertically               ;if any bits still set, branch to kill hammer\n         jsr FireballEnemyCollision   ;do hammer to enemy collision detection and deal with collisions\n         jmp DrawHammer               ;draw hammer appropriately and leave\nNoHam:   rts                          ;leave\nThrowHammers:\n     lda A_B_Buttons\n      and #B_Button              ;check for b button pressed\n      beq ProcHammer          ;branch if not pressed\n      and PreviousA_B_Buttons\n      bne ProcHammer          ;if button pressed in previous frame, branch\n      lda FireballCounter        ;load hammer counter\n      and #%00000001             ;get LSB and use as offset for buffer\n      tax\n      lda Fireball_State,x       ;load hammer state\n      bne ProcHammer          ;if not inactive, branch\n      ldy Player_Y_HighPos       ;if player too high or too low, branch\n      dey\n      bne ProcHammer\n      lda CrouchingFlag          ;if player crouching, branch\n      bne ProcHammer\n     lda Player_State           ;if player's state = climbing, branch\n      cmp #$03\n      beq ProcHammer\n      lda #Sfx_Fireball          ;play fireball sound effect\n      sta Square1SoundQueue\n      lda #$02                   ;load state\n      sta Fireball_State,x\n      ldy PlayerAnimTimerSet     ;copy animation frame timer setting\n      sty FireballThrowingTimer  ;into fireball throwing timer\n      dey\n      sty PlayerAnimTimer        ;decrement and store in player's animation timer\n      inc FireballCounter        ;increment fireball counter\nProcHammer:\n      ldx #$00\n      jsr HammerObjCore  ;process first fireball object\n      ldx #$01\n      jsr HammerObjCore  ;process second fireball object, then do air bubbles\n	  jmp ProcAirBubbles
P:1F13:DrawExplosion_Fireball:get OAM data offset of alternate sort for fireball's explosion
P:1F16::load fireball state
P:1F18::increment state for next frame
P:1F1A::divide by 2
P:1F1B::mask out all but d3-d1
P:1F1D::check to see if time to kill fireball
P:1F1F::branch if so, otherwise continue to draw explosion
P:1F21:DrawExplosion_Fireworks:use whatever's in A for offset
P:1F22::get tile number using offset
P:1F25::increment Y (contains sprite data offset)
P:1F26::into second row sprites
P:1F2C::and into first row sprites
P:1F2F::and dump into tile number part of sprite data
P:1F32::decrement Y so we have the proper offset again
P:1F33::return enemy object buffer offset to X
P:1F35::get relative vertical coordinate
P:1F38::subtract four pixels vertically
P:1F39::for first and third sprites
P:1F41::add eight pixels vertically
P:1F42::for second and fourth sprites
P:1F4A::get relative horizontal coordinate
P:1F4D::subtract four pixels horizontally
P:1F4E::for first and second sprites
P:1F56::add eight pixels horizontally
P:1F57::for third and fourth sprites
P:1F5F::set palette attributes for all sprites, but
P:1F61::set no flip at all for first sprite
P:1F66::set vertical flip for second sprite
P:1F6B::set horizontal flip for third sprite
P:1F70::set both flips for fourth sprite
P:1F73::we are done
P:1F74:KillFireBall:clear fireball state to kill it
P:1F78:NoFBall2
P:1F79:FireballXSpdData
P:1F7B:FireballObjCore:store offset as current object
P:1F7D::check for d7 = 1
P:1F7F::if so, branch to get relative coordinates and draw explosion
P:1F81::if fireball inactive, branch to leave
P:1F85::if fireball state set to 1, skip this part and just run it
P:1F88::get player's horizontal position
P:1F8A::add four pixels and store as fireball's horizontal position
P:1F8E::get player's page location
P:1F90::add carry and store as fireball's page location
P:1F94::get player's vertical position and store
P:1F98::set high byte of vertical position
P:1F9C::get player's facing direction
P:1F9E::decrement to use as offset here
P:1F9F::set horizontal speed of fireball accordingly
P:1FA4::set vertical speed of fireball
P:1FAA::set bounding box size control for fireball
P:1FAD::decrement state to 1 to skip this part from now on
P:1FAF:RunFB:add 7 to offset to use
P:1FB0::as fireball offset for next routines
P:1FB4::set downward movement force here
P:1FB8::set maximum speed here
P:1FBE::do sub here to impose gravity on fireball and move vertically
P:1FC1::do another sub to move it horizontally
P:1FC4::return fireball offset to X
P:1FC6::set for fireball offsets
P:1FC8::move offset to A
P:1FCA::add amount of bytes to offset depending on setting in Y
P:1FD0::load vertical coordinate low
P:1FD2::store here
P:1FD5::load horizontal coordinate
P:1FD7::subtract left edge coordinate
P:1FDB::store result here
P:1FE0::set for fireball offsets
P:1FE2::move offset to A
P:1FE4::add amount of bytes to offset depending on setting in Y
P:1FE8::set other offset for fireball's offscreen bits
P:1FEA::save offscreen bits offset to stack for now
P:1FEC::do subroutine here
P:1FF3::store here
P:1FFC::mask together with previously saved low nybble
P:1FFE::store both here
P:2000::get offscreen bits offset from stack
P:2002::get value here and store elsewhere
P:2009::add seven bytes to offset
P:200A::to use in routines as offset for fireball
P:200E::set offset for relative coordinates
P:2010::save offset here
P:2012::store object coordinates relative to screen
P:2015::vertically and horizontally, respectively
P:201C::multiply offset by four and save to stack
P:2020::use as offset for Y, X is left alone
P:2021::load value here to be used as offset for X
P:2024::multiply that by four and use as X
P:2027::add the first number in the bounding box data to the
P:2029::relative horizontal coordinate using enemy object offset
P:202A::and store somewhere using same offset * 4
P:202D::store here
P:2033::add the third number in the bounding box data to the
P:2036::relative horizontal coordinate and store
P:2039::increment both offsets
P:203B::add the second number to the relative vertical coordinate
P:203D::using incremented offset and store using the other
P:203E::incremented offset
P:2047::add the fourth number to the relative vertical coordinate
P:204A::and store
P:204D::get original offset loaded into $00 * y from stack
P:204E::use as Y
P:204F::get original offset and use as X again
P:2051::jump to handle any offscreen coordinates
P:2054::do fireball to background collision detection
P:2057::get fireball offscreen bits
P:205A::mask out certain bits
P:205C::if any bits still set, branch to kill fireball
P:205E::do fireball to enemy collision detection and deal with collisions
P:2061::get fireball's sprite data offset
P:2064::get relative vertical coordinate
P:2067::store as sprite Y coordinate
P:206A::get relative horizontal coordinate
P:206D::store as sprite X coordinate, then do shared code
P:2070::get frame counter
P:2072::divide by four
P:2074::save result to stack
P:2075::mask out all but last bit
P:2077::set either tile $64 or $65 as fireball tile
P:2079::thus tile changes every four frames
P:207C::get from stack
P:207D::divide by four again
P:207F::load value $02 to set palette in attrib byte
P:2081::if last bit shifted out was not set, skip this
P:2083::otherwise flip both ways every eight frames
P:2085:FireA:store attribute byte and leave
P:2089:EraseFB:erase fireball state
P:208D:NoFBall
P:208E:RunGameTimer:-------------------------------------------------------------------------------------\nget primary mode of operation
P:2091::branch to leave if in title screen mode
P:2095::if routine number less than eight running,
P:2097::branch to leave
P:2099::if running death routine,
P:209B::branch to leave
P:209F::if player below the screen,
P:20A1::branch to leave regardless of level type
P:20A3::if game timer control not yet expired,
P:20A6::branch to leave
P:20AB::otherwise check game timer digits
P:20B1::if game timer digits at 000, branch to time-up code
P:20B3::otherwise check first digit
P:20B6::branch to reset game timer control
P:20B8::if timer not at 60, branch to reset game timer control
P:20BD::otherwise check second and third digits
P:20C2::branch to reset game timer control
P:20C6::otherwise load time running out music
P:20E4:ResGTCtrl
P:20E7::reset game timer control
P:20F5::set offset for last digit
P:20F7::set value to decrement game timer digit
P:20FC::do sub to decrement game timer slowly
P:2101::write player's score and coin tally to screen
P:2104::set status nybbles to update game timer display
P:2106::do sub to update the display
P:2109:ExGTimer1:ldy VRAM_Buffer1_Offset   \nlda VRAM_Buffer1-3,y      ;check highest digit of score\nbne ExGTimer1                ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-3,y
P:210A:TimeUpOn
P:210F::init player status (note A will always be zero here)
P:2112::do sub to kill the player (note player is small here)
P:2115::set game timer expiration flag
P:2118:ExGTimer:leave
P:2119:timerthings:-------------------------------------------------------------------------------------
P:211B:yeah
P:211D:WarpZoneObject:check for scroll lock flag
P:2120::branch if not set to leave
P:2122::check to see if player's vertical coordinate has
P:2124::same bits set as in vertical high byte (why?)
P:2126::if so, branch to leave
P:212C::apparently this sometimes refuses to work correctly lmao
P:2139::otherwise nullify scroll lock flag
P:213D::increment warp zone flag to make warp pipes for warp zone
P:2140::kill this object
P:2143:FlagpoleScoreMods:-------------------------------------------------------------------------------------
P:2148:FlagpoleScoreDigits
P:214D:FlagpoleRoutine
P:2151::if flagpole slide routine not running,
P:2153::branch to near the end of code
P:2157::if player state not climbing,
P:2159::branch to near the end of code
P:215B::check flagpole flag's vertical coordinate
P:215D::if flagpole flag down to a certain point,
P:215F::branch to end the level
P:2161::check player's vertical coordinate
P:2163::if player down to a certain point,
P:2165::branch to end the level
P:216A::add movement amount to dummy variable
P:216C::save dummy variable
P:216F::get flag's vertical coordinate
P:2171::add 1 plus carry to move flag, and
P:2173::store vertical coordinate
P:2178::subtract movement amount from dummy variable
P:217B::save dummy variable
P:2181::subtract one plus borrow to move floatey number,
P:2183::and store vertical coordinate here
P:2186:SkipScore:jump to skip ahead and draw flag and floatey number
P:2189:GiveFPScr:get score offset from earlier (when player touched flagpole)
P:218C:NoEL4F:get amount to award player points
P:218F::get digit with which to award points
P:2192::store in digit modifier
P:219B::and play the 1-up sound
P:21AA:NoSc4F:do sub to award player points depending on height of collision
P:21AD:NoScore
P:21AF::set to run end-of-level subroutine on next frame
P:21B1:FPGfx:get offscreen information
P:21B4::get relative coordinates
P:21B7::draw flagpole flag and floatey number
P:21BA:ExitFlagP
P:21BB:Setup_Vine1:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\nload identifier for vine object
P:21BD::store in buffer
P:21C1::set flag for enemy object buffer
P:21C6::copy page location from previous object
P:21CB::copy horizontal coordinate from previous object
P:21D0::copy vertical coordinate from previous object
P:21D2::load vine flag/offset to next available vine slot
P:21D5::if set at all, don't bother to store vertical
P:21D7::otherwise store vertical coordinate here
P:21DA:NextVO:store object offset to next available vine slot
P:21DB::using vine flag as offset
P:21DE::increment vine flag offset
P:21E3::load vine grow sound
P:21E6:VineHeightData:-------------------------------------------------------------------------------------\n$06-$07 - used as address to block buffer data\n$02 - used as vertical high nybble of block buffer offset
P:21E8:VineObjectHandler:check enemy offset for special use slot
P:21EB::if not in last slot, branch to leave
P:21F0::decrement vine flag in Y, use as offset
P:21F4::if vine has reached certain height,
P:21F7::branch ahead to skip this part
P:21F9::get frame counter
P:21FB::shift d1 into carry
P:21FD::if d1 not set (2 frames every 4) skip this part
P:2201::subtract vertical position of vine
P:2203::one pixel every frame it's time
P:2205::increment vine height
P:2208:RunVSubs:if vine still very small,
P:220B::branch to leave
P:220F::get relative coordinates of vine,
P:2212::and any offscreen bits
P:2215::initialize offset used in draw vine sub
P:2217:VDrawLoop:draw vine
P:221A::increment offset
P:221B::if offset in Y and offset here
P:221E::do not yet match, loop back to draw more vine
P:2223::mask offscreen bits
P:2225::if none of the saved offscreen bits set, skip ahead
P:2227::otherwise decrement Y to get proper offset again
P:2228:KillVine:get enemy object offset for this vine object
P:222B::kill this vine object
P:222E::decrement Y
P:222F::if any vine objects left, loop back to kill it
P:2231::initialize vine flag/offset
P:2234::initialize vine height
P:2237:WrCMTile:check vine height
P:223A::if vine small (less than 32 pixels tall)
P:223C::then branch ahead to leave
P:2242::set A to obtain horizontal in $04, but we don't care
P:2244::set Y to offset to get block at ($04, $10) of coordinates
P:2246::do a sub to get block buffer address set, return contents
P:224B::if vertical high nybble offset beyond extent of
P:224D::current block buffer, branch to leave, do not write
P:224F::otherwise check contents of block buffer at 
P:2251::current offset, if not empty, branch to leave
P:2255::otherwise, write climbing metatile to block buffer
P:2257:ExitVH:get enemy object offset and leave
P:225A:CannonBitmasks:-------------------------------------------------------------------------------------
P:225C:ProcessCannons:lda AreaType                ;get area type\nbeq ExCannon                ;if water type area, branch to leave\nlda SwimmingFlag\nbne ExCannon
P:225E:ThreeSChk:start at third enemy slot
P:2260::check enemy buffer flag
P:2262::if set, branch to check enemy
P:2264::otherwise get part of LSFR
P:2267::get secondary hard mode flag, use as offset
P:226A::mask out bits of LSFR as decided by flag
P:226D::check to see if lower nybble is above certain value
P:226F::if so, branch to check enemy
P:2271::transfer masked contents of LSFR to Y as pseudorandom offset
P:2275::get page location
P:2278::if not set or on page 0, branch to check enemy
P:227A::get cannon timer
P:227D::if expired, branch to fire cannon
P:227F::otherwise subtract borrow (note carry will always be clear here)
P:2281::to count timer down
P:2284::then jump ahead to check enemy
P:2287:FireCannon:if master timer control set,
P:228A::branch to check enemy
P:228F::otherwise we start creating one
P:2291::first, reset cannon timer
P:2294::get page location of cannon
P:2297::save as page location of bullet bill
P:2299::get horizontal coordinate of cannon
P:229C::save as horizontal coordinate of bullet bill
P:229E::get vertical coordinate of cannon
P:22A2::subtract eight pixels (because enemies are 24 pixels tall)
P:22A4::save as vertical coordinate of bullet bill
P:22A8::set vertical high byte of bullet bill
P:22AA::set buffer flag
P:22AC::shift right once to init A
P:22AD::then initialize enemy's state
P:22B1::set bounding box size control for bullet bill
P:22B6::load identifier for bullet bill (cannon variant)
P:22CB::move onto next slot
P:22CE:Chk_BB:check enemy identifier for bullet bill (cannon variant)
P:22D2::if not found, branch to get next slot
P:22D4::otherwise, check to see if it went offscreen
P:22D7::check enemy buffer flag
P:22D9::if not set, branch to get next slot
P:22DB::otherwise, get offscreen information
P:22DE::then do sub to handle bullet bill
P:22E1:Next3Slt:move onto next slot
P:22E2::do this until first three slots are checked
P:22E4:ExCannon:then leave
P:22E5:ThreeSChk1:--------------------------------
P:22E8:MoveBulletBill:check bullet bill's enemy object state for d5 set
P:22EC::if not set, continue with movement code
P:22EE::otherwise jump to move defeated bullet bill downwards
P:22F1:NotDefB:set bullet bill's horizontal speed
P:22F3::and move it accordingly (note: this bullet bill
P:22F5::object occurs in frenzy object $17, not from cannons)
P:22F8:MoveJumpingEnemy:do a sub to impose gravity on green paratroopa
P:22FB::jump to move enemy horizontally
P:22FE:BulletBillXSpdData
P:2300:BulletBillHandler:if master timer control set,
P:2303::branch to run subroutines except movement sub
P:2307::if bullet bill's state set, branch to check defeated state
P:2309::otherwise load offscreen bits
P:230C::mask out bits
P:230E::check to see if all bits are set
P:2310::if so, branch to kill this object
P:2312::set to move right by default
P:2314::get horizontal difference between player and bullet bill
P:2317::if enemy to the left of player, branch
P:2319::otherwise increment to move left
P:231A:SetupBB:set bullet bill's moving direction
P:231C::decrement to use as offset
P:231D::get horizontal speed based on moving direction
P:2320::and store it
P:2322::get horizontal difference
P:2324::add 40 pixels
P:2326::if less than a certain amount, player is too close
P:2328::to cannon either on left or right side, thus branch
P:232C::otherwise set bullet bill's state
P:2330::set enemy frame timer
P:2335::play fireworks/gunfire sound
P:2337:ChkDSte:check enemy state for d5 set
P:233B::if not set, skip to move horizontally
P:233D::otherwise do sub to move bullet bill vertically
P:2340:BBFly:increment offset for enemy offset
P:2341::position object horizontally according to
P:2344::counters, return with saved value in A,
P:2346:RunBBSubs:get offscreen information
P:2349::get relative coordinates
P:234C::get bounding box coordinates
P:234F::handle player to enemy collisions
P:2352::jsr EnemiesCollision\ndraw the bullet bill and leave
P:2355:KillBB:kill bullet bill and leave
P:2358:HammerEnemyOfsData:-------------------------------------------------------------------------------------
P:2361:HammerXSpdData
P:2363:SpawnHammerObj:          lda PseudoRandomBitReg+1 ;get pseudorandom bits from\n          and #%00000111           ;second part of LSFR\n          bne SetMOfs              ;if any bits are set, branch and use as offset\n          lda PseudoRandomBitReg+1\n          and #%00001000           ;get d3 from same part of LSFR
P:2365::if any values loaded in
P:2368::$2a-$32 where offset is then leave with carry clear
P:236F::ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset\nlda Enemy_Flag,x         ;check enemy buffer flag at offset\nbne NoHammer             ;if buffer flag set, branch to leave with carry clear\nget original enemy object offset
P:2372::save here
P:2377::save hammer's state here
P:237C::set something else entirely, here
P:237F::return with carry set
P:2381:NoHammer:get original enemy object offset
P:2383::return with carry clear
P:2385:ProcHammerObj:--------------------------------\n$00 - used to set downward force\n$01 - used to set upward force (residual)\n$02 - used to set maximum speed\nif master timer control set
P:2388::skip all of this code and go to last subs at the end
P:238A::otherwise get hammer's state
P:238C::mask out d7
P:238E::get enemy object offset that spawned this hammer
P:2391::check hammer's state
P:2393::if currently at 2, branch
P:2395::if greater than 2, branch elsewhere
P:2398::add 13 bytes to use
P:2399::proper misc object
P:239B::return offset to X
P:239E::set downward movement force
P:23A0::lda #$0f\nsta $01                    ;set upward movement force (not used)
P:23A2::set maximum vertical speed
P:23A4::set A to impose gravity on hammer
P:23A6::do sub to impose gravity on hammer and move vertically
P:23A9::do sub to move it horizontally
P:23AC::get original misc object offset
P:23AE::branch to essential subroutines
P:23B1:SetHSpd
P:23B3::set hammer's vertical speed
P:23B5::get enemy object state
P:23B8::mask out d3
P:23BA::store new state
P:23BD::get enemy's moving direction
P:23BF::decrement to use as offset
P:23C0::get proper speed to use based on moving direction
P:23C3::reobtain hammer's buffer offset
P:23C5::set hammer's horizontal speed
P:23C7:SetHPos:decrement hammer's state
P:23C9::get enemy's horizontal position
P:23CD::set position 2 pixels to the right
P:23CF::store as hammer's horizontal position
P:23D1::get enemy's page location
P:23D4::add carry
P:23D6::store as hammer's page location
P:23D8::get enemy's vertical position
P:23DC::move position 10 pixels upward
P:23DE::store as hammer's vertical position
P:23E2::set hammer's vertical high byte
P:23E4::unconditional branch to skip first routine
P:23E6:RunAllH:handle collisions
P:23E9:RunHSubs:set for misc object offsets
P:23ED::add amount of bytes to offset depending on setting in Y
P:23F0::put back in X and leave
P:23F1::set other offset for misc object's offscreen bits
P:23F3::save offscreen bits offset to stack for now
P:23FC::mask together with previously saved low nybble
P:23FE::store both here
P:2400::get offscreen bits offset from stack
P:2402::get value here and store elsewhere
P:2409::set for misc object offsets
P:240D::add amount of bytes to offset depending on setting in Y
P:2413::get the coordinates
P:2416::add nine bytes to offset
P:2417::to use in routines as offset for misc object
P:241B::set offset for relative coordinates
P:241D::get bounding box coordinates
P:2420::jump to handle any offscreen coordinates
P:2423::draw the hammer
P:2426:CoinBlock:-------------------------------------------------------------------------------------\n$02 - used to store vertical high nybble offset from block buffer routine\n$06 - used to store low byte of block buffer address\nset offset for empty or last misc object buffer slot
P:2429::get page location of block object
P:242B::store as page location of misc object
P:242E::get horizontal coordinate of block object
P:2430::add 5 pixels
P:2432::store as horizontal coordinate of misc object
P:2435::get vertical coordinate of block object
P:2437::subtract 16 pixels
P:2439::store as vertical coordinate of misc object
P:243C::jump to rest of code as applies to this misc object
P:243F:SetupJumpCoin:set offset for empty or last misc object buffer slot
P:2442::get page location saved earlier
P:2445::and save as page location for misc object
P:2448::get low byte of block buffer offset
P:244B::multiply by 16 to use lower nybble
P:244E::add five pixels
P:2450::save as horizontal coordinate for misc object
P:2453::get vertical high nybble offset from earlier
P:2455::add 32 pixels for the status bar
P:2457::store as vertical coordinate
P:245A:JCoinC
P:245C::set vertical speed
P:245F::increment coin tally used to activate 1-up block flag
P:2464::set vertical high byte
P:2467::set state for misc object
P:246A::load coin grab sound
P:246C::store current control bit as misc object offset 
P:246E::update coin tally on the screen and coin amount variable
P:2471:FindEmptyMiscSlot:start at end of misc objects buffer
P:2473:FMiscLoop:get misc object state
P:2476::branch if none found to use current offset
P:2478::decrement offset
P:2479::do this for three slots
P:247B::do this until all slots are checked
P:247D::if no empty slots found, use last slot
P:247F:UseMiscS:store offset of misc object buffer here (residual)
P:2483:MiscObjectsCore:-------------------------------------------------------------------------------------\nset at end of misc object buffer
P:2485:MiscLoop:store misc object offset here
P:2487::check misc object state
P:2489::branch to check next slot
P:248B::if d7 not set, jumping coin, thus skip to rest of code here
P:2493::otherwise go to process hammer,
P:2496::decrement misc object offset
P:2497::store misc object offset here
P:2499::check misc object state
P:249B::branch to check next slot
P:249D::if d7 not set, jumping coin, thus skip to rest of code here
P:24A5::otherwise go to process hammer,
P:24A8::decrement misc object offset
P:24A9::store misc object offset here
P:24AB::check misc object state
P:24AD::branch to check next slot
P:24AF::if d7 not set, jumping coin, thus skip to rest of code here
P:24B7::otherwise go to process hammer,
P:24BA::decrement misc object offset
P:24BB::store misc object offset here
P:24BD::check misc object state
P:24BF::branch to check next slot
P:24C1::if d7 not set, jumping coin, thus skip to rest of code here
P:24C9::otherwise go to process hammer,
P:24CC::decrement misc object offset
P:24CD::store misc object offset here
P:24CF::check misc object state
P:24D1::branch to check next slot
P:24D3::if d7 not set, jumping coin, thus skip to rest of code here
P:24DB::otherwise go to process hammer,
P:24DE::decrement misc object offset
P:24DF::store misc object offset here
P:24E1::check misc object state
P:24E3::branch to check next slot
P:24E5::if d7 not set, jumping coin, thus skip to rest of code here
P:24ED::otherwise go to process hammer,
P:24F0::decrement misc object offset
P:24F1::store misc object offset here
P:24F3::check misc object state
P:24F5::branch to check next slot
P:24F7::if d7 not set, jumping coin, thus skip to rest of code here
P:24FF::otherwise go to process hammer,
P:2502::decrement misc object offset
P:2503::store misc object offset here
P:2505::check misc object state
P:2507::branch to check next slot
P:2509::if d7 not set, jumping coin, thus skip to rest of code here
P:2511::otherwise go to process hammer,
P:2514::decrement misc object offset
P:2515::store misc object offset here
P:2517::check misc object state
P:2519::branch to check next slot
P:251B::if d7 not set, jumping coin, thus skip to rest of code here
P:2520::otherwise go to process hammer,
P:2524:ProcJumpCoin:--------------------------------\n$00 - used to set downward force\n$01 - used to set upward force (residual)\n$02 - used to set maximum speed\ncheck misc object state
P:2526::decrement to see if it's set to 1
P:2527::if so, branch to handle jumping coin
P:2529::otherwise increment state to either start off or as timer
P:252B::get horizontal coordinate for misc object
P:252D::whether its jumping coin (state 0 only) or floatey number
P:252E::add current scroll speed
P:2531::store as new horizontal coordinate
P:2533::get page location
P:2535::add carry
P:2537::store as new page location
P:253B::check state of object for preset value
P:253D::if not yet reached, branch to subroutines
P:2541::otherwise nullify object state
P:2544:JCoinRun
P:2545::add 13 bytes to offset for next subroutine
P:2549::set downward movement amount
P:254D::set maximum vertical speed
P:2551::divide by 2 and set
P:2552::as upward movement amount (apparently residual)
P:2554::set A to impose gravity on jumping coin
P:2556::do sub to move coin vertically and impose gravity on it
P:2559::get original misc object offset
P:255B::check vertical speed
P:255F::if not moving downward fast enough, keep state as-is
P:2561::otherwise increment state to change to floatey number
P:2563:RunJCSubs:set for misc object offsets
P:2565::move offset to A
P:2567::add amount of bytes to offset depending on setting in Y
P:256A::put back in X and leave
P:256D::load vertical coordinate low
P:256F::store here
P:2572::load horizontal coordinate
P:2574::subtract left edge coordinate
P:2578::store result here
P:257B::return original offset
P:257D::set for misc object offsets
P:257F::move offset to A
P:2581::add amount of bytes to offset depending on setting in Y
P:2584::put back in X and leave
P:2585::set other offset for misc object's offscreen bits
P:2587::and get offscreen information about misc object
P:258A::jsr GetMiscBoundBox       ;get bounding box coordinates (why?)\ndraw the coin or floatey number
P:258D:JCoinGfxHandler:get coin/floatey number's OAM data offset
P:2590::get state of misc object
P:2592::if 2 or greater, 
P:2594::branch to draw floatey number
P:2598::store vertical coordinate as
P:259A::Y coordinate for first sprite
P:259E::add eight pixels
P:25A0::store as Y coordinate for second sprite
P:25A3::get relative horizontal coordinate
P:25A9::store as X coordinate for first and second sprites
P:25AC::get frame counter
P:25AE::divide by 2 to alter every other frame
P:25AF::mask out d2-d1
P:25B1::use as graphical offset
P:25B2::load tile number
P:25B5::increment OAM data offset to write tile numbers
P:25B6::and into first row sprites
P:25B9::and do sub to dump into first and second sprites
P:25BC::decrement to get old offset
P:25BF::set attribute byte in first sprite
P:25C4::set attribute byte with vertical flip in second sprite
P:25CA::check offscreen bits
P:25CC::if all bits clear, leave object alone
P:25D0::and into first row sprites
P:25D6:ExJCGfx:get misc object offset
P:25D9:DrawFloateyNumber_Coin
P:25E0::set number of points control for floatey numbers
P:25E5::set timer for floatey numbers
P:25EB::check offscreen bits
P:25ED::if all bits clear, leave object alone
P:25F8::set vertical coordinate
P:2601::set horizontal coordinate and leave
P:260E:CoinTallyOffsets:		  lda FrameCounter          ;get frame counter\n          lsr                       ;divide by 2\n          bcs NotRsNum              ;branch if d0 not set to raise number every other frame\n          dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate\nNotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate\n          sta Sprite_Data+4,y            ;and into first row sprites\n	      sta Sprite_Data,y              ;and do sub to dump into first and second sprites\n          lda Misc_Rel_XPos         ;get relative horizontal coordinates\n		  sta Sprite_X_Position,y\n          clc\n          adc #$08                  ;add eight pixels\n          sta Sprite_X_Position+4,y ;store as X coordinate for second sprite\n          lda #$02\n          sta Sprite_Attributes,y   ;store attribute byte in both sprites\n          sta Sprite_Attributes+4,y\n          lda #$f6\n          sta Sprite_Tilenumber,y   ;put tile numbers into both sprites\n          lda #$fb                  ;that resemble "200"\n          sta Sprite_Tilenumber+4,y\n          rts        \n-------------------------------------------------------------------------------------
P:2611:ScoreOffsets
P:2614:StatusBarNybbles
P:2618:GiveOneCoin:set digit modifier to add 1 coin
P:261A::to the current player's coin tally
P:261F::update the coin tally
P:2622::increment onscreen player's coin amount
P:2628::does player have 100 coins yet?
P:262A::if not, skip all of this
P:262E::otherwise, reinitialize coin amount
P:2633::and play the 1-up sound
P:263C::give the player an extra life
P:2643::set number of points control for floatey numbers
P:264B::set timer for floatey numbers
P:2650::set vertical coordinate
P:2656::set horizontal coordinate and leave
P:2661:CoinPoints:set digit modifier to award
P:2663::200 points to the player
P:2668:AddToScore
P:266A::update the score internally with value in digit modifier
P:266D:WriteScoreAndCoinTally
P:266F:UpdateNumber:inc bocata3\nldx ObjectOffset\nrts\nprint status bar numbers based on nybbles, whatever they be
P:2675:RealUpdateNumber:jmp NoZSup
P:267B:NoZSup:lda VRAM_Buffer1-6,y      ;check highest digit of score\nbne NoZSup                ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-6,y\nget enemy object buffer offset
P:267E:SetupPowerUp:-------------------------------------------------------------------------------------
P:268A::load power-up identifier into
P:268C::special use slot of enemy object buffer
P:268E::store page location of block object
P:2691::as page location of power-up object
P:2693::store horizontal coordinate of block object
P:2696::as horizontal coordinate of power-up object
P:269A::set vertical high byte of power-up object
P:269C::get vertical coordinate of block object
P:26A0::subtract 8 pixels
P:26A2::and use as vertical coordinate of power-up object
P:26A4:PwrUpJmp:this is a residual jump point in enemy object jump table
P:26A6::set power-up object's state
P:26A8::set buffer flag
P:26AC::set bounding box size control for power-up object
P:26B1::check currently loaded power-up type
P:26B3::if star or 1-up, branch ahead
P:26B5::otherwise check player's current status
P:26BA::if player not fiery, use status as power-up type
P:26BC::otherwise shift right to force fire flower type
P:26BD:StrType:store type here
P:26C0:PutBehind
P:26C2::set background priority bit
P:26C7::load power-up reveal sound and leave
P:26C9:ExitPUp
P:26CA:idk
P:26D3:PowerUpObjHandler:-------------------------------------------------------------------------------------\ncheck power-up object's state
P:26D5::if not set, branch to leave
P:26D7::if not set, branch ahead to skip this part
P:26D9::if master timer control set,
P:26DC::branch ahead to enemy object routines
P:26DE::check power-up type
P:26E1::if normal mushroom, branch ahead to move it
P:26E5::if 1-up mushroom, branch ahead to move it
P:26E9::if not star, branch elsewhere to skip movement
P:26EB::otherwise impose gravity on star power-up and make it jump
P:26F0::note that green paratroopa shares the same code here 
P:26F5::then jump to other power-up subroutines
P:26F8:ShroomM:do sub to make mushrooms move
P:26FD::deal with collisions
P:2700::bug fix: pswitch modifies the x register
P:2702::run the other subroutines
P:2705:GrowThePowerUp:get frame counter
P:2707::mask out all but 2 LSB
P:2709::if any bits set here, branch
P:270B::otherwise decrement vertical coordinate slowly
P:270D::load power-up object state
P:270F::increment state for next frame (to make power-up rise)
P:2711::if power-up object state not yet past 16th pixel,
P:2713::branch ahead to last part here
P:2720::make the paratroopa jump again
P:2724::otherwise set horizontal speed
P:2728::and then set d7 in power-up object's state
P:272A::shift once to init A
P:272B::initialize background priority bit set here
P:272E::rotate A to set right moving direction
P:272F::set moving direction
P:2731:ChkPUSte:check power-up object's state
P:2733::for if power-up has risen enough
P:2735::if not, don't even bother running these routines
P:2737:RunPUSubs:get coordinates relative to screen
P:273A::get offscreen bits
P:273D::get bounding box coordinates
P:2740::draw the power-up object
P:2743::check for collision with player
P:2746::check to see if it went offscreen
P:2749:ExitPUp2
P:274A:BlockYPosAdderData:-------------------------------------------------------------------------------------\nThese apply to all routines in this section unless otherwise noted:\n$00 - used to store metatile from block buffer routine\n$02 - used to store vertical high nybble offset from block buffer routine\n$05 - used to store metatile stored in A at beginning of PlayerHeadCollision\n$06-$07 - used as block buffer address indirect
P:274C:PlayerHeadCollision:store metatile number to stack
P:2758::load unbreakable block object state by default
P:275A::load offset control bit here
P:275D::check player's size
P:2760::if small, branch
P:2762::otherwise load breakable block object state
P:2764:DBlockSte:store into block object buffer
P:2766::store blank metatile in vram buffer to write to name table
P:2769::load offset control bit
P:276C::get vertical high nybble offset used in block buffer routine
P:276E::set as vertical coordinate for block object
P:2772::get low byte of block buffer address used in same routine
P:2774::save as offset here to be used later
P:277F::get contents of block buffer at old address at $06, $07
P:2790::do a sub to check which block player bumped head on
P:2793::store metatile here
P:279A::check player's size
P:279D::if small, use metatile itself as contents of A
P:27A2::otherwise init A (note: big = 0)
P:27A5:ChkBrick
P:27A6::if no match was found in previous sub, skip ahead
P:27A8::otherwise load unbreakable state into block object buffer
P:27AA::note this applies to both player sizes
P:27AC::load empty block metatile into A for now
P:27AE::get metatile from before
P:27B0::is it brick with coins (with line)?
P:27B2::if so, branch
P:27BC::is it brick with coins (without line)?
P:27BE::if not, branch ahead to store empty block metatile
P:27C0:StartBTmr:check brick coin timer flag
P:27C3::if set, timer expired or counting down, thus branch
P:27C7::if not set, set brick coin timer
P:27CA::and set flag linked to it
P:27CD:ContBTmr
P:27D0::check brick coin timer
P:27D3::if not yet expired, branch to use current metatile
P:27D8::otherwise use empty block metatile
P:27DA:PutOldMT:put metatile into A
P:27DB:PutMTileB:store whatever metatile be appropriate here
P:27DE::get block object horizontal coordinates saved
P:27E1::get vertical high nybble offset
P:27EF::write blank metatile $23 to block buffer
P:27F3::set block bounce timer
P:27F6::pull original metatile from stack
P:27F7::and save here
P:27F9::set default offset
P:27FB::is player crouching?
P:27FE::if so, branch to increment offset
P:2800::is player big?
P:2803::if so, branch to use default offset
P:2805:SmallBP:increment for small or big and crouching
P:2809:BigBP
P:2811::get player's vertical coordinate
P:2815::save as vertical coordinate for block object
P:281A:BumpChkRt:get player's vertical coordinate
P:281D::add value determined by size
P:2820::mask out low nybble to get 16-pixel correspondence
P:2822::save as vertical coordinate for block object
P:2824:JumpBack:get block object state
P:2828::if set to value loaded for unbreakable, branch
P:282A::execute code for breakable brick
P:282F::set vertical speed for player
P:2834:Unbreak:execute code for unbreakable brick or question block
P:2837:InvOBit
P:283F::leave!
P:2840:UnderWaterBumpChk:get player's vertical coordinate
P:2844::save as vertical coordinate for block object
P:2849:BumpBlock:--------------------------------
P:2851::check to see if there's a coin directly above this block
P:2856::play bump sound
P:285A::initialize horizontal speed for block object
P:285C::init fractional movement force
P:285F::init player's vertical speed
P:2863::set vertical speed for block object
P:2865::get original metatile from stack
P:2866::do a sub to check which block player bumped head on
P:2869::if no match was found, branch to leave
P:286B::move block number to A
P:286C::if block number was within 0-8 range,
P:286E::branch to use current number
P:2870::otherwise subtract 5 for second set to get proper number
P:2872:BlockCode:run appropriate subroutine depending on block number
P:28A1:MushFlowerBlock:.dw HammerMushBlock\n.dw HammerMushBlock\n.dw HammerMushBlock\n.dw MushFlowerBlock\n--------------------------------\nload mushroom/fire flower into power-up type
P:28A3::BIT instruction opcode
P:28A4:StarBlock:load star into power-up type
P:28A6::BIT instruction opcoded
P:28A7:ExtraLifeMushBlock:load 1-up mushroom into power-up type
P:28A9::store correct power-up type
P:28B0:VineBlock
P:28B8::get control bit
P:28BB::set up vine object
P:28BE:ExitBlockChk:leave
P:28BF:BrickQBlockMetatiles:--------------------------------\nused by question blocks
P:28CC::these two sets are functionally identical, but look different\n, $70, $6f, $c4, $72 ;used by ground level types
P:28D5::, $71, $6f, $c4, $72 ;used by other level types
P:28DE:BlockBumpedChk:BrickQBlockMetatiles:\n.db $c1, $c2, $c0, $5e, $5f, $60, $61 ;used by question blocks\n.db $52, $53, $54, $55, $56, $57 ;used by ground level bricks\n.db $58, $59, $5a, $5b, $5c, $5d ;used by other level bricks\nstart at end of metatile data
P:28E0:BumpChkLoop:check to see if current metatile matches
P:28E3::metatile found in block buffer, branch if so
P:28E5::otherwise move onto next metatile
P:28E6::do this until all metatiles are checked
P:28E8::if none match, return with carry clear
P:28E9:MatchBump:note carry is set if found match
P:28EA:BrickShatter:--------------------------------\ncheck to see if there's a coin directly above this block
P:28EF::set flag for block object to immediately replace metatile
P:28F5::load brick shatter sound
P:28F7::set horizontal coordinate of block object
P:28F9::as original horizontal coordinate here
P:28FE::set horizontal speed for brick chunk objects
P:2904::set vertical speed for one
P:2908::set lower vertical speed for the other
P:290C::init fractional movement force for both
P:2914::copy page location
P:2918::copy horizontal coordinate
P:291C::add 8 pixels to vertical coordinate
P:291D::and save as vertical coordinate for one of them
P:2923::set digit modifier to give player 50 points
P:2926::do sub to update the score
P:2929::load control bit and leave
P:292D:CheckTopOfBlock:--------------------------------\nload control bit
P:2930::get vertical high nybble offset used in block buffer
P:2932::branch to leave if set to zero, because we're at the top
P:2934::otherwise set to A
P:2936::subtract $10 to move up one row in the block buffer
P:2938::store as new vertical high nybble offset
P:293B::get contents of block buffer in same column, one row up
P:2942::is it a coin? (not underwater)
P:2944::if not, branch to leave
P:294C::otherwise put blank metatile where coin was
P:2951::write blank metatile to vram buffer
P:2954::get control bit
P:2957::create jumping coin object and update coin variable
P:295A:TopEx:--------------------------------
P:295E:UpdSte2:store contents of A in block object state
P:2961:BouncingBlockHandler1:-------------------------------------------------------------------------------------
P:2964:BlockObjectsCore:get state of block object
P:2966::if not set, branch to leave
P:2968::mask out high nybble
P:296A::push to stack
P:296B::put in Y for now
P:296E::add 9 bytes to offset (note two block objects are created
P:2970::when using brick chunks, but only one offset for both)
P:2971::decrement Y to check for solid block state
P:2972::branch if found, otherwise continue for brick chunks
P:2974::set offset for maximum speed
P:2976::set movement amount here
P:297A::get maximum speed
P:297D::set maximum speed here
P:297F::set value to move downwards
P:2981::jump to the code that actually moves it
P:2984::do another sub to move horizontally
P:2988::move onto next block object
P:298C::set offset for maximum speed
P:298E::set movement amount here
P:2992::get maximum speed
P:2995::set maximum speed here
P:2997::set value to move downwards
P:2999::jump to the code that actually moves it
P:299C::do another sub to move horizontally
P:299F::get block object offset used for both
P:29A4:sacrificaopapu2
P:29A5:sacrificaopapu:get coordinates of one block object
P:29A7::relative to the screen
P:29A9::store value to add to A here
P:29AC::add A to value stored
P:29AE::use as enemy offset
P:29AF::load vertical coordinate low
P:29B1::store here
P:29B4::load horizontal coordinate
P:29B6::subtract left edge coordinate
P:29BA::store result here
P:29BD::reload old object offset and leave
P:29BF::adjust offset for other block object if any
P:29C3::adjust other and get coordinates for other one
P:29C4::store value to add to A here
P:29C7::add A to value stored
P:29C9::use as enemy offset
P:29CA::load vertical coordinate low
P:29CC::store here
P:29CF::load horizontal coordinate
P:29D1::subtract left edge coordinate
P:29D5::store result here
P:29D8::reload old object offset and leave
P:29E0::add contents of X to A to get
P:29E1::appropriate offset, then give back to X
P:29E4::save offscreen bits offset to stack for now
P:29E6::do subroutine here
P:29ED::store here
P:29F6::mask together with previously saved low nybble
P:29F8::store both here
P:29FA::get offscreen bits offset from stack
P:29FC::get value here and store elsewhere
P:2A03::set palette bits here
P:2A07::set tile number for ball (something residual, likely)
P:2A0B::if end-of-level routine running,
P:2A0D::use palette and tile number assigned
P:2A0F::otherwise set different palette bits
P:2A13::and set tile number for brick chunks
P:2A15:DChunks:get OAM data offset
P:2A18::increment to start with tile bytes in OAM
P:2A19::into second row sprites
P:2A1F::and into first row sprites
P:2A22::and dump into tile number part of sprite data
P:2A25::get frame counter
P:2A2B::get what was originally d3-d2 of low nybble
P:2A2D::add palette bits
P:2A2F::increment offset for attribute bytes
P:2A30::into second row sprites
P:2A36::and into first row sprites
P:2A39::and dump into tile number part of sprite data
P:2A3D::decrement offset to Y coordinate
P:2A3E::get first block object's relative vertical coordinate
P:2A41::and into first row sprites
P:2A44::and dump into tile number part of sprite data
P:2A47::get first block object's relative horizontal coordinate
P:2A4A::save into X coordinate of first sprite
P:2A4D::get original horizontal coordinate
P:2A51::subtract coordinate of left side from original coordinate
P:2A54::store result as relative horizontal coordinate of original
P:2A57::get difference of relative positions of original - current
P:2A5A::add original relative position to result
P:2A5C::plus 6 pixels to position second brick chunk correctly
P:2A5E::save into X coordinate of second sprite
P:2A61::get second block object's relative vertical coordinate
P:2A67::dump into Y coordinates of third and fourth sprites
P:2A6A::get second block object's relative horizontal coordinate
P:2A6D::save into X coordinate of third sprite
P:2A70::use original relative horizontal position
P:2A73::get difference of relative positions of original - current
P:2A76::add original relative position to result
P:2A78::plus 6 pixels to position fourth brick chunk correctly
P:2A7A::save into X coordinate of fourth sprite
P:2A7D::get offscreen bits for block object
P:2A80::check to see if d3 in offscreen bits are set
P:2A82::if not set, branch, otherwise move sprites offscreen
P:2A84::move offscreen two OAMs
P:2A86::on the left side (or two rows of enemy on either side
P:2A89::if branched here from enemy graphics handler)
P:2A8C::get offscreen bits again
P:2A8F::shift d7 into carry
P:2A90::if d7 not set, branch to last part
P:2A94::and into first row sprites
P:2A97::and do sub to dump into first and second sprites
P:2A9A:ChnkOfs:if relative position on left side of screen,
P:2A9C::go ahead and leave
P:2A9E::otherwise compare left-side X coordinate
P:2AA1::to right-side X coordinate
P:2AA4::branch to leave if less
P:2AA6::otherwise move right half of sprites offscreen
P:2AAE:ExBCDr:get lower nybble of saved state
P:2AAF::check vertical high byte of block object
P:2AB3::store contents of A in block object state
P:2AB6::otherwise save state back into stack
P:2AB9::check to see if bottom block object went
P:2ABB::to the bottom of the screen, and branch if not
P:2ABD::otherwise set offscreen coordinate
P:2ABF:ChkTop:get top block object's vertical coordinate
P:2AC1::see if it went to the bottom of the screen
P:2AC3::pull block object state from stack
P:2AC6::store contents of A in block object state
P:2ACC:BouncingBlockHandler:set offset for maximum speed
P:2ACE::set movement amount here
P:2AD2::get maximum speed
P:2AD5::set maximum speed here
P:2AD7::set value to move downwards
P:2AD9::jump to the code that actually moves it
P:2ADC::get block object offset
P:2ADE::get coordinates of one block object
P:2AE0::relative to the screen
P:2AE2::store value to add to A here
P:2AE5::add A to value stored
P:2AE7::use as enemy offset
P:2AE8::load vertical coordinate low
P:2AEA::store here
P:2AED::load horizontal coordinate
P:2AEF::subtract left edge coordinate
P:2AF3::store result here
P:2AF6::reload old object offset and leave
P:2AF8::adjust offset for other block object if any
P:2AFC::adjust other and get coordinates for other one
P:2AFD::store value to add to A here
P:2B00::add A to value stored
P:2B02::use as enemy offset
P:2B03::load vertical coordinate low
P:2B05::store here
P:2B08::load horizontal coordinate
P:2B0A::subtract left edge coordinate
P:2B0E::store result here
P:2B11::reload old object offset and leave
P:2B19::add contents of X to A to get
P:2B1A::appropriate offset, then give back to X
P:2B1D::save offscreen bits offset to stack for now
P:2B1F::do subroutine here
P:2B26::store here
P:2B2F::mask together with previously saved low nybble
P:2B31::store both here
P:2B33::get offscreen bits offset from stack
P:2B35::get value here and store elsewhere
P:2B3C::draw the block
P:2B3F::get vertical coordinate
P:2B41::mask out high nybble
P:2B43::check to see if low nybble wrapped around
P:2B45::pull state from stack
P:2B46::if still above amount, not time to kill block yet, thus branch
P:2B4A::otherwise set flag to replace metatile
P:2B4D:KillBlock:if branched here, nullify object state
P:2B4F:UpdSte:store contents of A in block object state
P:2B52:BlockObjMT_Updater:-------------------------------------------------------------------------------------\n$02 - used to store offset to block buffer\n$06-$07 - used to store block buffer address\nset offset to start with second block object
P:2B54:UpdateLoop:set offset here
P:2B56::if vram buffer already being used here,
P:2B5B::branch to move onto next block object
P:2B5D::if flag for block object already clear,
P:2B60::branch to move onto next block object
P:2B62::get low byte of block buffer
P:2B65::store into block buffer address
P:2B6A::set high byte of block buffer address
P:2B6C::get original vertical coordinate of block object
P:2B6F::store here and use as offset to block buffer
P:2B72::get metatile to be written
P:2B75::write it to the block buffer
P:2B77::do sub to replace metatile where block object is
P:2B7A::ldy temp8
P:2B82::clear block object flag
P:2B85:NextBUpd:decrement block object offset
P:2B86::set offset here
P:2B88::if vram buffer already being used here,
P:2B8F::if flag for block object already clear,
P:2B92::branch to move onto next block object
P:2B94::get low byte of block buffer
P:2B97::store into block buffer address
P:2B9C::set high byte of block buffer address
P:2B9E::get original vertical coordinate of block object
P:2BA1::store here and use as offset to block buffer
P:2BA4::get metatile to be written
P:2BA7::write it to the block buffer
P:2BA9::do sub to replace metatile where block object is
P:2BAC::ldy temp8
P:2BB4::clear block object flag
P:2BB7::then leave
P:2BB8:MovePlatformDown:-------------------------------------------------------------------------------------\n$00 - used to store high nybble of horizontal speed as adder\n$01 - used to store low nybble of horizontal speed\n$02 - used to store adder to page location\nsave value to stack (if branching here, execute next
P:2BBA::part as BIT instruction)
P:2BBB:MovePlatformUp:save value to stack
P:2BBE::get enemy object identifier
P:2BC0::increment offset for enemy object
P:2BC1::load default value here
P:2BC3::this code, thus unconditional branch here
P:2BC5:SetDplSpd:save downward movement amount here
P:2BC7::save upward movement amount here
P:2BCB::save maximum vertical speed here
P:2BCF::get value from stack
P:2BD0::use as Y, then move onto code shared by red koopa
P:2BD1:RedPTroopaGrav:do a sub to move object gradually
P:2BD4::get enemy object offset and leave
P:2BD7:MoveDropPlatform:set movement amount for drop platform
P:2BD9::skip ahead of other value set here
P:2BDB:MoveEnemySlowVert:set movement amount for bowser/other objects
P:2BDD:SetMdMax:set maximum speed in A
P:2BDF::unconditional branch
P:2BE1:MoveJ_EnemyVertically:--------------------------------\nset movement amount for podoboo/other objects
P:2BE3:SetHiMax:set maximum speed in A
P:2BE5:SetXMoveAmt:set movement amount here
P:2BE7::increment X for enemy offset
P:2BE8::set maximum speed here
P:2BEA::set value to move downwards
P:2BEC::jump to the code that actually moves it
P:2BEF::get enemy object buffer offset and leave
P:2BF1:HE
P:2BF2:MoveRedPTroopaDown:--------------------------------\n--------------------------------\nset Y to move downwards
P:2BF4::skip to movement routine
P:2BF6:MoveRedPTroopaUp:set Y to move upwards
P:2BF8:MoveRedPTroopa:increment X for enemy offset
P:2BFB::set downward movement amount here
P:2BFF::set upward movement amount here
P:2C03::set maximum speed here
P:2C05::set movement direction in A, and
P:2C06::jump to move this thing
P:2C08:MoveD_EnemyVertically:--------------------------------\n-------------------------------------------------------------------------------------\n$00 - used to store high nybble of horizontal speed as adder\n$01 - used to store low nybble of horizontal speed\n$02 - used to store adder to page location\n--------------------------------\nset quick movement amount downwards
P:2C0A::then check enemy state
P:2C0C::if not set to unique state for spiny's egg, go ahead
P:2C0E::and use, otherwise set different movement amount, continue on
P:2C10:MoveFallingPlatform:set movement amount
P:2C12:ContVMove:jump to skip the rest of this
P:2C15:MoveObjectHorizontally1:get currently saved value (horizontal
P:2C1B::store result here
P:2C1D::get saved value again
P:2C23::if < 8, branch, do not change
P:2C27::otherwise alter high nybble
P:2C29:SaveXSp1:save result here
P:2C2B::load default Y value here
P:2C2D::if result positive, leave Y alone
P:2C31::otherwise decrement Y
P:2C32:UseAdde1:save Y here
P:2C34::get whatever number's here
P:2C38::add low nybble moved to high
P:2C3A::store result here
P:2C3D::init A
P:2C3F::rotate carry into d0
P:2C40::push onto stack
P:2C41::rotate d0 back onto carry
P:2C44::add carry plus saved value (high nybble moved to low
P:2C46::ldy FramesMissed\n beq +\n adc $00\nplus $f0 if necessary) to object's horizontal position
P:2C4A::add carry plus other saved value to the
P:2C4C::object's page location and save
P:2C4F::pull old carry from stack and add
P:2C50::to high nybble moved to low
P:2C52:ExXMove1
P:2C54::and leave
P:2C55:MovePlayerHorizontally:if jumpspring currently animating,
P:2C58::branch to leave
P:2C5A::otherwise set zero for offset to use player's stuff
P:2C5B:MoveObjectHorizontally:get currently saved value (horizontal
P:2C61::store result here
P:2C63::get saved value again
P:2C69::if < 8, branch, do not change
P:2C6D::otherwise alter high nybble
P:2C6F:SaveXSpd:save result here
P:2C71::ldy FramesMissed\nbeq +\nclc\nadc $00\nsta $00\nload default Y value here
P:2C73::if result positive, leave Y alone
P:2C77::otherwise decrement Y
P:2C78:UseAdder:save Y here
P:2C7A::get whatever number's here
P:2C7E::add low nybble moved to high
P:2C80::store result here
P:2C83::init A
P:2C85::rotate carry into d0
P:2C86::push onto stack
P:2C87::rotate d0 back onto carry
P:2C8A::add carry plus saved value (high nybble moved to low
P:2C8C::plus $f0 if necessary) to object's horizontal position
P:2C90::add carry plus other saved value to the
P:2C92::object's page location and save
P:2C96::ldy FramesMissed\nbeq +\nto high nybble moved to low
P:2C98:ExXMove:and leave
P:2C99:BounceJS:-------------------------------------------------------------------------------------\n$00 - used for downward force\n$01 - used for upward force\n$02 - used for maximum vertical speed\n    .db $08, $10, $08, $00\n      jsr GetEnemyOffscreenBits   ;get offscreen information\n     lda TimerControl            ;check master timer control\n   bne DrawJSpr                ;branch to last section if set\n  lda JumpspringAnimCtrl      ;check jumpspring frame control\n; ;   beq DrawJSpr                ;branch to last section if not set\n tay\n   dey                         ;subtract one from frame control,\ntya                         ;the only way a poor nmos 6502 can\n and #%00000010              ;mask out all but d1, original value still in Y\nbne DownJSpr                ;if set, branch to move player up\ninc Player_Y_Position\n  inc Player_Y_Position       ;move player's vertical position down two pixels\n  jmp PosJSpr                 ;skip to next part\n  dec Player_Y_Position       ;move player's vertical position up two pixels\n  dec Player_Y_Position\n  lda Jumpspring_FixedYPos,x  ;get permanent vertical position\n  clc\n  adc Jumpspring_Y_PosData,y  ;add value using frame control as offset\n  sta Enemy_Y_Position,x      ;store as new vertical position\n  cpy #$01                    ;check frame control offset (second frame is $00)\n  bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part\n  lda A_B_Buttons\n  and #A_Button               ;check saved controller bits for A button press\n  beq BounceJS                ;skip to next part if A not pressed\n  and PreviousA_B_Buttons     ;check for A button pressed in previous frame\n  bne BounceJS                ;skip to next part if so\n  lda #$f4\n  sta JumpspringForce         ;otherwise write new jumpspring force here\n  cpy #$03                    ;check frame control offset again\n  bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)\n  lda JumpspringForce\n  sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed\n  if JUMPSPRING_FIX == 1\n      lda #$40                ;PAL bugfix: Define vertical acceleration on springs (was undefined on NTSC)\n      sta VerticalForce\n  endif\n  lda #$00\n  sta JumpspringAnimCtrl      ;initialize jumpspring frame control\n  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates\n  jsr EnemyGfxHandler         ;draw jumpspring\n  jsr OffscreenBoundsCheck    ;check to see if we need to kill it\n  lda JumpspringAnimCtrl      ;if frame control at zero, don't bother\n  beq ExJSpring               ;trying to animate it, just leave\n  lda JumpspringTimer\n  bne ExJSpring               ;if jumpspring timer not expired yet, leave\n  lda #$04\n  sta JumpspringTimer         ;otherwise initialize jumpspring timer\n  inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring\nExJSpring: rts                         ;leave\npush value to stack
P:2C99:DownJSpr
P:2C99:DrawJSpr
P:2C99:ImposeGravity
P:2C99:JumpspringHandler
P:2C99:Jumpspring_Y_PosData
P:2C99:PosJSpr
P:2C9D::add value in movement force to contents of dummy variable
P:2CA4::set Y to zero by default
P:2CA6::get current vertical speed
P:2CA8::if currently moving downwards, do not decrement Y
P:2CAA::otherwise decrement Y
P:2CAB:AlterYP:store Y here
P:2CAD::add vertical position to vertical speed plus carry
P:2CAF::ldy FramesMissed\n  beq +\n  adc SprObject_Y_Speed,x\nstore as new vertical position
P:2CB3::add carry plus contents of $07 to vertical high byte
P:2CB5::store as new vertical high byte
P:2CBB::add downward movement amount to contents of $0433
P:2CC0::add carry to vertical speed and store
P:2CC6::compare to maximum speed
P:2CC8::if less than preset value, skip this part
P:2CD1::keep vertical speed within maximum value
P:2CD5::clear fractional
P:2CD8:ChkUpM:get value from stack
P:2CD9::if set to zero, branch to leave
P:2CDD::otherwise get two's compliment of maximum speed
P:2CE1::store two's compliment here
P:2CE6::subtract upward movement amount from contents
P:2CE7::of movement force, note that $01 is twice as large as $00,
P:2CE9::thus it effectively undoes add we did earlier
P:2CEE::subtract borrow from vertical speed and store
P:2CF2::compare vertical speed to two's compliment
P:2CF4::if less negatively than preset maximum, skip this part
P:2CF9::and if so, branch to leave
P:2CFD::keep vertical speed within maximum value
P:2D01::clear fractional
P:2D04:ExVMove:leave!
P:2D05:MaxSpdBlockData
P:2D07:ImposeGravityBlock:set offset for maximum speed
P:2D09::set movement amount here
P:2D0D::get maximum speed
P:2D10:ImposeGravitySprObj:set maximum speed here
P:2D12::set value to move downwards
P:2D14::jump to the code that actually moves it
P:2D17:UpdateLives:--------------------------------\n DPCM data must be at $C000 or later, aligned to 64 byte boundry\ninclude code\sound\shmup_dpcm.asm\nincbin code\sound\vyu.dmc
P:2D1C::otherwise, check number of lives
P:2D1F::iny\ntya\nmore than 9 lives?
P:2D23::if so, subtract 10 and add one to the 10s digit
P:2D25::instead of showing 100 lives, A0 will show, etc.
P:2D2E::if so, subtract 10 and add to the digit
P:2D30::next to the difference
P:2D36:PutLives2
P:2D3E:RunOffscrBitsSubs:do subroutine here
P:2D45::store here
P:2D4A:RelativePlayerPosition:set offsets for relative cooordinates
P:2D4C::routine to correspond to player object
P:2D4E::load vertical coordinate low
P:2D50::store here
P:2D53::load horizontal coordinate
P:2D55::subtract left edge coordinate
P:2D59::store result here
P:2D5F:RelativeFireballPosition:set for fireball offsets
P:2D61::move offset to A
P:2D63::add amount of bytes to offset depending on setting in Y
P:2D66::put back in X and leave
P:2D69:RelWOfs:load vertical coordinate low
P:2D6B::store here
P:2D6E::load horizontal coordinate
P:2D70::subtract left edge coordinate
P:2D74::store result here
P:2D77::return original offset
P:2D79::leave
P:2D7A:SetOffscrBitsOffset:leave
P:2D7C::add contents of X to A to get
P:2D7D::appropriate offset, then give back to X
P:2D80:GetOffScreenBitsSet:save offscreen bits offset to stack for now
P:2D82::do subroutine here
P:2D89::store here
P:2D92::mask together with previously saved low nybble
P:2D94::store both here
P:2D96::get offscreen bits offset from stack
P:2D98::get value here and store elsewhere
P:2DA0:ObjOffsetData
P:2DA3:PlayerGfxTblOffsets
P:2DB3:PowerUpGfxTable:regular mushroom
P:2DB7::fire flower
P:2DBB::star
P:2DBF::1-up mushroom
P:2DC3:PowerUpAttributes:.db $d6, $d6, $d9, $d9 ;hammer suit
P:2DC8:Player_DifferenceUD:--------------------------------\n-------------------------------------------------------------------------------------\n$00-$01 - tile numbers\n$02 - Y coordinate\n$03 - flip control\n$04 - sprite attributes\n$05 - X coordinate
P:2DCA:MoveUpsideDownPiranhaP:check enemy state
P:2DCC::if set at all, branch to leave
P:2DCE::check enemy's timer here
P:2DD1::branch to end if not yet expired
P:2DD3::check movement flag
P:2DD5::if moving, skip to part ahead
P:2DD7::if currently rising, branch 
P:2DD9::to move enemy upwards out of pipe
P:2DDB::get distance between enemy object's
P:2DDD::horizontal coordinate and the player's
P:2DDE::horizontal coordinate
P:2DE0::and store here
P:2DE4::subtract borrow, then leave
P:2DE6::piranha plant, and branch if enemy to right of player
P:2DE8::otherwise get saved horizontal difference
P:2DEC::and change to two's compliment
P:2DEF::save as new horizontal difference
P:2DF1:ChkPlayerNearPipe1
P:2DFF::get saved horizontal difference
P:2E04::if player within a certain distance, branch to leave
P:2E06:ReverseUPlantSpeed:get vertical speed
P:2E0A::change to two's compliment
P:2E0D::save as new vertical speed
P:2E0F::increment to set movement flag
P:2E11:SetupToMoveUDPPlant:get original vertical coordinate (lowest point)
P:2E14::get vertical speed
P:2E16::branch if moving downwards
P:2E18::otherwise get other vertical coordinate (highest point)
P:2E1B:RiseFallUDPiranhaPlant:save vertical coordinate here
P:2E28::get frame counter
P:2E2B::branch to leave if d0 set (execute code every other frame)
P:2E2D::get master timer control
P:2E30::branch to leave if set (likely not necessary)
P:2E32::get current vertical coordinate
P:2E35::add vertical speed to move up or down
P:2E37::save as new vertical coordinate
P:2E39::compare against low or high coordinate
P:2E3B::branch to leave if not yet reached
P:2E3F::otherwise clear movement flag
P:2E43::set timer to delay piranha plant movement
P:2E46:ExMoveUDPP
P:2E47:PlayerNamesOffset
P:2E49:MarioName
P:2E49:PlayerNames
P:2E4E:LuigiName
P:2E53:XOffscreenBitsData
P:2E63:DefaultXOnscreenOfs
P:2E66:GetXOffscreenBits:save position in buffer to here
P:2E68::start with right side of screen
P:2E6A:XOfsLoop:get pixel coordinate of edge
P:2E6D::get difference between pixel coordinate of edge
P:2E6E::and pixel coordinate of object position
P:2E70::store here
P:2E72::get page location of edge
P:2E75::subtract from page location of object position
P:2E77::load offset value here
P:2E7C::if beyond right edge or in front of left edge, branch
P:2E7E::if not, load alternate offset value here
P:2E83::if one page or more to the left of either edge, branch
P:2E85::if no branching, load value here and store
P:2E89::load some other value and execute subroutine
P:2E8B::store current value in A here
P:2E8D::get pixel difference
P:2E8F::compare to preset value
P:2E91::if pixel difference >= preset value, branch
P:2E93::divide by eight
P:2E96::mask out all but 3 LSB
P:2E98::right side of the screen or top?
P:2E9A::if so, branch, use difference / 8 as offset
P:2E9C::if not, add value to difference / 8
P:2E9E:SetOscrO:use as offset
P:2E9F:ExDivPD:get bits here
P:2E9F:XLdBData
P:2EA2::reobtain position in buffer
P:2EA4::if bits not zero, branch to leave
P:2EA8::otherwise, do left side of screen now
P:2EA9::branch if not already done with left side
P:2EAB:ExXOfsBS
P:2EAC:YOffscreenBitsData
P:2EB5:DefaultYOnscreenOfs
P:2EB8:HighPosUnitData
P:2EBA:GetYOffscreenBits:save position in buffer to here
P:2EBC::start with top of screen
P:2EBE:YOfsLoop:load coordinate for edge of vertical unit
P:2EC2::subtract from vertical coordinate of object
P:2EC4::store here
P:2EC6::subtract one from vertical high byte of object
P:2ECA::load offset value here
P:2ECF::if under top of the screen or beyond bottom, branch
P:2ED1::if not, load alternate offset value here
P:2ED6::if one vertical unit or more above the screen, branch
P:2ED8::if no branching, load value here and store
P:2EDC::load some other value and execute subroutine
P:2EDE::store current value in A here
P:2EE0::get pixel difference
P:2EE2::compare to preset value
P:2EE4::if pixel difference >= preset value, branch
P:2EE6::divide by eight
P:2EE9::mask out all but 3 LSB
P:2EEB::right side of the screen or top?
P:2EED::if so, branch, use difference / 8 as offset
P:2EEF::if not, add value to difference / 8
P:2EF1:SetOscrO1:use as offset
P:2EF2:ExDivPD1:get offscreen data bits using offset
P:2EF2:YLdBData
P:2EF5::reobtain position in buffer
P:2EF9::if bits not zero, branch to leave
P:2EFB::otherwise, do bottom of the screen now
P:2EFE:ExYOfsBS
P:2EFF:RelativeEnemyPosition:get coordinates of enemy object 
P:2F01::relative to the screen
P:2F03::store value to add to A here
P:2F06::add A to value stored
P:2F08::use as enemy offset
P:2F09::load vertical coordinate low
P:2F0B::store here
P:2F0E::load horizontal coordinate
P:2F10::subtract left edge coordinate
P:2F14::store result here
P:2F17::reload old object offset and leave
P:2F1A:ShrinkPlayer:add ten bytes to frame control as offset
P:2F1C::this thing apparently uses two of the swimming frames
P:2F1E::to draw the player shrinking
P:2F1F::load offset for small player swimming
P:2F21::get what would normally be offset adder
P:2F24::and branch to use offset if nonzero
P:2F26::otherwise load offset for big player swimming
P:2F28:ShrPlF:get offset to graphics table based on offset loaded
P:2F2B::and leave
P:2F2C:ChkForPlayerAttrib:get sprite data offset
P:2F31::if executing specific game engine routine,
P:2F33::branch to change third and fourth row OAM attributes
P:2F35::get graphics table offset
P:2F3A::if crouch offset, either standing offset,
P:2F3C::or intermediate growing offset,
P:2F3E::go ahead and execute code to change 
P:2F40::fourth row OAM attributes only
P:2F46::if none of these, branch to leave
P:2F48:KilledAtt
P:2F4B::mask out horizontal and vertical flip bits
P:2F4D::for third row sprites and save
P:2F55::set horizontal flip bit for second
P:2F57::sprite in the third row
P:2F5A:C_S_IGAtt
P:2F5D::mask out horizontal and vertical flip bits
P:2F5F::for fourth row sprites and save
P:2F67::set horizontal flip bit for second
P:2F69::sprite in the fourth row
P:2F6C:ExPlyrAt:leave
P:2F6D:ShrinkPlayer2
P:2F70:HandleChangeSize:get animation frame control
P:2F75::get frame counter and execute this code every
P:2F77::fourth frame, otherwise branch ahead
P:2F79::increment frame control
P:2F7A::check for preset upper extent
P:2F7C::if not there yet, skip ahead to use
P:2F7E::otherwise initialize both grow/shrink flag
P:2F80::and animation frame control
P:2F83:CSzNext:store proper frame control
P:2F86:GorSLog
P:2F91::get player's size
P:2F94::if player small, skip ahead to next part
P:2F96::get offset adder based on frame control as offset
P:2F99::load offset for player growing
P:2F9B:GetOffsetFromAnimCtrl:multiply animation frame control
P:2F9C::by eight to get proper amount
P:2F9D::to add to our offset
P:2F9E::add to offset to graphics table
P:2FA1::and return with result in A
P:2FA2:ProcessPlayerAction:get player's state
P:2FA6::if climbing, branch here
P:2FAA::if falling, branch here
P:2FAE::if not jumping, branch here
P:2FB3::if swimming flag set, branch elsewhere
P:2FB5::load offset for crouching
P:2FB7::get crouching flag
P:2FBA::if set, branch to get offset for graphics table
P:2FBC::otherwise load offset for jumping
P:2FBE::go to get offset to graphics table
P:2FC1:ProcOnGroundActs:load offset for crouching
P:2FC3::get crouching flag
P:2FC6::if set, branch to get offset for graphics table
P:2FC8::load offset for standing
P:2FCA::check player's horizontal speed
P:2FCC::and left/right controller bits
P:2FD1::if no speed or buttons pressed, use standing offset
P:2FD3::load walking/running speed
P:2FD8::if less than a certain amount, branch, too slow to skid
P:2FDA::otherwise check to see if moving direction
P:2FDC::and facing direction are the same
P:2FDE::if moving direction = facing direction, branch, don't skid
P:2FE6::if running the change size, fire flower, injure
P:2FE8::or death game engine subroutines, skip this
P:2FEA::otherwise play skid sound
P:2FEE:NoSkidS:increment to skid offset ($03)
P:2FEF:NonAnimatedActs:load offset for crouching\nget crouching flag\nif set, branch to get offset for graphics table\nload offset for standing\ncheck player's horizontal speed\nand left/right controller bits\nif no speed or buttons pressed, use standing offset\nload walking/running speed\nif less than a certain amount, branch, too slow to skid\notherwise check to see if moving direction\nand facing direction are the same\nif moving direction = facing direction, branch, don't skid\notherwise increment to skid offset ($03)\ndo a sub here to get offset adder for graphics table
P:2FF4::initialize animation frame control
P:2FF7::load offset to graphics table using size as offset
P:2FFB:ActionFalling:load offset for walking/running
P:2FFD::get offset to graphics table
P:3000::execute instructions for falling state
P:3003:ActionWalkRun:load offset for walking/running
P:3005::get offset to graphics table
P:3008::execute instructions for normal state
P:300B:ActionClimbing:load offset for climbing
P:300D::check player's vertical speed
P:300F::if no speed, branch, use offset as-is
P:3011::otherwise get offset for graphics table
P:3014::then skip ahead to more code
P:3017:ActionSwimming:load offset for swimming
P:301C::check jump/swim timer
P:301F::and animation frame control
P:3022::if any one of these set, branch ahead
P:3026::branch to same place if A button pressed
P:3028:GetCurrentAnimOffset:get animation frame control
P:302B::jump to get proper offset to graphics table
P:302E:FourFrameExtent:load upper extent for frame control
P:3030::jump to get offset and animate player object
P:3033:ThreeFrameExtent:load upper extent for frame control for climbing
P:3035:AnimationControl:store upper extent here
P:3037::get proper offset to graphics table
P:303A::save offset to stack
P:303B::load animation frame timer
P:303E::branch if not expired
P:3040::get animation frame timer amount
P:3043::and set timer accordingly
P:3049::add one to animation frame control
P:304C::compare to upper extent
P:304E::if frame control + 1 < upper extent, use as next
P:3050::otherwise initialize frame control
P:3052:SetAnimC:store as new animation frame control
P:3055:ExAnimC:get offset to graphics table from stack and leave
P:3057:GetGfxOffsetAdder:get player's size
P:305A::if player big, use current offset as-is
P:305C::for big player
P:305D::otherwise add eight bytes to offset
P:305E::for small player
P:3061:SzOfs:go back
P:3062:GetEnemyOffscreenBits:-------------------------------------------------------------------------------------\n$00 - used in adding to get proper offset\nset A to add 1 byte in order to get enemy offset
P:3068:ChkLandedEnemyState:if enemy in normal state, branch back to jump here
P:306F::if in state used by spiny's egg
P:3073::then branch elsewhere
P:3076::if already in state used by koopas and buzzy beetles
P:3078::or in higher numbered state, branch to leave
P:307A::lda Enemy_State,x         ;load enemy state again (why?)\nif not in $02 state (used by koopas and buzzy beetles)
P:307E::then branch elsewhere
P:3081::load default timer here
P:3083::check enemy identifier for spiny
P:3087::branch if not found
P:3089::set timer for $00 if spiny
P:308B:SetForStn:set timer here
P:308E::set state here, apparently used to render
P:3090::upside-down koopas and buzzy beetles
P:3092::initialize vertical speed
P:3094::and movement force
P:30A4::do something here to vertical speed and something else
P:30A9::save high nybble of vertical coordinate, and
P:30AB::set d3, then store, probably used to set enemy object
P:30AD::neatly on whatever it's landing on
P:30AF:ExSteChk:then leave
P:30B0:DrawTitleScreen:are we in title screen mode?
P:30B5::if not, exit
P:30B8::put address $0300 into
P:30BA::the indirect at $00
P:30C8:OutputTScr
P:30D5:ChkHiByte:check high byte?
P:30D7::at $0400?
P:30D9::if not, loop back and do another
P:30DB::check if offset points past end of data (This is #$3a normally).
P:30DD::if not, loop back and do another
P:30DF::set buffer transfer control to $0300,
P:30E1::increment task and exit
P:30E4:titleScreenData:.incbin data\SMB Annoyance.nes, TitleScreenDataOffset + $8000 + $10, $13a      ; does not work\n.incbin data\SMB Annoyance.nes, $1ec0 + $8000 + $10, $13a                      ; does not work\n.incbin SMBAnnoyance.nes, $9ed0                                                ; works\n.incbin "SMB Annoyance.nes", $9ed0                                             ; works\n.incbin data\SMB Annoyance.nes, $9ed0                                          ; does not work\n.incbin SMBAnnoyance.nes, $1ec0 + $8000 + $10, $13a                            ; works\n.incbin SMBAnnoyance.nes, TitleScreenDataOffset + $8000 + $10, $13a            ; assembles, does not work\n.incbin "data\SMB Annoyance.nes", TitleScreenDataOffset + $8000 + $10, $13a    ; works\n.incbin "data/SMB Annoyance.nes", TitleScreenDataOffset + $8000 + $10, $13a    ; works\n.incbin data\SMB Annoyance.nes, $8000 + $10, $13a + TitleScreenDataOffset      ; does not work\n.incbin SMBAnnoyance.nes, $8000 + $10, $13a + TitleScreenDataOffset            ; does not work
P:320E::.db $20, $a6, $54, $26, $20, $c6, $54, $26, $20, $e6, $54, $26, $21, $06, $54, $26\n.db $20, $85, $01, $44, $20, $86, $54, $48, $20, $9a, $01, $49, $20, $a5, $c9, $46\n.db $20, $ba, $c9, $4a, $20, $a6, $0a, $d0, $d1, $d8, $d8, $de, $d1, $d0, $da, $de\n.db $d1, $20, $c6, $0a, $d2, $d3, $db, $db, $db, $d9, $db, $dc, $db, $df, $20, $e6\n.db $0a, $d4, $d5, $d4, $d9, $db, $e2, $d4, $da, $db, $e0, $21, $06, $0a, $d6, $d7\n.db $d6, $d7, $e1, $26, $d6, $dd, $e1, $e1, $21, $26, $14, $d0, $e8, $d1, $d0, $d1\n.db $de, $d1, $d8, $d0, $d1, $26, $de, $d1, $de, $d1, $d0, $d1, $d0, $d1, $26, $21\n.db $46, $14, $db, $42, $42, $db, $42, $db, $42, $db, $db, $42, $26, $db, $42, $db\n.db $42, $db, $42, $db, $42, $26, $21, $66, $46, $db, $21, $6c, $0e, $df, $db, $db\n.db $db, $26, $db, $df, $db, $df, $db, $db, $e4, $e5, $26, $21, $86, $14, $db, $db\n.db $db, $de, $43, $db, $e0, $db, $db, $db, $26, $db, $e3, $db, $e0, $db, $db, $e6\n.db $e3, $26, $21, $a6, $14, $db, $db, $db, $db, $42, $db, $db, $db, $d4, $d9, $26\n.db $db, $d9, $db, $db, $d4, $d9, $d4, $d9, $e7, $21, $c5, $16, $5f, $95, $95, $95\n.db $95, $95, $95, $95, $95, $97, $98, $78, $95, $96, $95, $95, $97, $98, $97, $98\n.db $95, $7a;, $21, $ed, $0e, $cf, $01, $09, $08, $05, $24, $17, $12, $17, $1d, $0e, $17, $0d, $18, 
P:322B::$22, $ec, $04, $1d, $18, $19, $28, $22, $f6, $01, $00, $23, $c9
P:322E::.db $56, $55, $23, $e2, $04, $99, $aa, $aa, $aa, $23, $ea, $04, $99, $aa, $aa, $aa\n.db $00, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff\n.db $21, $ed, $0e, $cf, $02, $00, $02, $01, $24, "ALEFUNKY"-55
P:3230:PauseRoutine:.db $22, $0a\n.db titleMessageEnd-titleMessageStart\ntitleMessageStart:\n.db "SCANLINE-TEST"-$37\ntitleMessageEnd:\nare we in victory mode?
P:3230:titleScreenDataEnd
P:3233::if so, go ahead
P:3237::are we in game mode?
P:3239::if not, leave
P:323B::if we are in game mode, are we running game engine?
P:3240::if not, leave
P:3256:ChkPauseTimer:lda debug			  ;check if debug mode is enabled		  \nbeq +				  ;skip the debug routine if not
P:3259::check if pause timer is still counting down
P:325E::if so, decrement and leave
P:3261:ExitPause1
P:3262:ChkStart:check to see if start is pressed
P:3265::on controller 1
P:3282::set pause timer
P:3288::is set to less than 4
P:329C:UnPause
P:32B3::lda Mirror_PPU_CTRL_REG2\neor #%01100000\nsta Mirror_PPU_CTRL_REG2\nsta PPU_CTRL_REG2
P:32CE::set pause timer
P:32D7::set pause sfx queue for next pause mode
P:32DA::invert d0 and set d7
P:32DE::unconditional branch
P:32E0:ClrPauseTimer:clear timer flag if timer is at zero and start button
P:32E3::is not pressed
P:32E5:SetPause
P:32E8:ExitPause
P:32E9:DebugModeRoutine:check to see if SELECT is pressed
P:32EC::on controller 1
P:32EE::if not don't bother checking more
P:32F7::check to see if UP is pressed
P:32F9::on controller 1
P:32FD::check to see if DOWN is pressed
P:32FF::on controller 1
P:3303::check to see if B is pressed
P:3305::on controller 1
P:3309::check to see if A is pressed
P:330B::on controller 1
P:330F::lda #$01\nsta	TextboxID\nrts
P:331C::lda GameEngineSubroutine\ncmp #$08\nbne Ex
P:3323::check if timer setting is 0 to detect pipe intro
P:3328::decrement LevelNumber so we end up on the same level for next area
P:332B:Soweback
P:3330::increment level number
P:3336:SetRunOutMusic:lda #TimeRunningOutMusic\nsta EventMusicQueue     ;load time running out music\ninc HurryUp
P:3337:Inour:check to see if world end timer expired
P:333A::this doesnt do anything (fix?) 
P:3348:Ex
P:3349:Swam
P:334B:SetSwim
P:334F::sta DebugSwim				;also store here because collision routine sets swimming flag to zero every frame\ntay\nlda Swam,y\nsta VerticalForceDown
P:3350:ChangePower:load player powerup status
P:3353::if fiery, set to small
P:3357::otherwise increment
P:335A::load mario status
P:335D::store here to prevent size change animation when hit in fiery mario
P:3360::load again (to compare if zero)
P:3363::branch if small
P:3367::set size to big
P:336A::jump to change colors
P:336D:FiretoSmall
P:336F::set status to small
P:3375::set size to small
P:337A::jump to change colors
P:337D:GrabShelltest
P:33A0::check if mario is holding anything
P:33A3::if not, branch to exit
P:33AD::jump to grab routine
P:33B0:SpriteShuffler:sample start addresses LUT\nsample lengths LUT\n        lda \n        dpcm_sample_SD2ddx2002d909Snare\n        lda <dpcm_sample_SD2ddx2002d909Snare\n        lsr\n        lsr\n        lsr\n        lsr\n        lsr\n        lsr\n        sta $00\n        lda >dpcm_sample_SD2ddx2002d909Snare\n        asl\n        asl\n        clc\n        adc $00\n        sta $4012\n        lda #$8f\n        sta $4013\n        lda #$80\n        sta $4010\n        ldx #$00\n  ldx #$00\n  stx $2000\n  stx $2001\n  stx $4010\nSND_SQUARE1_REG       = $4000\nSND_SQUARE2_REG       = $4004\nSND_TRIANGLE_REG      = $4008\nSND_NOISE_REG         = $400c\nSND_DELTA_REG         = $4010\nSND_MASTERCTRL_REG    = $4015\n        ldx #$00                ;if end of sfx reached, clear buffer\n        stx Square1SoundBuffer  ;and stop making the sfx\n        ldx #$0e\n        stx SND_MASTERCTRL_REG\n        ldx #$0f\n        stx SND_MASTERCTRL_REG\n  lda #$fe\n  sta SND_MASTERCTRL_REG\n  lda #$ff\n  sta SND_MASTERCTRL_REG\nload sample number into X\nload pitch ($00-$0F) into Y\nload starting level ($00-$7F) into a temp variable\nDPCM disable\nY = pitch\ntemp = starting sample level\nX = sample number\nDPCM enable (plays sample)\n- jmp -\n-------------------------------------------------------------------------------------\n$00 - used for preset value\nldy AreaType               ;load level type, likely residual code\nlda #$28                    ;load preset value which will put it at\nsta $00                     ;sprite #10\nstart at the end of OAM data offsets
P:33B0:sndTest
P:33B2:ShuffleLoop:check for offset value against
P:33B5::the preset value
P:33B7::if less, skip this part
P:33B9::get current offset to preset value we want to add
P:33BD::get shuffle amount, add to current sprite offset
P:33C0::if not exceeded $ff, skip second add
P:33C3::otherwise add preset value $28 to offset
P:33C5:StrSprOffset:store new offset here or old one if branched to here
P:33C8:NextSprOffset:move backwards to next one
P:33CB::load offset
P:33CF::check if offset + 1 goes to 3
P:33D1::if offset + 1 not 3, store
P:33D3::otherwise, init to 0
P:33D5:SetAmtOffset
P:33D8::load offsets for values and storage
P:33DC:SetMiscOffset:load one of three OAM data offsets
P:33DF::store first one unmodified, but
P:33E2::add eight to the second and eight
P:33E3::more to the third one
P:33E5::note that due to the way X is set up,
P:33E8::this code loads into the misc sprite offsets
P:33F2::do this until all misc spr offsets are loaded
P:33F5:LandEnemyInitState2:-------------------------------------------------------------------------------------\nBitchTable:\n		.db $08, $09, $0a, $0b, $0c, $0d, $0e, $0f\n		.db $00, $01, $02, $03, $04, $05, $06, $07\nAnotherBitchTable:\n		.db $0f, $0e, $0d, $0c, $0b, $0a, $09, $08\n		.db $07, $06, $05, $04, $03, $02, $01, $00\nPutEnemyOnSlope:\n		lda Enemy_Y_Position,x\n		sec\n		sbc #$08\n		sta tempD\n		lda Enemy_X_Position,x\n		and #$0f\n		tay\n		lda BitchTable,y\n		sta tempC\n+:		lda tempD\n		and #$0f\n		tay\n		lda AnotherBitchTable,y\n		cmp tempC\n		beq ++\n		bcs +\n++:		lda tempD\n		clc\n		adc #$10\n		and #$f0\n		clc\n		adc #$08\n		sec\n		sbc tempC\n		sta Enemy_Y_Position,x\n		lda Enemy_State,x      \n        and #%01000000          ;branch if d6 in enemy state is set\n        bne LandEnemyInitState2\n        lda Enemy_State,x\n        asl                     ;branch if d7 in enemy state is not set\n        bcs +\n	    jsr ChkLandedEnemyState\n	    lda tempD\n		clc\n		adc #$10\n		and #$f0\n		clc\n		adc #$08\n		sec\n		sbc tempC\n		sta Enemy_Y_Position,x\n		lda #$01\n		.db $2c\n+:		lda #$00\n		sta EnemyOnSlope,x\n		rts
P:33F8:Chorizo:		sty tempD\n		lda Player_X_Position\n		and #$0f\n		tay\n		lda BitchTable,y\n		sta tempC\n		lda GroundedTimer\n		cmp #$08\n		bcc ++\n+:		lda Player_Y_Position\n		and #$0f\n		tay\n		lda AnotherBitchTable,y\n		sec\n		sbc tempC\n		bpl +\n++:		lda Player_Y_Position\n		clc \n		adc #$0f\n		adc tempD\n		and #$f0\n		sec\n		sbc tempC\n		sta Player_Y_Position\n		lda #$00\n		sta Player_State\n		lda #$ff\n		sta GroundedTimer\n		ldy Player_MovingDir\n		dey\n		beq +\n		lda #$01\n		sta Player_Y_Speed\n+:		inc GroundedTimer\nSlopeExit:		\n		rts
P:33F8:PutOnSlope
P:3405:Adio:jmp GoBack
P:3408:JmpToBreakblock
P:340F:JmpGetBlockCoin
P:3413:DoSide2
P:3455:NoPe2
P:345F::regular coin?
P:3464:NoPe3:blank metatile used for vines?
P:3478::regular coin?
P:34A4:Oetu2
P:34A8:Boi2
P:34AE:Webos
P:34AF::hidden coin block?
P:34D3:jod
P:350E:SolidMTileUpperExt
P:3512:PlayerKilled2
P:3515:DoChangeSize2
P:3518:FindPlayerAction2
P:351B:PlayerGfxHandler:if player's injured invincibility timer
P:351E::not set, skip checkpoint and continue code
P:3522::otherwise check frame counter and branch
P:3524::to leave on every other frame (when d0 is set)
P:3526:CntPl:if executing specific game engine routine,
P:3528::branch ahead to some other part
P:352C::if grow/shrink flag set
P:352F::then branch to some other code
P:3531::if swimming flag set, branch to
P:3534::different part, do not return
P:3538::cmp #$00                    ;if player status normal,\nbranch and do not return
P:353A::otherwise jump and return
P:353F::check frame counter for d2 set (8 frames every
P:3541::eighth frame), and branch if set to leave
P:3543::initialize X to zero
P:3544::get player sprite data offset
P:3547::get player's facing direction
P:354A::if player facing to the right, use current offset
P:354D::otherwise move to next OAM data
P:3550:SwimKT:check player's size
P:3553::if big, use first tile
P:3555::check tile number of seventh/eighth sprite
P:3558::against tile number in player graphics table
P:355B::if spr7/spr8 tile number = value, branch to leave
P:355D::otherwise increment X for second tile
P:355E:BigKTS:overwrite tile number in sprite 7/8
P:3561::to animate player's feet when swimming
P:3564:ExPGH:then leave
P:3565:DrawOneSprite
P:3579::add eight to the offset in Y to
P:357A::move to the next two sprites
P:357F:RenderPlayerSub:store number of rows of sprites to draw
P:3584::store player's relative horizontal position
P:3587::store it here also
P:358C::store player's vertical position
P:3590::store player's facing direction
P:3595::store player's sprite attributes
P:3597::load graphics table offset
P:359A::get player's sprite data offset
P:359D:DrawPlayerLoop:load player's left side
P:35A2::now load right side
P:35A8::decrement rows of sprites to draw
P:35AA::do this until all rows are drawn
P:35AC::        lda #$75                ; tile\n        sta $00\n        lda $02                 ; load stored y position\n        sec                     ; set carry bit\n        sbc #$20                ; subtract 32\n        sta $02                 ; store it again\n        lda #$00\n        sta $04                 ; attributes\n        jsr DrawOneSprite\n        lda $05                 ; load stored x position\n        clc                     ; clear carry bit\n        adc #$0b                ; add 12\n        sta $05                 ; store it again\n        jsr DrawOneSprite
P:35AD:PlayerKilled:load offset for player killed
P:35AF::get offset to graphics table
P:35B2:PlayerGfxProcessing:store offset to graphics table here
P:35B7::draw player based on offset loaded
P:35BA::set horizontal flip bits as necessary
P:35C0::if fireball throw timer not set, skip to the end
P:35C2::set value to initialize by default
P:35C4::get animation frame timer
P:35C7::compare to fireball throw timer
P:35CA::initialize fireball throw timer
P:35CD::if animation frame timer => fireball throw timer skip to end
P:35CF::otherwise store animation timer into fireball throw timer
P:35D2::load offset for throwing
P:35D4::get offset to graphics table
P:35D7::store it for use later
P:35DA::set to update four sprite rows by default
P:35DE::check for horizontal speed or left/right button press
P:35E0::if no speed or button press, branch using set value in Y
P:35E2::otherwise set to update only three sprite rows
P:35E3:SUpdR:save in A for use
P:35E4::in sub, draw player object again
P:35E7:PlayerOffscreenChk:get player's offscreen bits
P:35EB::move vertical bits to low nybble
P:35EE::store here
P:35F0::check all four rows of player sprites
P:35F2::get player's sprite data offset
P:35F6::add 24 bytes to start at bottom row
P:35F8::set as offset here
P:35F9:PROfsLoop:load offscreen Y coordinate just in case
P:35FB::shift bit into carry
P:35FD::if bit not set, skip, do not move sprites
P:35FF::and into first row sprites
P:3602::and do sub to dump into first and second sprites
P:3605:NPROffscr
P:3606::subtract eight bytes to do
P:3607::next row up
P:360A::decrement row counter
P:360B::do this until all sprite rows are checked
P:360D::then we are done!
P:360E:PlayerCollisionCore:-------------------------------------------------------------------------------------\n$06 - second object's offset\n$07 - counter\ninitialize X to use player's bounding box for comparison
P:3610:SprObjectCollisionCore:save contents of Y here
P:3614::save value 1 here as counter, compare horizontal coordinates first
P:3616:CollisionCoreLoop:compare left/top coordinates
P:3619::of first and second objects' bounding boxes
P:361C::if first left/top => second, branch
P:361E::otherwise compare to right/bottom of second
P:3621::if first left/top < second right/bottom, branch elsewhere
P:3623::if somehow equal, collision, thus branch
P:3625::if somehow greater, check to see if bottom of
P:3628::first object's bounding box is greater than its top
P:362B::if somehow less, vertical wrap collision, thus branch
P:362D::otherwise compare bottom of first bounding box to the top
P:3630::of second box, and if equal or greater, collision, thus branch
P:3632::otherwise return with carry clear and Y = $0006
P:3634::note horizontal wrapping never occurs
P:3635:SecondBoxVerticalChk:check to see if the vertical bottom of the box
P:3638::is greater than the vertical top
P:363B::if somehow less, vertical wrap collision, thus branch
P:363D::otherwise compare horizontal right or vertical bottom
P:3640::of first box with horizontal left or vertical top of second box
P:3643::if equal or greater, collision, thus branch
P:3645::otherwise return with carry clear and Y = $0006
P:3648:FirstBoxGreater:compare first and second box horizontal left/vertical top again
P:364B::if first coordinate = second, collision, thus branch
P:364D::if not, compare with second object right or bottom edge
P:3650::if left/top of first less than or equal to right/bottom of second
P:3652::then collision, thus branch
P:3654::otherwise check to see if top of first box is greater than bottom
P:3657::if less than or equal, no collision, branch to end
P:365B::otherwise compare bottom of first to top of second
P:365E::if bottom of first is greater than top of second, vertical wrap
P:3661::collision, and branch, otherwise, proceed onwards here
P:3663:NoCollisionFound:clear carry, then load value set earlier, then leave
P:3664::like previous ones, if horizontal coordinates do not collide, we do
P:3666::not bother checking vertical ones, because what's the point?
P:3667:CollisionFound:increment offsets on both objects to check
P:3668::the vertical coordinates
P:3669::decrement counter to reflect this
P:366B::if counter not expired, branch to loop
P:366D::otherwise we already did both sets, therefore collision, so set carry
P:366E::load original value set here earlier, then leave
P:3671:BoundBoxCtrlData:-------------------------------------------------------------------------------------\n$00 - used to hold one of bitmasks, or offset\n$01 - used for relative X coordinate, also used to store middle screen page location\n$02 - used for relative Y coordinate, also used to store middle screen coordinate\nthis data added to relative coordinates of sprite objects\nstored in order: left edge, top edge, right edge, bottom edge\n00
P:3675::01
P:3679::02
P:367D::03
P:3681::04
P:3685::05
P:3689::06
P:368D::07
P:3691::08
P:3695::PAL diff: some enemies (Piranha, Bullet Bill, Goomba, Spiny, Blooper, Cheep Cheep) has larger hitbox
P:3699::09\n0a
P:369D::0b
P:36A1::0c
P:36A5::0d
P:36A9::0e
P:36AD::0f
P:36B1::10
P:36B5:GetFireballBoundBox:add seven bytes to offset
P:36B6::to use in routines as offset for fireball
P:36BA::set offset for relative coordinates
P:36BC::unconditional branch
P:36BE:GetMiscBoundBox:add nine bytes to offset
P:36BF::to use in routines as offset for misc object
P:36C3::set offset for relative coordinates
P:36C5:FBallB:get bounding box coordinates
P:36C8::jump to handle any offscreen coordinates
P:36CB:GetEnemyBoundBox:store bitmask here for now
P:36CF::store another bitmask here for now and jump
P:36D4:SmallPlatformBoundBox:store bitmask here for now
P:36D8::store another bitmask here for now
P:36DA:GetMaskedOffScrBits:get enemy object position relative
P:36DC::to the left side of the screen
P:36E0::store here
P:36E2::subtract borrow from current page location
P:36E4::of left side
P:36E7::if enemy object is beyond left edge, branch
P:36EB::if precisely at the left edge, branch
P:36ED::if to the right of left edge, use value in $00 for A
P:36EF:CMBits:otherwise use contents of Y
P:36F0::preserve bitwise whatever's in here
P:36F3::save masked offscreen bits here
P:36F6::if anything set here, branch
P:36F8::otherwise, do something else
P:36FB:LargePlatformBoundBox:increment X to get the proper offset
P:36FC::then jump directly to the sub for horizontal offscreen bits
P:36FF::decrement to return to original offset
P:3700::if completely offscreen, branch to put entire bounding
P:3702::box offscreen, otherwise start getting coordinates
P:3704:SetupEOffsetFBBox
P:3705::load 1 as offset here, same reason
P:3707::save offset here
P:3709::store object coordinates relative to screen
P:370C::vertically and horizontally, respectively
P:3713::multiply offset by four and save to stack
P:3717::use as offset for Y, X is left alone
P:3718::load value here to be used as offset for X
P:371B::multiply that by four and use as X
P:371E::add the first number in the bounding box data to the
P:3720::relative horizontal coordinate using enemy object offset
P:3721::and store somewhere using same offset * 4
P:3724::store here
P:372A::add the third number in the bounding box data to the
P:372D::relative horizontal coordinate and store
P:3730::increment both offsets
P:3732::add the second number to the relative vertical coordinate
P:3734::using incremented offset and store using the other
P:3735::incremented offset
P:373E::add the fourth number to the relative vertical coordinate
P:3741::and store
P:3744::get original offset loaded into $00 * y from stack
P:3745::use as Y
P:3746::get original offset and use as X again
P:3748::jump to handle offscreen coordinates of bounding box
P:374B:MoveBoundBoxOffscreen:multiply offset by 4
P:374E::use as offset here
P:3751::load value into four locations here and leave
P:375E:BoundingBoxCore:save offset here
P:3760::store object coordinates relative to screen
P:3763::vertically and horizontally, respectively
P:376A::multiply offset by four and save to stack
P:376E::use as offset for Y, X is left alone
P:376F::load value here to be used as offset for X
P:3772::multiply that by four and use as X
P:3775::add the first number in the bounding box data to the
P:3777::relative horizontal coordinate using enemy object offset
P:3778::and store somewhere using same offset * 4
P:377B::store here
P:3781::add the third number in the bounding box data to the
P:3784::relative horizontal coordinate and store
P:3787::increment both offsets
P:3789::add the second number to the relative vertical coordinate
P:378B::using incremented offset and store using the other
P:378C::incremented offset
P:3795::add the fourth number to the relative vertical coordinate
P:3798::and store
P:379B::get original offset loaded into $00 * y from stack
P:379C::use as Y
P:379D::get original offset and use as X again
P:37A0:CheckRightScreenBBox:add 128 pixels to left side of screen
P:37A3::and store as horizontal coordinate of middle
P:37A8::add carry to page location of left side of screen
P:37AB::and store as page location of middle
P:37AF::get horizontal coordinate
P:37B1::compare against middle horizontal coordinate
P:37B3::get page location
P:37B5::subtract from middle page location
P:37B7::if object is on the left side of the screen, branch
P:37B9::check right-side edge of bounding box for offscreen
P:37BC::coordinates, branch if still on the screen
P:37BE::load offscreen value here to use on one or both horizontal sides
P:37C0::check left-side edge of bounding box for offscreen
P:37C3::coordinates, and branch if still on the screen
P:37C5::store offscreen value for left side
P:37C8:SORte:store offscreen value for right side
P:37CB:NoOfs:get object offset and leave
P:37CE:CheckLeftScreenBBox:check left-side edge of bounding box for offscreen
P:37D1::coordinates, and branch if still on the screen
P:37D3::check to see if left-side edge is in the middle of the
P:37D5::screen or really offscreen, and branch if still on
P:37D9::check right-side edge of bounding box for offscreen
P:37DC::coordinates, branch if still onscreen
P:37DE::store offscreen value for right side
P:37E1:SOLft:store offscreen value for left side
P:37E4:NoOfs2:get object offset and leave
P:37E7:_InitializeMemory:$06 - RAM address low\n$07 - RAM address high\nset initial high byte to $0700-$07ff
P:37E9::set initial low byte to start of page (at $00 of page)
P:37ED:InitPageLoop
P:37EF:InitByteLoop:check to see if we're on the stack ($0100-$01ff)
P:37F1::if not, go ahead anyway
P:37F3::otherwise, check to see if we're at $0160-$01ff
P:37F5::if so, skip write
P:37F7:InitByte:otherwise, initialize byte with current low byte in Y
P:37F9:SkipByte
P:37FA::do this until all bytes in page have been erased
P:37FE::go onto the next page
P:37FF::do this until all pages of memory have been erased
P:3802:: set default chr banks
P:3803:SwimKickTileNum
P:3805:LakituDiffAdj
P:3808:HammerThrowTmrData
P:380A:XSpeedAdderData
P:380E:RevivedXSpeed
P:3812:SwimSpeed
P:3815:PlayerGraphicsTable:big player table\nwalking frame 1
P:381D::        frame 2
P:3825::        frame 3
P:382D::skidding
P:3835::jumping
P:383D::swimming frame 1
P:3845::         frame 2
P:384D::         frame 3
P:3855::climbing frame 1
P:385D::         frame 2
P:3865::crouching
P:386D::fireball throwing
P:3875::small player table\nwalking frame 1
P:387D::        frame 2
P:3885::        frame 3
P:388D::skidding
P:3895::jumping
P:389D::swimming frame 1
P:38A5::         frame 2
P:38AD::         frame 3
P:38B5::climbing frame 1
P:38BD::         frame 2
P:38C5::killed
P:38CD::used by both player sizes\nsmall player standing
P:38D5::intermediate grow frame
P:38DD::big player standing
P:38E5::crouching
P:38ED:FindPlayerAction:find proper offset to graphics table by player's actions
P:38F0::draw player, then process for fireball throwing
P:38F3:DoChangeSize:find proper offset to graphics table for grow/shrink
P:38F6::draw player, then process for fireball throwing
P:38F9:MetatileThingy:this table specifies the metatile id that each metatile acts like, for example, a metatile which acts like metatile id $54, acts like the ground, thus solid
P:39EB:DoWarpZone
P:39F0::load value of 4 for game text routine as default
P:39F2::warp zone (4-3-2), then check world number
P:39F7::if world number > 1, increment for next warp zone (5)
P:39FA::check area type
P:39FE::if ground area type, increment for last warp zone emanems
P:3A02::(8-7-6) and move on
P:3A03:WarpNum
P:3A04::store number here to be used by warp zone routine
P:3A07::print text and warp zone numbers
P:3A0C::load identifier for piranha plants and do sub
P:3A0F:KillEnemies:store identifier here
P:3A13::check for identifier in enemy object buffer
P:3A15:KillELoop
P:3A17::if not found, branch
P:3A1B::if found, deactivate enemy object flag
P:3A1D:NoKillE:do this until all slots are checked
P:3A21:LoadBattery
P:3A30:SaveBattery
P:3A3C:FirebarPosLookupTbl
P:3A9F:FirebarMirrorData
P:3AA3:FirebarTblOffsets
P:3AAF:FirebarYPos
P:3AB1:BlockBufferAdderData
P:3AB4:BlockBuffer_X_Adder:00-07
P:3ABC::08-0f
P:3AC4::10-17
P:3ACC::18-1f
P:3ADB:BlockBuffer_Y_Adder
P:3B02:BlockBuffer_Y_Adder3
P:3B29:jmpidk
P:3B45:QUe
P:3B52:ImpedePlayerMove
P:3B58::initialize value here
P:3B5A::get player's horizontal speed
P:3B5C::check value set earlier for
P:3B5E::left side collision
P:3B5F::if right side collision, skip this part
P:3B61::return value to X
P:3B62::if player moving to the left,
P:3B64::branch to invert bit and leave
P:3B68::otherwise load A with value to be used later
P:3B6A::and jump to affect movement
P:3B6D:RImpd:return $02 to X
P:3B6F::if player moving to the right
P:3B75::otherwise load A with value to be used here
P:3B77:NXSpd
P:3B7B::set timer of some sort
P:3B80::nullify player's horizontal speed
P:3B84::if value set in A not set to $ff,
P:3B86::branch ahead, do not decrement Y
P:3B88::otherwise decrement Y now
P:3B89:PlatF:store Y as high bits of horizontal adder
P:3B8F::add contents of A to player's horizontal
P:3B91::position to move player left or right
P:3B95::add high bits and carry to
P:3B97::page location if necessary
P:3BA1:ExIPM:invert contents of X
P:3BA4::mask out bit that was set here
P:3BA7::store to clear bit
P:3BB8:EXPM
P:3BB9:SixSpriteStacker:do six sprites
P:3BBB:StkLp:store X or Y coordinate into OAM data
P:3BBF::add eight pixels
P:3BC2::move offset four bytes forward
P:3BC5::do another sprite
P:3BC6::do this until all sprites are done
P:3BC8::get saved OAM data offset and leave
P:3BCB:MoveFlyingCheepCheep:PAL diff: reworked movement function for Cheep Cheeps\ncheck cheep-cheep's enemy state\nfor d5 set\nincrement offset for enemy offset\nposition object horizontally according to\ncounters, return with saved value in A,\ncheck cheep-cheep's enemy state
P:3BCD::for d5 set
P:3BCF::branch to continue code if not set
P:3BD3::otherwise clear sprite attributes
P:3BD6::and jump to move defeated cheep-cheep downwards
P:3BD9:FlyCC:increment offset for enemy offset                       ;increment offset for enemy offset
P:3BDA::position object horizontally according to
P:3BDD::ldx ObjectOffset            ;counters, return with saved value in A,\ncounters, return with saved value in A,
P:3BDF::set vertical movement amount
P:3BE1::set maximum speed
P:3BE3::branch to impose gravity on flying cheep-cheep
P:3BE9::get vertical movement force and
P:3BEA::move high nybble to low
P:3BED::save as offset (note this tends to go into reach of code)
P:3BEE::get vertical position
P:3BF0::subtract pseudorandom value based on offset from position
P:3BF4::if result within top half of screen, skip this part
P:3BF8::otherwise get two's compliment
P:3BFB:AddCCF:if result or two's compliment greater than eight,
P:3BFD::skip to the end without changing movement force
P:3C03::otherwise add to it
P:3C08::move high nybble to low again
P:3C0D:BPGet:load bg priority data and store (this is very likely
P:3C10::broken or residual code, value is overwritten before
P:3C13::drawing it next frame), then leave
P:3C14:BlockBufferAdderData1
P:3C17:BlockBuffer_X_Adder1:00-07
P:3C1F::08-0f
P:3C27::10-17
P:3C2F::18-1f
P:3C3D:BlockBuffer_Y_Adder1
P:3C63:BlockBuffer_Y_Adder2
P:3C89:BlockBufferAddr1
P:3C8D:BlockBufferColli_Feet:inc PlayerFoot\nif branched here, increment to next set of adders
P:3C8E:BlockBufferColli_Head:set flag to return vertical coordinate
P:3C90::BIT instruction opcode
P:3C91:BlockBufferColli_Side:set flag to return horizontal coordinate
P:3C93:BlockBufferCollision:ldx #$00       ;set offset for player object\nsave contents of A to stack
P:3C94::save contents of Y here
P:3C96::add horizontal coordinate
P:3C99::of object to value obtained using Y as offset
P:3C9C::store here
P:3C9E::of indirect here
P:3CA7::lda SprObject_PageLoc       ;get LSB, mask out all other bits\nlsr                         ;move to carry
P:3CAC::store here and leave
P:3CAE::get old contents of Y
P:3CB0::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3CB3::add it to value obtained using Y as offset
P:3CB6::mask out low nybble
P:3CB8::store result here
P:3CBA::use as offset for block buffer
P:3CBB::check current content of block buffer
P:3CBD::and store here
P:3CBF::get old contents of Y again
P:3CC1::pull A from stack
P:3CC2::if A = 1, branch
P:3CC4::if A = 0, load vertical coordinate
P:3CC6::and mask out high nybble
P:3CC8::store masked out result here
P:3CCA::get saved content of block buffer
P:3CCF::and leave, again...
P:3CD0:RetXC:otherwise load horizontal coordinate
P:3CD2::and mask out high nybble
P:3CD4::store masked out result here
P:3CD6::get saved content of block buffer
P:3CDB::and leave
P:3CDC:KillPlant
P:3CEE::mask out 2 MSB of enemy object's state
P:3CF0::set d5 to defeat enemy and save as new state
P:3CF4::play smack enemy sound
P:3CFB::get chain counter for shell
P:3D0D::mask out 2 MSB of enemy object's state
P:3D0F::set d5 to defeat enemy and save as new state
P:3D13::play smack enemy sound
P:3D23:MSBtoLSB
P:3E23:LSBtoMSB
P:3F23:BridgeCollapseData:axe
P:3F24::bridge
P:3F31:DrawPowerUp:-------------------------------------------------------------------------------------\n$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type\n$02 - used to hold bottom row Y position\n$03 - used to hold flip control (not used here)\n$04 - used to hold sprite attributes\n$05 - used to hold X position\n$07 - counter\ntiles arranged in top left, right, bottom left, right order\nget power-up's sprite data offset
P:3F40::get relative vertical coordinate
P:3F44::add eight pixels
P:3F46::store result here
P:3F48::get relative horizontal coordinate
P:3F4B::store here
P:3F51::ldx PowerUpType            ;get power-up type\nget attribute data for power-up type
P:3F54::add background priority bit if set
P:3F57::store attributes here
P:3F5A::save power-up type to the stack
P:3F5C::multiply by four to get proper offset
P:3F5D::use as X
P:3F60::set counter here to draw two rows of sprite object
P:3F6F::init d1 of flip control
P:3F71:PUpDrawLoop:load left tile of power-up object
P:3F76::load right tile
P:3F79::branch to draw one row of our power-up object
P:3F7C::decrement counter
P:3F7E::branch until two rows are drawn
P:3F80::get sprite data offset again
P:3F83::pull saved power-up type from the stack
P:3F84::if regular mushroom, branch, do not change colors or flip
P:3F88::if 1-up mushroom, branch, do not change colors or flip
P:3F8A::store power-up type here now
P:3F8C::get frame counter
P:3F8E::divide by 2 to change colors every two frames
P:3F8F::mask out all but d1 and d0 (previously d2 and d1)
P:3F91::add background priority bit if any set
P:3F94::set as new palette bits for top left and
P:3F97::top right sprites for fire flower and star
P:3F9C::check power-up type for fire flower
P:3F9D::if found, skip this part
P:3F9F::otherwise set new palette bits  for bottom left
P:3FA2::and bottom right sprites as well for star only
P:3FA5:FlipPUpRightSide
P:3FA8::set horizontal flip bit for top right sprite
P:3FB0::set horizontal flip bit for bottom right sprite
P:3FB2::note these are only done for fire flower and star power-ups
P:3FB5:PUpOfs:jump to check to see if power-up is offscreen at all, then leave
P:3FFF:: bank 01 -- custom code\n bank identifier
P:4000:MMC3Setup: THIS CODE SUCKS!!!!!!!!! :))))))
P:4010::lda #$1f\nsta $c000\nlda #$00
P:401B::set on block by default
P:4027:LoopMMC3Setup
P:406B::lda #$20\nsta $7f03\nlda #$80\nsta $ff
P:408E:MMC3SetupTable
P:4094:setCHR:setMirroring:\n    sta $a000\n    rts\n setLeftCHR sets both left CHR banks\n setRightCHR sets all 4 right CHR banks\n\n The chr is divided like this (but it can be \n inverted to switch which side gets 2 and which\n side gets 4 banks).\n\n______________________  ______________________\n| 0                  |  | 2                  |\n|                    |  |____________________|\n|                    |  | 3                  |\n|____________________|  |____________________|\n| 1                  |  | 4                  |\n|                    |  |____________________|\n|                    |  | 5                  |\n|____________________|  |____________________|\n The values used are as if they were all 2k banks.\n An example of the values is:\n CHR0: 0\n CHR1: 2\n CHR2: 4\n CHR3: 5\n CHR4: 6\n CHR5: 7\nlda #$00\nsta Old8000\nsta $8000\nlda CHR0\nsta $8001\nlda #$01\nsta Old8000\n sta $8000\nlda CHR1\nsta $8001\nlda #$02\nsta Old8000\nsta $8000\nlda CHR2\nsta $8001
P:40A5::lda #$84\n;sta $8000\nlda CHR4\nsta $8001
P:40B0::load depending of on block and pswitch flag
P:40C0::lda #$05\nsta Old8000\nsta $8000\nlda CHR5\nsta $8001
P:40C1:setLeftCHR
P:40CD:setRightCHR
P:40E0:setLeftCHRDirect
P:40FA:setRightCHRDirect
P:412B:MessageBoxData_Low:include code\lagmaker.asm
P:412C:MessageBoxData_High
P:412D:MessageBoxData
P:428E:ASCII2CHR
P:42EC::button emojis
P:42F3:TestText:01
P:4345:ID01:02
P:43AE:VeryLongText:03
P:4430:Jigas:04
P:4461:ID05:05
P:44A2:Structured:06
P:4536:Firefox:07
P:4582:Textbox_Low
P:4589:Textbox_High
P:4591:SetupTextbox
P:45A1::only increment by 1
P:45A3::write contents of A to PPU register 1
P:45A6::and its mirror
P:45D6::sets vram address to $3f00
P:45E2::set y to 0 :)
P:45ED:DisplayTextbox: DisplayTextbox
P:4675::substract lowest ascii char for smaller table
P:4691:NeedsWaitForInputAndEnd
P:4694:NeedsContinueChar
P:4697:NeedsNewLine
P:469A:NeedsWaitAndScrollNoDec
P:469D:NeedsWaitAndScroll
P:46A0:NewLineChar
P:46C9:WaitAndScrollNoDec
P:46E6:WaitAndScroll
P:4704:ScrollTextBox
P:478A:TextBoxYClearTable
P:4791:ScrollLineTable
P:47B1:NewLine
P:47C1:WaitForInputAndEnd
P:47FC::set so no jumping after closing
P:4800::set y to 0 :)
P:480B:ContinueThingy
P:480D:TableOfCompares
P:4814:ContinueChar
P:4884:CustomText_AddrTable_Low
P:4889:CustomText_AddrTable_High
P:488E:CustomText0
P:48C4:Livestext
P:48C9:WellOk
P:48D3:MessageCrash1
P:4913:EndOfDemo
P:494C:ExitHere: $00 - used to hold low byte of custom text address\n $01 - used to hold high byte of custom text address\n $03 - used to hold ascii handling state
P:494E:CustomCode
P:494E:skipCustomOperModeTask
P:4955:: load ScreenRoutineTask
P:4958:: compare it to our stored ScreenRoutineTask
P:495B:: store ScreenRoutineTask
P:495E:: branch if they're the same
P:496C::lda FinishedDemo\ncmp #$ff\nbeq xd\ninc FinishedDemo\nlda FinishedDemo\ncmp #$04\nbcs xd\nlda #$04\njmp LoadCustomText\n here we run code when ScreenRoutineTask modes are initially set\n Display a message on intermediate screen\n check ScreenRoutineTask for DisplayIntermediate
P:496E:: branch if not
P:4970:: load message
P:4972:xd:jmp LoadCustomText
P:4973:OnOffCb:Off, On, pswitchOff, pswitchoOn
P:4977:OnOffCbW:Off, On, pswitchOff, pswitchoOn (water area)
P:497B:OnOffCHR
P:4987::load CHR bank depending if block is on or pswitch is triggered
P:4998:TitleScreenCHR
P:49A0::if loading level, decrement
P:49A5:Est
P:49D1:EE
P:49D2:Force
P:49D4:jmpik:the start
P:49E0:emin
P:49E3:vaina
P:49E5:ClearRemainings2
P:4A33:ClearVRAM
P:4A3D:WorldCHRTable
P:4A46:WorldPalHigh:---------------------------------------------\n\n			START OF BANK 01\n\n---------------------------------------------
P:4A4A:WorldPalLow
P:4A4E:World4Pal
P:4A6E:World6Pal
P:4A8E:World7Pal
P:4AAE:World8Pal
P:4ACE:ChangeBankRunner
P:4B85::if in pause mode, do not bother with sprites at all
P:4B8B::check mode of operation
P:4B90::if in title screen mode, branch to lock score
P:4B92::fifth digit of coin
P:4BC6::unconditional
P:4BC8:WebosJoder
P:4BCC:ExitThere
P:4BCF:EnemyLoadingRoutine
P:4BD4::get horizontal coordinate for left side of screen
P:4BDC::store result here
P:4BE4::store result here
P:4BEA::get horizontal coordinate for left side of screen
P:4BF2::store result here
P:4BFA::store result here
P:4C02:LoopEL
P:4C08::if defeated don't load anymore
P:4C21::sign ID + 1
P:4C25::power up ID + 1
P:4C94:_LoopEL
P:4CC9:emkn
P:4CCC::check for next saved enemy
P:4CDB:ExitTher
P:4CEB::jmp ++
P:4CF0::dec GlobalSaveOffset
P:4CF3::inc GlobalSaveOffset
P:4D0B:NoPlease2
P:4D11:PSpeedHud
P:4D44::lda WorldNumber\nasl\nasl\nadd LevelNumber\ntay
P:4D4E::ldy LevelNumber
P:4DD1:WriteDat
P:4E08::lda $7f03
P:4E2B:NoPlease
P:4E4D::ldy VRAM_Buffer1_Offset   \nlda VRAM_Buffer1-6,y      ;check highest digit of score\nbne +++	                  ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-6,y\njmp ++
P:4E66::change the last 0 to a 9
P:4E75::jmp +\nlda IntervalTimerControl\nbne +\n\nlda FrameCaunter+2\nadd #$01\nsta FrameCaunter+2\nlda FrameCaunter+1\nadc #$00\nsta FrameCaunter+1\nlda FrameCaunter\nadc #$00\nsta FrameCaunter\n\nldx VRAM_Buffer1_Offset\nlda #$20\nsta VRAM_Buffer1,x\ninx\nlda #$00\nsta VRAM_Buffer1,x\ninx\nlda #$06\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter\nand #$f0\nlsr\nlsr\nlsr\nlsr\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter\nand #$0f\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+1\nand #$f0\nlsr\nlsr\nlsr\nlsr\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+1\nand #$0f\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+2\nand #$f0\nlsr\nlsr\nlsr\nlsr\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+2\nand #$0f\nsta VRAM_Buffer1,x\ninx\nlda #$00\nsta VRAM_Buffer1,x\nstx VRAM_Buffer1_Offset\nlda EvenFrame\neor #$01\nsta EvenFrame\nldx $07eb					;load first digit of coin counter\ndex\nbne ++\ninc UnlockWorld9			;unlock world 9
P:4E80::get primary mode of operation
P:4E83::branch to set title screen CHR
P:4E85::are we in game over mode?
P:4E87::if so, proceed change platform sprite to the coin heaven one
P:4E89::check timer to change CHR
P:4E8C::branch if zero
P:4E94::if cloud level override flag not set, use normal platform CHR
P:4E96:CldPlt
P:4E9E::set cloud platform sprite
P:4EA3::skip to FireballCooldown
P:4EA6:NrmlPl
P:4EAE::set normal platform sprite
P:4EB3:FireballCooldown:if fireball cooldown set, don't decrement
P:4ECB::check grabflag
P:4ECE::branch if not
P:4EDA::set grabbing sprite
P:4EE0:Chavo
P:4F00::set normal sprite
P:4F34::set grabbing sprite
P:4F3A::do not animate if master timer set
P:4F3F::branch if not under 60 seconds
P:4F4C::check if last animation CHR bank
P:4F4E::if not, skip this
P:4F52::set first animation CHR bank and
P:4F55::jump to speed up animation
P:4F83::check ptimer
P:4F86::branch to set if set
P:4F88::if ptimer is 0
P:4F8B::then save only bit 0
P:4F96::load animation depending of the area type
P:4F99::increment bank timer
P:4FA6:PSwitchBank
P:4FBF:Fuk
P:4FCD:@e
P:4FD0:@i
P:4FDE:Bank1
P:4FE5:BankR
P:4FE7::reset bank change
P:4FED:PSwitchBank1
P:4FF0:AnimAdder
P:4FF8:AreaAdder
P:4FFC:AreaAdderP
P:5000:HurryUpChg
P:5005::lda PTimer\nbne PSwitchBank1\nlda #$01\nsta ChangeBankRDelay\n+:		 dec ChangeBankRDelay
P:501B::add #%01000100
P:5021::if ptimer not set
P:5024::save only bit 0
P:503D::increment bank timer
P:504A:bocataprint:store player-specific offset
P:504C::use first nybble to print the coin display
P:504F::move high nybble to low
P:5051::and print to score display
P:5055:OutputNumbers1:add 1 to low nybble
P:5058::mask out high nybble
P:505E::save incremented value to stack for now and
P:505F::shift to left and use as offset
P:5061::get current buffer pointer
P:5068::put at top of screen by default
P:506A::are we writing top score on title screen?
P:506E::if so, put further down on the screen
P:5070:SetupNums1
P:5073::write low vram address and length of thing
P:5076::we're printing to the buffer
P:507F::save length byte in counter
P:5083::pull original incremented value from stack
P:5085::load offset to value we want to write
P:5089::subtract from length byte we read before
P:508C::use value as offset to display digits
P:508F:DigitPLoop1:write digits to the buffer
P:5097::do this until all the digits are written
P:509B::put null terminator at end
P:50A0::increment buffer pointer by 3
P:50A3::store it in case we want to use it again
P:50A6:ExitOutput1
P:50AC:Text_AddrTable_Low
P:50B4:Text_AddrTable_High
P:50BC:MuchoTexto
P:50D9:PocoTexto
P:50ED:Studs
P:5107:pending
P:511E:hellfire
P:5133:smbarena
P:514E:obviouslyme
P:5166:ElPepe
P:517A:PauseMenu
P:5190:UnPauses
P:5196:Clear6400
P:519D:DrawMenuCursorj
P:51A3:Some
P:51AA:SetPauseBG
P:51C1:Noth
P:51C2:DisplayPauseMenu
P:51C6::set pause sfx queue for next pause mode
P:51F7:MusicMutetxt
P:5206:MusicMuteON
P:5215:PSoundtxt
P:522C:PSoundON
P:5243:RestartText
P:5254:QTTSText
P:5266:DisplayMenuText:$28a2
P:526A::otherwise store A and B buttons in $0a
P:5271::store left and right buttons in $0c
P:527D::store up and down buttons in $0b
P:52DA:WhenTheSus
P:52E0::cmp #$05\nbcs ++
P:52EB:MusicSetting
P:5319:PauseMenuExit
P:531A:PSoundSetting
P:5349:RestartSetting:inc FetchNewGameTimerFlag ;set flag to load new game timer\ninc DisableScreenFlag     ;set flag to disable screen output
P:5386:QuitToTitleScreen
P:53CE:DrawMenuCursor
P:53F4::lda #$00\nsta VRAM_Buffer1+4,x
P:5429:DoFlagpoleEnemy
P:5431::multiply current offset where we're at by 16
P:5434::to obtain horizontal pixel coordinate
P:5438::get pixel coordinate of where the flagpole is,
P:5439::subtract eight pixels and use as horizontal
P:543E::sta Enemy_X_Position,x   ;coordinate for the flag
P:5441::subtract borrow from page location and use as
P:5446::page location for the flag
P:544F::set vertical coordinate for flag
P:5453::set initial vertical coordinate for flagpole's floatey number
P:5458::set flag identifier, note that identifier and coordinates
P:545F::use last space in enemy object buffer
P:5462:jmpidk2
P:546F:QUe2
P:547C:PlayerColorsOffset1
P:547E:MarioColors1:Small
P:547E:PlayerColors1
P:5482::Big
P:5486::Fiery
P:548A:LuigiColors1:Small
P:548E::Big
P:5492::Fiery
P:5496:BackgroundColors1:used by area type if bg color ctrl not set
P:549A::used by background color control if set
P:54A2:GetPlayerColors2:get current buffer offset
P:54B6:StartClrGet1:do four colors
P:54BA:ClrGetLoop1:fetch player colors and store them
P:54BD::in the buffer
P:54C6::load original offset from before
P:54C9::if this value is four or greater, it will be set
P:54CC::therefore use it as offset to background color
P:54D8::otherwise use area type bits from area offset as offset
P:54DB:SetBGColor1:to background color instead
P:54E1::set for sprite palette address
P:54E3::save to buffer
P:54EB::write length byte to buffer
P:54F0::now the null terminator
P:54F5::move the buffer pointer ahead 7 bytes
P:54F6::in case we want to write anything else later
P:54F9::store as new vram buffer offset
P:54FD:Hitboxes
P:5534:PPhitbox1
P:5536:MoveAllSpritesOffscreen1:ldy #$00                ;this routine moves all sprites off the screen\n.byte $2c                 ;BIT instruction opcode\nthis routine moves all but sprite 0
P:5536:MoveSpritesOffscreen1
P:5538::off the screen
P:553A:SprInitLoop:sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
P:55FB:BlankPalette
P:5603:Palette2Data:used based on area type
P:5613:ColorRotation:check vram buffer offset
P:5618::if offset over 48 bytes, branch to leave
P:561A::otherwise use frame counter's 3 LSB as offset here
P:561C:GetBlankPal:get blank palette for palette 3
P:561F::store it in the vram buffer
P:5622::increment offsets
P:5626::do this until all bytes are copied
P:5628::get current vram buffer offset
P:562D::set counter here
P:5636::get area type
P:5639::multiply by 4 to get proper offset
P:563B::save as offset here
P:563C:GetAreaPal
P:5647::fetch palette to be written based on area type
P:564A::store it to overwrite blank palette in vram buffer
P:564F::decrement counter
P:5651::do this until the palette is all copied
P:5656::add seven bytes to vram buffer offset
P:565C:ExitColorRot:leave
P:565D:EnemyGraphicsTable:-------------------------------------------------------------------------------------\n$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers\n$02 - used to store Y position\n$03 - used to store moving direction, used to flip enemies horizontally\n$04 - used to store enemy's sprite attributes\n$05 - used to store X position\n$eb - used to hold sprite data offset\n$ec - used to hold either altered enemy state or special value used in gfx handler as condition\n$ed - used to hold enemy state from buffer \n$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)\ntiles arranged in top left, right, middle left, right, bottom left, right order\nbuzzy beetle frame 1
P:5663::             frame 2
P:5669::koopa troopa frame 1
P:566F::             frame 2
P:5675::koopa paratroopa frame 1
P:567B::                 frame 2
P:5681::spiny frame 1
P:5687::      frame 2
P:568D::spiny's egg frame 1
P:5693::            frame 2
P:5699::bloober frame 1
P:569F::        frame 2
P:56A5::cheep-cheep frame 1
P:56AB::            frame 2
P:56B1::goomba
P:56B7::koopa shell frame 1 (upside-down)
P:56BD::            frame 2
P:56C3::koopa shell frame 1 (rightsideup)
P:56C9::            frame 2
P:56CF::buzzy beetle shell frame 1 (rightsideup)
P:56D5::                   frame 2
P:56DB::buzzy beetle shell frame 1 (upside-down)
P:56E1::                   frame 2
P:56E7::defeated goomba
P:56ED::lakitu frame 1
P:56F3::       frame 2
P:56F9::princess
P:56FF::mushroom retainer
P:5705::hammer bro frame 1
P:570B::           frame 2
P:5711::           frame 3
P:5717::           frame 4
P:571D::piranha plant frame 1
P:5723::              frame 2
P:5729::podoboo
P:572F::bowser front frame 1
P:5735::bowser rear frame 1
P:573B::       front frame 2
P:5741::       rear frame 2
P:5747::bullet bill
P:5753:EnemyGfxTableOffsets:.db $f2, $f2, $f3, $f3, $f2, $f2  ;jumpspring frame 1\n.db $f1, $f1, $f1, $f1, $fc, $fc  ;           frame 2\n.db $f0, $f0, $fc, $fc, $fc, $fc  ;           frame 3
P:575B::0f
P:576B::1f
P:5776:EnemyAttributeData
P:577E::0f
P:578E::1f
P:5799:EnemyAnimTimingBMask
P:579B:JumpspringFrameOffsets
P:57A0:SignPalettes
P:57A4:EnemyGfxHandler1:get enemy object vertical position
P:57A8::get enemy object horizontal position
P:57AB::relative to screen
P:57B0::get sprite data offset
P:57B4::initialize vertical flip flag by default
P:57B9::get enemy object moving direction
P:57BE::get enemy object sprite attributes
P:57DB::is enemy object piranha plant?
P:57DD::if not, branch
P:57E1::if piranha plant moving upwards, branch
P:57E6::if timer for movement expired, branch
P:57E8::if all conditions fail, leave
P:57E9:CheckForRetainerObj:store enemy state
P:57ED::nullify all but 5 LSB and use as Y
P:57F0::check for mushroom retainer/princess object
P:57F4::if not found, branch
P:57F6::if found, nullify saved state in Y
P:57F8::set value that will not be used
P:57FC::set value $15 as code for mushroom retainer/princess object
P:57FE:CheckForBulletBillCV:otherwise check for bullet bill object
P:5800::if not found, branch again
P:5802::decrement saved vertical position
P:5806::get timer for enemy object
P:5809::if expired, do not set priority bit
P:580B::otherwise do so
P:580D:SBBAt:set new sprite attributes
P:580F::nullify saved enemy state both in Y and in
P:5811::memory location here
P:5813::set specific value to unconditionally branch once
P:5815:CheckForPodoboo:CheckForJumpspring:\n      cmp #JumpspringObject        ;check for jumpspring object\n      bne CheckForPodoboo\n      ldy #$03                     ;set enemy state -2 MSB here for jumpspring object\n      ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object\n      lda JumpspringFrameOffsets,x ;load data using frame number as offset\nstore saved enemy object value here
P:5817::and Y here (enemy state -2 MSB if not changed)
P:5819::get enemy object offset
P:581B::check for podoboo object
P:581D::branch if not found
P:581F::if moving upwards, branch
P:5823::otherwise, set flag for vertical flip
P:5826:CheckBowserGfxFlag:if not drawing bowser at all, skip to something else
P:582B::if set to 1, draw bowser's front
P:5831::otherwise draw bowser's rear
P:5832:SBwsrGfxOfs
P:5834:CheckForGoomba:check value for goomba object
P:5840::branch if not found
P:5844::check for defeated state
P:5846::if not defeated, go ahead and animate
P:5848::if defeated, write new value here
P:584C:GmbaAnim:check for d5 set in enemy object state 
P:584E::or timer disable flag set
P:5851::if either condition true, do not animate goomba
P:5855::check for every eighth frame
P:585B::invert bits to flip horizontally every eight frames
P:585D::leave alone otherwise
P:585F:CheckBowserFront
P:5875::load sprite attribute using enemy object
P:5878::as offset, and add to bits already loaded
P:587C::load value based on enemy object as offset
P:587F::save as X
P:5880::get previously saved value
P:5885::if not drawing bowser object at all, skip all of this
P:5889::if not drawing front part, branch to draw the rear part
P:588B::check bowser's body control bits
P:588E::branch if d7 not set (control's bowser's mouth)      
P:5890::otherwise load offset for second frame
P:5892:ChkFrontSte:check saved enemy state
P:5894::if bowser not defeated, do not set flag
P:5898:FlipBowserOver:set vertical flip flag to nonzero
P:589B:DrawBowser:draw bowser's graphics now
P:589E:CheckBowserRear:check bowser's body control bits
P:58A3::branch if d0 not set (control's bowser's feet)
P:58A5::otherwise load offset for second frame
P:58A7:ChkRearSte:check saved enemy state
P:58A9::if bowser not defeated, do not set flag
P:58AD::subtract 16 pixels from
P:58AF::saved vertical coordinate
P:58B4::jump to set vertical flip flag
P:58B7:CheckForSpiny:check if value loaded is for spiny
P:58B9::if not found, branch
P:58BB::if enemy state set to $05, do this,
P:58BD::otherwise branch
P:58BF::set to spiny egg offset
P:58C3::set enemy direction to reverse sprites horizontally
P:58C7::set enemy state
P:58C9:NotEgg:skip a big chunk of this if we found spiny but not in egg
P:58CC:CheckForLakitu:check value for lakitu's offset loaded
P:58CE::branch if not loaded
P:58D2::check for d5 set in enemy state
P:58D4::branch if set
P:58D9::check timer to see if we've reached a certain range
P:58DB::branch if not
P:58DD::if d6 not set and timer in range, load alt frame for lakitu
P:58DF:NoLAFr:skip this next part if we found lakitu but alt frame not needed
P:58E2:CheckUpsideDownShell:check for enemy object => $04
P:590D::branch if true
P:5911::branch if enemy state < $02
P:5913::set for upside-down koopa shell by default
P:5917::check for buzzy beetle object
P:591D::increment vertical position by one pixel
P:591F:CheckRightSideUpShell:check for value set here
P:5921::if enemy state < $02, do not change to shell, if
P:5923::enemy state => $02 but not = $04, leave shell upside-down
P:5925::set right-side up buzzy beetle shell by default
P:5927::increment saved vertical position by one pixel
P:592B::check for buzzy beetle object
P:592D::branch if found
P:592F::change to right-side up koopa shell if not found
P:5931::and increment saved vertical position again
P:5933:CheckForDefdGoomba:check for goomba object (necessary if previously
P:5935::failed buzzy beetle object test)
P:593B::load for regular goomba
P:593D::note that this only gets performed if enemy state => $02
P:593F::check saved enemy state for d5 set
P:5941::branch if set
P:5943::load offset for defeated goomba
P:5945::set different value and decrement saved vertical position
P:5947:CheckForHammerBro
P:5949::check for hammer bro object
P:594D::branch if not found
P:5951::branch if not in normal enemy state
P:5955::if d3 not set, branch further away
P:5957::otherwise load offset for different frame
P:5959::unconditional branch
P:595B:CheckForBloober:check for cheep-cheep offset loaded
P:595D::branch if found
P:5964::branch if some timer is above a certain point
P:5966::check for bloober offset loaded
P:5968::branch if not found this time
P:596C::branch if timer is set to certain point
P:596E::increment saved vertical coordinate three pixels
P:5974::and do something else
P:5977:CheckToAnimateEnemy:check for specific enemy objects
P:5983::branch if goomba
P:598B::branch if bullet bill (note both variants use $08 here)
P:598F::branch if podoboo
P:599D::branch if => $18
P:59A3::check for mushroom retainer/princess object
P:59A5::which uses different code here, branch if not found
P:59A7::iny                      ;residual instruction\nare we on world 8?
P:59AC::if so, leave the offset alone (use princess)
P:59AE::otherwise, set for mushroom retainer object instead
P:59B0::set alternate state here
P:59B4::unconditional branch
P:59B6:CheckForSecondFrame:load frame counter
P:59B8::mask it (partly residual, one byte not ever used)
P:59BB::branch if timing is off
P:59BD:CheckAnimationStop:check saved enemy state
P:59BF::for d7 or d5, or check for timers stopped
P:59C4::if either condition true, branch
P:59CE::add $06 to current enemy offset
P:59D0::to animate various enemy objects
P:59D1:CheckDefeatedState
P:59DB::check saved enemy state
P:59DD::for d5 set
P:59DF::branch if not set
P:59E3::check for saved enemy object => $04
P:59E5::branch if less
P:59ED::set vertical flip flag
P:59F1::init saved value here
P:59F3:DrawEnemyObject:load sprite data offset
P:59F5::draw six tiles of data
P:59F8::into sprite data
P:59FE::get enemy object offset
P:5A00::get sprite data offset
P:5A05::get saved enemy object and check
P:5A07::for bullet bill, branch if not found
P:5A09:SkipToOffScrChk:jump if found
P:5A0C:CheckForVerticalFlip:check if vertical flip flag is set here
P:5A0F::branch if not
P:5A11::get enemy object offset
P:5A13::get sprite data offset
P:5A16::get attributes of first sprite we dealt with
P:5A19::set bit for vertical flip
P:5A1C::increment two bytes so that we store the vertical flip
P:5A1D::dump A contents
P:5A20::into third row sprites
P:5A23::into second row sprites
P:5A29::and into first row sprites
P:5A2C::in attribute bytes of enemy obj sprite data
P:5A30::now go back to the Y coordinate offset
P:5A32::give offset to X
P:5A35::check saved enemy object for hammer bro
P:5A39::check saved enemy object for lakitu
P:5A3B::branch for hammer bro or lakitu
P:5A4B::also branch if enemy object => $15
P:5A4F::if not selected objects or => $15, set
P:5A51::offset in X for next row
P:5A52:FlipEnemyVertically:load first or second row tiles
P:5A55::and save tiles to the stack
P:5A5A::exchange third row tiles
P:5A5D::with first or second row tiles
P:5A66::pull first or second row tiles from stack
P:5A67::and save in third row
P:5A6E:CheckForESymmetry:are we drawing bowser at all?
P:5A71::branch if so
P:5A75::get alternate enemy state
P:5A77::check for hammer bro object
P:5A7B::jump if found
P:5A7E:CheckToMirrorLakitu1
P:5A81:ContES:check for bloober object
P:5A85::check for piranha plant object
P:5A95::check for podoboo object
P:5A97::branch if either of three are found
P:5A99::check for spiny object
P:5A9B::branch closer if not found
P:5A9D::check spiny's state
P:5A9F::branch if not an egg, otherwise
P:5AA1:ESRtnr:check for princess/mushroom retainer object
P:5AA5::set horizontal flip on bottom right sprite
P:5AA7::note that palette bits were already set earlier
P:5AAA:SpnySC:if alternate enemy state set to 1 or 0, branch
P:5AAE:MirrorEnemyGfx:if enemy object is bowser, skip all of this
P:5AB3::load attribute bits of first sprite
P:5AB8::save vertical flip, priority, and palette bits
P:5ABB::in left sprite column of enemy object OAM data
P:5AC1::set horizontal flip
P:5AC3::check for state used by spiny's egg
P:5AC5::if alternate state not set to $05, branch
P:5AC7::otherwise set vertical flip
P:5AC9:EggExc:set bits of right sprite column
P:5ACC::of enemy object sprite data
P:5AF4::check alternate enemy state
P:5AF6::branch if not $04
P:5AF9::get second row left sprite attributes
P:5AFE::store bits with vertical flip in
P:5B01::second and third row left sprites
P:5B06::store with horizontal and vertical flip in
P:5B09::second and third row right sprites
P:5B0C:CheckToMirrorLakitu
P:5B12::check if enemy ID is piranha plant
P:5B16::store current X in here
P:5B1E::get the piranha's root Y position
P:5B24::	iny
P:5B35::subtract the current piranha position from it
P:5B37::and to check every 8 difference
P:5B3C::rotate xxxxx000 -> 000xxxxx
P:5B3E::load from this table, 0->this sprite is inside the pipe, 1->this sprite is outside of pipe
P:5B41::store it into a temporary address
P:5B44::rotate to the right, bit 0 becomes carry
P:5B47::if carry is clear, piranha is inside the pipe (this can be optimized to branch to the end of the code)
P:5B49::otherwise get the sprite attribute
P:5B51::do it with the sprite next to it aswell
P:5B59::same procedure as earlier
P:5B6E::same procedure as earlier
P:5B86:exitPiranha
P:5B8E::store current X in here
P:5B93::get the piranha's root Y position
P:5B9A::subtract the current piranha position from it
P:5B9C::and to check every 8 difference
P:5BA1::rotate xxxxx000 -> 000xxxxx
P:5BA3::load from this table, 0->this sprite is inside the pipe, 1->this sprite is outside of pipe
P:5BA6::store it into a temporary address
P:5BA9::rotate to the right, bit 0 becomes carry
P:5BAC::if carry is clear, piranha is inside the pipe (this can be optimized to branch to the end of the code)
P:5BBE::same procedure as earlier
P:5BD3::same procedure as earlier
P:5BD8::otherwise get the sprite attribute
P:5BE0::do it with the sprite next to it aswell
P:5BEB:exitPiranhaUD:check for lakitu enemy object
P:5BEF::branch if not found
P:5BF4::branch if vertical flip flag not set
P:5BF6::save vertical flip and palette bits
P:5BF9::in third row left sprite
P:5BFE::set horizontal flip and palette bits
P:5C01::in third row right sprite
P:5C06::check timer
P:5C0B::branch if timer has not reached a certain range
P:5C0D::otherwise set same for second row right sprite
P:5C12::preserve vertical flip and palette bits for left sprite
P:5C15::unconditional branch
P:5C17:NVFLak:get first row left sprite attributes
P:5C1C::save vertical flip and palette bits
P:5C1F::get first row right sprite attributes
P:5C22::set horizontal flip and palette bits
P:5C24::note that vertical flip is left as-is
P:5C2A:PiranhaTable:CheckToMirrorJSpring:\nlda temp4                   ;check for jumpspring object (any frame)\ncmp #$18\nbcc SprObjectOffscrChk      ;branch if not jumpspring object at all\ncmp #RedKoopaShell\nbeq SprObjectOffscrChk\ncmp #RedPiranhaPlant\nbeq SprObjectOffscrChk\ncmp #RUDPiranhaPlant\nbeq SprObjectOffscrChk\ncmp #UDPiranhaPlant\nbeq SprObjectOffscrChk\nlda #$82\nsta Sprite_Attributes+8,y   ;set vertical flip and palette bits of \nsta Sprite_Attributes+16,y  ;second and third row left sprites\nora #%01000000\nsta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip\nsta Sprite_Attributes+20,y  ;for second and third row right sprites
P:5C2E:UDPiranhaTable
P:5C33:GameOverCursorData:.db $5b, $02, $48
P:5C36:GameOverCursorY:, $a7, $bf, $d7
P:5C38:GameOverMenu
P:5C6B::if player pressed the start button
P:5C6E::then either continue or start over
P:5C75::if player pressed the select button
P:5C77::then branch to select "continue" or "retry"
P:5C90::and toggle between the two choices
P:5C92::            inc ContinueMenuSelect\n            lda ContinueMenuSelect\n            and #$03
P:5C94:ChgSel
P:5C96:ChgSelLoop:set up cursor sprite tile, attribute
P:5C99::and X position in sprite OAM data
P:5CA1::set Y position based on the selection
P:5CAE:ContinueOrRetry:if player selected "continue"
P:5CB0::then branch to continue
P:5CB2::lda #$00\nsta CompletedWorlds          ;otherwise init completed worlds flags
P:5CB9:Continue
P:5CBB::give five lives
P:5CCE::put at x-1 of the current world
P:5CD5:ISCont:reset score
P:5CDB::allow 1-up to be found again
P:5CE4:LevelSelectAreasOffsets1
P:7FFF:: bank 02 -- relocated original sound code\n bank identifier
P:8000:SoundEngine:are we in title screen mode?
P:8005::if so, disable sound and leave
P:8009:SndOn
P:800B::disable irqs and set frame counter mode???
P:8010::enable first four channels
P:8013::is sound already in pause mode?
P:8018::if not, check pause sfx queue    
P:801C::if queue is empty, skip pause mode routine
P:801E:InPause:check pause sfx buffer
P:8023::check pause queue
P:8027::if queue full, store in buffer and activate
P:802A::pause mode to interrupt game sounds
P:802D::disable sound and clear sfx buffers
P:803A::enable sound again
P:803D::store length of sound in pause counter
P:8042:PTone1F:play first tone
P:8044::unconditional branch
P:8046:ContPau:check pause length left
P:8049::time to play second?
P:804D::time to play first again?
P:8051::time to play second again?
P:8053::only load regs during times, otherwise skip
P:8055:PTone2F:store reg contents and play the pause sfx
P:8057:PTRegC
P:805E:DecPauC:decrement pause sfx counter
P:8063::lda #$00                  ;disable sound if in pause mode and
P:8068::not currently playing the pause sfx
P:806B::if no longer playing pause sfx, check to see
P:806E::if we need to be playing sound again
P:8072::clear pause mode to allow game sounds again
P:8077:SkipPIn:clear pause sfx buffer
P:807E:RunSoundSubroutines:play sfx on square channel 1
P:8081:: ''  ''  '' square channel 2
P:8084:: ''  ''  '' noise channel
P:8087::play music on all channels
P:808A::clear the music queues
P:8090:SkipSoundSubroutines:clear the sound effects queues
P:809A::load some sort of counter 
P:809F::check for specific music
P:80A3::increment and check counter
P:80A8::if not there yet, just store it
P:80AA:NoIncDAC
P:80AB::if we are at zero, do not decrement 
P:80AD::decrement counter
P:80B0:StrWave:store into DMC load register (??)
P:80B3::we are done here
P:80B4:Dump_Squ1_Regs:--------------------------------\ndump the contents of X and Y into square 1's control regs
P:80BB:PlaySqu1Sfx:do sub to set ctrl regs for square 1, then set frequency regs
P:80BE:SetFreq_Squ1:set frequency reg offset for square 1 sound channel
P:80C0:Dump_Freq_Regs
P:80C1::use previous contents of A for sound reg offset
P:80C4::if zero, then do not load
P:80C6::first byte goes into LSB of frequency divider
P:80C9::second byte goes into 3 MSB plus extra bit for 
P:80CC::length counter
P:80D1:NoTone
P:80D2:Dump_Sq2_Regs:dump the contents of X and Y into square 2's control regs
P:80D9:PlaySqu2Sfx:do sub to set ctrl regs for square 2, then set frequency regs
P:80DC:SetFreq_Squ2:set frequency reg offset for square 2 sound channel
P:80DE::unconditional branch
P:80E0:SetFreq_Tri:set frequency reg offset for triangle sound channel
P:80E2::unconditional branch
P:80E4:SwimStompEnvelopeData:--------------------------------
P:80F2:PlayFlagpoleSlide:store length of flagpole sound
P:80F7::load part of reg contents for flagpole sound
P:80FC::now load the rest
P:8100:PlaySmallJump:branch here for small mario jumping sound
P:8104:PlayBigJump:branch here for big mario jumping sound
P:8106:JumpRegContents:note that small and big jump borrow each others' reg contents
P:8108::anyway, this loads the first part of mario's jumping sound
P:810D::store length of sfx for both jumping sounds
P:810F::then continue on here
P:8112:ContinueSndJump:jumping sounds seem to be composed of three parts
P:8115::check for time to play second part yet
P:8119::load second part
P:811D::unconditional branch
P:811F:N2Prt:check for third part
P:8123::load third part
P:8125:FPS2nd:the flagpole slide sound shares part of third part
P:8127:DmpJpFPS
P:812A::unconditional branch outta here
P:812C:PlayFireballThrow
P:812E::load reg contents for fireball throw sound
P:8130::unconditional branch
P:8132:PlayBump:load length of sfx and reg contents for bump sound
P:8136:Fthrow:the fireball sound shares reg contents with the bump sound
P:813B::load offset for bump sound
P:8140:ContinueBumpThrow:check for second part of bump sound
P:8147::load second part directly
P:814C:DecJpFPS:unconditional branch
P:814E:_PlayPipeDownInj
P:8151:_PlayFlagpoleSlide
P:8154:Square1SfxHandler:check for sfx in queue
P:8158::if found, put in buffer
P:815A::small jump
P:815E::big jump
P:8162::bump
P:8166::swim/stomp
P:816A::smack enemy
P:816E::pipedown/injury
P:8172::fireball throw
P:8176::slide flagpole
P:8178:CheckSfx1Buffer:check for sfx in buffer 
P:817A::if not found, exit sub
P:817C::small mario jump 
P:817F::big mario jump 
P:8182::bump
P:8185::swim/stomp
P:8188::smack enemy
P:818B::pipedown/injury
P:818E::fireball throw
P:8191::slide flagpole
P:8193:ExS1H
P:8194:PlaySwimStomp:store length of swim/stomp sound
P:8199::store reg contents for swim/stomp sound
P:81A2:ContinueSwimStomp:look up reg contents in data section based on
P:81A5::length of sound left, used to control sound's
P:81A8::envelope
P:81AF::when the length counts down to a certain point, put this
P:81B1::directly into the LSB of square 1's frequency divider
P:81B4:BranchToDecLength1:unconditional branch (regardless of how we got here)
P:81B6:PlaySmackEnemy:store length of smack enemy sound
P:81BF::store reg contents for smack enemy sound
P:81C4::unconditional branch
P:81C6:ContinueSmackEnemy
P:81CC::check about halfway through
P:81D3::if we're at the about-halfway point, make the second tone
P:81D5::stomp counter 1: #%10100000
P:81E0::in the smack enemy sound
P:81E7:SmSpc:this creates spaces in the sound, giving it its distinct noise
P:81E9:SmTick
P:81EC:DecrementSfx1Length:decrement length of sfx
P:81F1:StopSquare1Sfx
P:81F4:ExSfx1
P:81F5:PlayPipeDownInj:load length of pipedown sound
P:81FA:ContinuePipeDownInj:some bitwise logic, forces the regs
P:81FD::to be written to only during six specific times
P:81FE::during which d3 must be set and d1-0 must be clear
P:8207::and this is where it actually gets written in
P:8210:NoPDwnL
P:8213:NormalContinueSwimStomp:--------------------------------\ncheck about halfway through
P:821A::if we're at the about-halfway point, make the second tone
P:821C::in the smack enemy sound
P:8223:SmSpc1:this creates spaces in the sound, giving it its distinct noise
P:8225:SmTic1
P:8230:PowerUpGrabFreqData
P:824B::residual frequency data
P:824E:ExtraLifeFreqData
P:8254:PUp_VGrow_FreqData:used by both
P:8264::used by vinegrow
P:8274:PlayCoinGrab:load length of coin grab sound
P:8276::and part of reg contents
P:827A:PlayTimerTick:load length of timer tick sound
P:827C::and part of reg contents
P:8281::load the rest of reg contents 
P:8283::of coin grab and timer tick sound
P:828B:CGrab_TTickRegL
P:828E::load the rest of reg contents 
P:8290::of coin grab and timer tick sound
P:8295:ContinueCGrabTTick:check for time to play second tone yet
P:8298::timer tick sound also executes this, not sure why
P:829C::if so, load the tone directly into the reg
P:82A1:N2Tone
P:82A3:N2Ton3:lda #$54
P:82B8:PlayBlast:load length of fireworks/gunfire sound
P:82BD::load reg contents of fireworks/gunfire sound
P:82C3:ContinueBlast:check for time to play second part
P:82CA::load second part reg contents then
P:82CE:SBlasJ:unconditional branch to load rest of reg contents
P:82D1:PlayPowerUpGrab:load length of power-up grab sound
P:82D6:ContinuePowerUpGrab:load frequency reg based on length left over
P:82D9::divide by 2
P:82DA::alter frequency every other frame
P:82DD::use length left over / 2 for frequency offset
P:82E0::store reg contents of power-up grab sound
P:82E4:LoadSqu2Regs
P:82E7:DecrementSfx2Length:decrement length of sfx
P:82EC:EmptySfx2Buffer:initialize square 2's sound effects buffer
P:82F0:StopSquare2Sfx
P:82F3:ExSfx2
P:82F4:PlayTimerTick1
P:82F7:PlayCoinGrab2
P:82FA:Square2SfxHandler
P:8304::special handling for the 1-up sound to keep it
P:8306::from being interrupted by other sounds on square 2
P:830A::check for sfx in queue
P:830E::if found, put in buffer and check for the following
P:8310::bowser fall
P:8314::coin grab
P:8318::power-up reveal
P:831C::vine grow
P:8320::fireworks/gunfire
P:8324::timer tick
P:8328::power-up grab
P:832A:CheckSfx2Buffer:lsr Square2SoundQueue\nbcs PlayExtraLife      ;1-up\ncheck for sfx in buffer
P:832C::if not found, exit sub
P:832E::bowser fall
P:8331::coin grab
P:8334::power-up reveal
P:8337::vine grow
P:833A::fireworks/gunfire
P:833D::timer tick
P:8340::power-up grab
P:8343::1-up
P:8345:ExS2H
P:8346:Cont_CGrab_TTick
P:8349:N2Tone1
P:834C:JumpToDecLength2
P:834F:PlayBowserFall:load length of bowser defeat sound
P:8354::load contents of reg for bowser defeat sound
P:8358:BlstSJp
P:835A:ContinueBowserFall:check for almost near the end
P:8361::if so, load the rest of reg contents for bowser defeat sound
P:8365:PBFRegs:the fireworks/gunfire sound shares part of reg contents here
P:8367:EL_LRegs:this is an unconditional branch outta here
P:836A:PlayExtraLife:load length of 1-up sound
P:836F:ContinueExtraLife
P:8372::load new tones only every eight frames
P:8374:DivLLoop
P:8375::if any bits set here, branch to dec the length
P:8378::do this until all bits checked, if none set, continue
P:837B::load our reg contents
P:8382::unconditional branch
P:8384:PlayGrowPowerUp:load length of power-up reveal sound
P:8388:PlayGrowVine:load length of vine grow sound
P:838A:GrowItemRegs
P:838D::load contents of reg for both sounds directly
P:8392::start secondary counter for both sounds
P:8397:ContinueGrowItems:increment secondary counter for both sounds
P:839A::this sound doesn't decrement the usual counter
P:839D::divide by 2 to get the offset
P:839F::have we reached the end yet?
P:83A2::if so, branch to jump, and stop playing sounds
P:83A4::load contents of other reg directly
P:83A9::use secondary counter / 2 as offset for frequency regs
P:83AF:StopGrowItems:branch to stop playing sounds
P:83B2:BrickShatterFreqData:--------------------------------
P:83C2:SkidSfxFreqData
P:83C8:PlaySkidSfx
P:83CF:ContinueSkidSfx
P:83E3:PlayBrickShatter
P:83E5::load length of brick shatter sound
P:83EA:ContinueBrickShatter
P:83ED::divide by 2 and check for bit set to use offset
P:83F1::load reg contents of brick shatter sound
P:83F7:PlayNoiseSfx:play the sfx
P:8402:DecrementSfx3Length:decrement length of sfx
P:8407::if done, stop playing the sfx
P:8415:ExSfx3
P:8416:NoiseSfxHandler
P:842C::lsr\nbcs ContinueWindSfx\nlsr NoiseSoundQueue\nbcs PlayWindSfx
P:842D:CheckNoiseBuffer:check for sfx in queue\nif found, put in buffer\nbrick shatter\nbowser flame\ncheck for sfx in buffer
P:842F::if not found, exit sub
P:8432::brick shatter
P:8435::bowser flame
P:8437:ExNH
P:8438:PlayBowserFlame
P:843A::load length of bowser flame sound
P:843F:ContinueBowserFlame
P:8444::load reg contents of bowser flame sound
P:8449::unconditional branch here
P:844B:ContinueMusic:--------------------------------\nif we have music, start with square 2 channel
P:844E:MusicHandler:check event music queue
P:8452::check area music queue
P:8466::check both buffers
P:846F::no music, then leave
P:8470:LoadEventMusic:copy event music queue contents to buffer
P:8473::is it death music?
P:8475::if not, jump elsewhere
P:8477::stop sfx in square 1 and 2
P:847A::but clear only square 1's sfx buffer
P:847D:NoStopSfx
P:847F::save current area music buffer to be re-obtained later
P:8484::default value for additional length byte offset
P:8487::clear area music buffer
P:8489::is it time running out music?
P:848D::load offset to be added to length byte of header
P:8492::unconditional branch
P:8494:LoadAreaMusic:is it underground music?
P:8496::no, do not stop square 1 sfx
P:849B:NoStop1:start counter used only by ground level music
P:849D:GMLoopB
P:84A0:HandleAreaMusicLoopB:clear event music buffer
P:84A5::copy area music queue contents to buffer
P:84B2::is it ground level music?
P:84B6::increment but only if playing ground level music
P:84B9::is it time to loopback ground level music?
P:84BE::branch ahead with alternate offset
P:84C2::unconditional branch
P:84C4:FindAreaMusicHeader:load Y for offset of area music
P:84C6::residual instruction here
P:84C8:FindEventMusicHeader:increment Y pointer based on previously loaded queue contents
P:84C9::bit shift and increment until we find a set bit for music
P:84CC:LoadHeader:load offset for header
P:84D0::now load the header
P:84F2::initialize music note counters
P:8500::initialize music data offset for square 2
P:8504::initialize alternate control reg data used by square 1
P:8507::disable triangle channel and reenable it
P:851D:HandleSquare2Music:decrement square 2 note length
P:8520::is it time for more data?  if not, branch to end tasks
P:8522::increment square 2 music offset and fetch data
P:8528::if zero, the data is a null terminator
P:852A::if non-negative, data is a note
P:852C::otherwise it is length data
P:852E:EndOfMusicData:check secondary buffer for time running out music
P:8535::load previously saved contents of primary buffer
P:8538::and start playing the song again if there is one
P:853A:NotTRO:check for victory music (the only secondary that loops)
P:853E::check primary buffer for any music except pipe intro
P:8542::if any area music except pipe intro, music loops
P:8544::clear primary and secondary buffers and initialize
P:8546::control regs of square and triangle channels
P:8557:MusicLoopBack
P:855A:VictoryMLoopBack
P:855D:Rest:lda Squ2_EnvelopeDataCtrl
P:8560:Squ2LengthHandler:store length of note
P:8566::fetch another byte (MUST NOT BE LENGTH BYTE!)
P:856C:Squ2NoteHandler:is there a sound playing on this channel?
P:8570::no, then play the note
P:8573::check to see if note is rest
P:8575::if not, load control regs for square 2
P:8578::save contents of A
P:857B::dump X and Y into square 2 control regs
P:857E:SkipFqL1:save length in square 2 note counter
P:8584:MiscSqu2MusicTasks:is there a sound playing on square 2?
P:8588::check for death music or d4 set on secondary buffer
P:858B::note that regs for death music or d4 are loaded by default
P:858F::check for contents saved from LoadControlRegs
P:8594::decrement unless already zero
P:8597:NoDecEnv1:do a load of envelope data to replace default
P:859A::based on offset set by first load unless playing
P:859D::death music or d4 set on secondary buffer
P:85A2:HandleSquare1Music:is there a nonzero offset here?
P:85A4::if not, skip ahead to the triangle channel
P:85A6::decrement square 1 note length
P:85A9::is it time for more data?
P:85AB:FetchSqu1MusicData:increment square 1 music offset and fetch data
P:85B1::if nonzero, then skip this part
P:85B5::store some data into control regs for square 1
P:85B8::and fetch another byte of data, used to give
P:85BA::death music its unique sound
P:85C0::unconditional branch
P:85C2:Squ1NoteHandler
P:85C5::save contents of A in square 1 note counter
P:85C8::is there a sound playing on square 1?
P:85CD::change saved data to appropriate note format
P:85CF::play the note
P:85D7:SkipCtrlL:save envelope offset
P:85DD:MiscSqu1MusicTasks:is there a sound playing on square 1?
P:85E1::check for death music or d4 set on secondary buffer
P:85E8::check saved envelope offset
P:85ED::decrement unless already zero
P:85F0:NoDecEnv2:do a load of envelope data
P:85F3::based on offset set by first load
P:85F6:DeathMAltReg:check for alternate control reg data
P:85FB::load this value if zero, the alternate value
P:85FD:DoAltLoad:if nonzero, and let's move on
P:8600:HandleTriangleMusic
P:8602::decrement triangle note length
P:8605::is it time for more data?
P:8607::increment square 1 music offset and fetch data
P:860D::if zero, skip all this and move on to noise 
P:860F::if non-negative, data is note
P:8611::otherwise, it is length data
P:8614::save contents of A
P:8619::load some default data for triangle control reg
P:861C::fetch another byte
P:8622::check once more for nonzero data
P:8624:TriNoteHandler
P:8627::save length in triangle note counter
P:8630::check for death music or d4 set on secondary buffer
P:8632::if playing any other secondary, skip primary buffer check
P:8634::check primary buffer for water or castle level music
P:8638::if playing any other primary, or death or d4, go on to noise routine
P:863A:NotDOrD4:if playing water or castle music or any secondary
P:863B::besides death music or d4 set, check length of note
P:863F::check for win castle music again if not playing a long note
P:8646::load value $0f if playing the win castle music and playing a short
P:8648::note, load value $1f if playing water or castle level music or any
P:864A:MediN:secondary besides death and d4 except win castle or win castle and playing
P:864C::a short note, and load value $ff if playing a long note on water, castle
P:864E:LongN:or any secondary (including win castle) except death and d4
P:8650:LoadTriCtrlReg:save final contents of A into control reg for triangle
P:8653:HandleNoiseMusic:check if playing underground or castle music
P:8657::if so, skip the noise routine
P:865F::decrement noise beat length
P:8662::is it time for more data?
P:8664:FetchNoiseBeatData:increment noise beat offset and fetch data
P:866A::get noise beat data, if nonzero, branch to handle
P:866E::if data is zero, reload original noise beat offset
P:8671::and loopback next time around
P:8674::unconditional branch
P:8676:NoiseBeatHandler
P:8679::store length in noise beat counter
P:867D::reload data and erase length bits
P:867F::if no beat data, silence
P:8681::check the beat data and play the appropriate
P:8683::noise accordingly
P:868D::short beat data
P:8695:StrongBeat:strong beat data
P:869D:LongBeat:long beat data
P:86A5:SilentBeat:silence
P:86A7:PlayBeat:load beat data into noise regs
P:86B0:ExitMusicHandler
P:86B1:AlternateLengthHandler:save a copy of original byte into X
P:86B2::save LSB from original byte into carry
P:86B3::reload original byte and rotate three times
P:86B4::turning xx00000x into 00000xxx, with the
P:86B5::bit in carry as the MSB here
P:86B7:ProcessLengthData:clear all but the three LSBs
P:86BA::add offset loaded from first header byte
P:86BC::add extra if time running out music
P:86C0::load length
P:86C4:LoadControlRegs:check secondary buffer for win castle music
P:86CB::this value is only used for win castle music
P:86CD::unconditional branch
P:86CF:NotECstlM
P:86D1::check primary buffer for water music
P:86D5::this is the default value for all other music
P:86D9:WaterMus:this value is used for water music and all other event music
P:86DB:AllMus:load contents of other sound regs for square 2
P:86E0:LoadEnvelopeData:check secondary buffer for win castle music
P:86E7::load data from offset for win castle music
P:86EB:LoadUsualEnvData:check primary buffer for water music
P:86F1::load default data from offset for all other music
P:86F5:LoadWaterEventMusEnvData:load data from offset for water music and all other event music
P:86F9:_StopSquare2Sfx
P:86FD::keep only the dmc bit
P:86FF::stop playing the sfx
P:8703:: write #$d to lower nibble
P:8708:: write #$f to lower nibble
P:870C:_StopSquare1Sfx:if end of sfx reached, clear buffer
P:870E::and stop making the sfx
P:8714::keep only the dmc bit
P:8716::stop making the sfx
P:8722:MusicHeaderData:--------------------------------\nmusic header offsets\nstarts from 01 (or 00)\n01 - event music
P:8723::02
P:8724::03
P:8725::04
P:8726::05
P:8727::06
P:8728::07
P:8729::08
P:872A::09 - area music
P:872B::0a
P:872C::0b
P:872D::0c
P:872E::0d
P:872F::0e
P:8730::0f
P:8731::10
P:8732::12 - ground level music layout
P:8733::13 (13-14)
P:8735::14	(15-18)
P:8739::15	(19-1c)
P:873D::16	(1d-20)
P:8741::17	(21-22)
P:8743::18	(23-26)
P:8747::19	(27-2a)
P:874B::1a	(2b-2e)
P:874F::1b	(2f-32)
P:8753::32
P:8754:TimeRunningOutHdr:music headers\nheader format is as follows: \n1 byte - length byte offset\n2 bytes -  music data address\n1 byte - triangle data offset\n1 byte - square 1 data offset\n1 byte - noise data offset (not used by secondary music)\n01
P:8759:Star_CloudHdr:02
P:875F:EndOfLevelMusHdr:03
P:8764:ResidualHeaderData:04
P:8769:UndergroundMusHdr:05
P:876E:SilenceHdr:06
P:8772:CastleMusHdr:07
P:8777:VictoryMusHdr:08
P:877C:GameOverMusHdr:09
P:8781:WaterMusHdr:0a
P:8787:WinCastleMusHdr:0b
P:878C:GroundLevelPart1Hdr:0c
P:8792:GroundLevelPart2AHdr:0d
P:8798:GroundLevelPart2BHdr:0e
P:879E:GroundLevelPart2CHdr:0f
P:87A4:GroundLevelPart3AHdr:10
P:87AA:GroundLevelPart3BHdr:11
P:87B0:GroundLevelLeadInHdr:12
P:87B6:GroundLevelPart4AHdr:13
P:87BC:GroundLevelPart4BHdr:14
P:87C2:GroundLevelPart4CHdr:15
P:87C8:DeathMusHdr:16
P:87CE:PSwitchMusHdr:17
P:87D3:Star_CloudMData:--------------------------------\nMUSIC DATA\nsquare 2/triangle format\nd7 - length byte flag (0-note, 1-length)\nif d7 is set to 0 and d6-d0 is nonzero:\nd6-d0 - note offset in frequency look-up table (must be even)\nif d7 is set to 1:\nd6-d3 - unused\nd2-d0 - length offset in length look-up table\nvalue of $00 in square 2 data is used as null terminator, affects all sound channels\nvalue of $00 in triangle data causes routine to skip note\nsquare 1 format\nd7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)\nd5-d1 - note offset in frequency look-up table\nvalue of $00 in square 1 data is flag alternate control reg data to be loaded\nnoise format\nd7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)\nd5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)\nd3-d1 - unused\nvalue of $00 in noise data is used as null terminator, affects only noise\nall music data is organized into sections (unless otherwise stated):\nsquare 2, square 1, triangle, noise
P:881C:GroundM_P1Data
P:8837:SilenceData
P:8864:GroundM_P2AData
P:8890:GroundM_P2BData
P:88B8:GroundM_P2CData
P:88DD:GroundM_P3AData
P:88F6:GroundM_P3BData
P:890A::triangle data used by both sections of third part
P:8914:GroundMLdInData
P:8935::noise data used by lead-in and third part sections
P:8940:GroundM_P4AData
P:8966:GroundM_P4BData
P:898D:DeathMusData:death music share data with fourth part c of ground level music 
P:898F:GroundM_P4CData
P:899C::death music only
P:89AB::death music only
P:89BA::noise data used by fourth part sections
P:89BF:CastleMusData
P:8A60:GameOverMusData
P:8A8D:TimeRunOutMusData
P:8ACB:WinLevelMusData
P:8B07::unused byte
P:8B2C:UndergroundMusData:square 2 and triangle use the same data, square 1 is unused
P:8B6D:WaterMusData:noise data directly follows square 2 here unlike in other songs
P:8C6C:EndOfCastleMusData
P:8CE3:VictoryMusData
P:8D18:PSwitch:SQ2
P:8D5C::TRI  ;44
P:8D8D::SQ1  ;75
P:8DBD::af
P:8DC3:FreqRegLookupTbl
P:8E29:MusicLengthLookupTbl
P:8E59:EndOfCastleMusicEnvData
P:8E5D:AreaMusicEnvData
P:8E65:WaterEventMusEnvData
P:8E8D:BowserFlameEnvData
P:8EAD:BrickShatterEnvData
P:8EBD::include "D:\random\.disasembly w\smbdis mmc3\famitone\famitone2_asm6.asm"\ninclude "D:\random\.disasembly w\smbdis mmc3\famitone\tools\music.asm"\ninclude "D:\random\.disasembly w\smbdis mmc3\famitone\tools\sfx.asm"\n	----------------------------------------------------------------------------------------------------------------\n	ALL OF THIS CODE BELONGS TO STUDSX\n----------------------------------------------------------------------------------------------------------------\nCustomAudioInit 		EQU FamiToneInit\n	CustomAudioSfxInit 		EQU FamiToneSfxInit\n	CustomAudioSfxPlay 		EQU FamiToneSfxPlay\n	CustomAudioMusicPlay 	EQU FamiToneMusicPlay\n	CustomAudioMusicPause 	EQU FamiToneMusicPause\n	CustomAudioUpdate 		EQU FamiToneUpdate\n	SFX_CH0 EQU FT_SFX_CH0\n	SFX_CH1 EQU FT_SFX_CH1\n	SFX_CH2 EQU FT_SFX_CH2\n	SFX_CH3 EQU FT_SFX_CH3\n					;Enter music number here (Famitracker music number - 1)\n\nGroundMus        =	0\nWaterMus         =  1\nCaveMus          =  2\nCastleMus        =  3\nCloudMus         =  4\nPipeMus          =  5\nStarmanMus       =  6\nDeathMus         =  7\nGameOverMus      =  8\nPrincessMus      =  9\nCastleFinishMus  =  10\nLevelFinishMus   =  11\nHurryMus         =  12\n\nMusicLUT:\n		.db GroundMus, WaterMus, CaveMus, CastleMus, CloudMus, PipeMus, StarmanMus,	-1\n		.db DeathMus, GameOverMus, PrincessMus, CastleFinishMus, 0, LevelFinishMus, HurryMus, -1\n\nBRICK = 1		-1\nBREATH = 2		-1\nCOIN = 3		-1\nGROWPU = 4		-1\nVINE = 5		-1\nBLAST = 6		-1\nTIMER = 7		-1\nGROW = 8		-1\nEXTRALIFE = 9	-1\nBOWS_FALL = 10	-1\nBJUMP = 11		-1\nBUMP = 12		-1\nSTOMP = 13		-1\nSMACK = 14		-1\nINJURY = 15		-1\nFIREBALL = 16	-1\nFLAGPOLE = 17	-1\nSJUMP = 18		-1\nPAUSE_= 19		-1\n\n\nnoise_sfx_table:\n			.db BRICK      , SFX_CH2\n			.db BREATH     , SFX_CH2\n			.db PAUSE_	   , SFX_CH3 ;put pause here cuz i can	   \n			\nsq2_sfx_table:	           \n			.db COIN       , SFX_CH1\n			.db GROWPU     , SFX_CH1\n			.db VINE       , SFX_CH1\n			.db BLAST      , SFX_CH1\n			.db TIMER      , SFX_CH1\n			.db GROW       , SFX_CH1\n			.db EXTRALIFE  , SFX_CH3\n			.db BOWS_FALL  , SFX_CH1\n\nsq1_sfx_table:             \n			.db BJUMP      , SFX_CH0\n			.db BUMP       , SFX_CH0\n			.db STOMP      , SFX_CH0\n			.db SMACK      , SFX_CH0\n			.db INJURY     , SFX_CH0\n			.db FIREBALL   , SFX_CH0\n			.db FLAGPOLE   , SFX_CH0\n			.db SJUMP      , SFX_CH0\n		\nCustomMusicEngine:\n		lda GamePauseStatus\n		bmi +\n		and #$01\n		ora SettingsBits\n		jsr FamiToneMusicPause\n+:\n		lda EventMusicQueue\n		ora AreaMusicQueue\n		beq NoTrigger\n		lda AreaMusicQueue\n		beq +\n		sta AreaMusicBuffer\n		ldx #-1\n		-\n		inx\n		lsr\n		bcc -\n		ldy #0\n		sty AreaMusicQueue\n		+\n		lda EventMusicQueue\n		beq +\n		sta EventMusicBuffer\n		ldx #7\n		-\n		inx\n		lsr\n		bcc -\n		ldy #0\n		sty EventMusicQueue\n		+\n		lda MusicLUT,x\n		pha\n		ldx #<music_music_data\n		ldy #>music_music_data\n		lda #1\n		sta songPlaying\n		jsr CustomAudioInit\n		ldx #<sounds\n		ldy #>sounds\n		jsr CustomAudioSfxInit\n		pla\n		jsr CustomAudioMusicPlay\nNoTrigger:\n		lda Square2SoundQueue\n		beq noSQ2\n		jsr countBITS_asl\n		lda sq2_sfx_table,y\n		ldx sq2_sfx_table+1,y\n		jsr CustomAudioSfxPlay\n		lda #0\n		sta Square2SoundQueue\nnoSQ2:\n		lda Square1SoundQueue\n		beq noSQ1\n		jsr countBITS_asl\n		lda sq1_sfx_table,y\n		ldx sq1_sfx_table+1,y\n		jsr CustomAudioSfxPlay\n		lda #0\n		sta Square1SoundQueue\nnoSQ1:\n		lda NoiseSoundQueue\n		beq noNOI\n		jsr countBITS_asl\n		lda noise_sfx_table,y\n		ldx noise_sfx_table+1,y\n		jsr CustomAudioSfxPlay\n		lda #0\n		sta NoiseSoundQueue\nnoNOI:\n		jmp CustomAudioUpdate\n\ncountBITS_asl:\n			ldx #$ff\n			sec\n			-\n			inx\n			ror\n			bcc -\n			txa\n			asl\n			tay\n			rts\n			\nCustomMusicLoopCallback:\n	lda #0\n	sta songPlaying\n	lda EventMusicBuffer\n	cmp #$40\n	bne +\n	lda #0\n	sta EventMusicBuffer\n	lda AreaMusicBuffer\n	sta AreaMusicQueue\n	+\n	rts
P:BFFF:: bank 03 -- self-contained core routines\n bank identifier
P:C000:_ReadJoypads: handle management of player data\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00 - temp joypad bit
P:C00B::reset and clear strobe of joypad ports
P:C011::start with joypad 1's port
P:C015:ReadPortBits:jsr ReadPortBits\ninx                   ;increment for joypad 2's port
P:C017:PortLoop:push previous bit onto stack
P:C018::read current bit on joypad port
P:C01B::check d1 and d0 of port output
P:C01D::this is necessary on the old
P:C01E::famicom systems in japan
P:C021::read bits from stack
P:C022::rotate bit from carry flag
P:C024::count down bits left
P:C026::save controller status here always
P:C029::              pha\n              and #%00110000         ;check for select or start\n              and JoypadBitMask,x    ;if neither saved state nor current state\n              beq Save8Bits          ;have any of these two set, branch\n              pla\n              and #%11001111         ;otherwise store without select\n              sta SavedJoypadBits,x  ;or start bits and leave\n              rts\nSave8Bits:    pla\nsave with all bits in another place and leave
P:C02D:D7_Attributes:-------------------------------------------------------------------------------------
P:C046:_InitializeNameTables:reset flip-flop
P:C049::load mirror of ppu reg $2000
P:C04C::set sprites for first 4k and background for second 4k
P:C04E::clear rest of lower nybble, leave higher alone
P:C050::write contents of A to PPU register 1
P:C053::and its mirror
P:C056::set vram address to start of name table 1
P:C05B::set vram address to start of name table 2
P:C065::and then set it to name table 0
P:C067:WriteNTAddr
P:C06F::clear name table with blank tile #24
P:C075:InitNTLoop:count out exactly 768 tiles
P:C07E::now to clear the attribute table (with zero this time)
P:C081::init vram buffer 1 offset
P:C084::init vram buffer 1
P:C089:InitATLoop
P:C091::reset scroll variables
P:C097::initialize scroll registers to zero
P:C09A:DemoActionData:-------------------------------------------------------------------------------------
P:C0AF:DemoTimingData
P:C0C5:_DemoEngine:load current demo action
P:C0C8::load current action timer
P:C0CB::if timer still counting down, skip
P:C0CE::if expired, increment action, X, and
P:C0D1::set carry by default for demo over
P:C0D2::get next timer
P:C0D5::store as current timer
P:C0D8::if timer already at zero, skip
P:C0DA:DoAction:get and perform action (current or next)
P:C0E0::decrement action timer
P:C0E3::clear carry if demo still going
P:C0E4:DemoOver
P:FFFF:: bank 04 -- level decode routines\n bank identifier
P:1000D:WorldNumberOffset:load level stuff\n Subtroutines that involve level loading\n AreaParserTaskHandler\n AreaParserTasks\n AreaParserCore\n IncrementColumnPos\n RenderAreaGraphics\n ProcessAreaData\n DecodeAreaData\n AlterAreaAttributes\n GetLrgObjAttrib\n\n GetAreaDataAddrs\n
P:10016:BankLevelOffset
P:10016:W1
P:1001B:W2
P:10020:W3
P:10024:W4
P:10028:W5
P:1002C:W6
P:10030:W7
P:10035:W8
P:10039:W9
P:1003E:LoadAreaPointerR
P:1005D::replace for adc to enable
P:10062::find it and store it here
P:10068:GetAreaType:mask out all but d6 and d5\nmask out all but d6 and d5\nmake %0xx00000 into %000000xx\nsave 2 MSB as area type
P:1006C:FindAreaPointer:load offset from world variable
P:1006F::and #%00000111
P:10073::add area number used to find data
P:10078::from there we have our area pointer
P:1007C:GetAreaDataAddrsR
P:10099::use 2 MSB for Y
P:100A0::mask out all but 5 LSB
P:100A5::save as low offset
P:100A8::load base value with 2 altered MSB,
P:100AB::then add base value to 5 LSB, result
P:100AC::becomes offset for level data
P:100B0::use offset to load pointer
P:100BA:: fix the pointers to match original file\nuse area type as offset
P:100BD::do the same thing but with different base value
P:100C5::use this offset to load another pointer
P:100CF:: fix the pointers to match original file\nload first byte of header
P:100D3::save it to the stack for now
P:100D4::save 3 LSB for foreground scenery or bg color control
P:100DA::if 4 or greater, save value here as bg color control
P:100DF:StoreFore:if less, save value here as foreground scenery
P:100E2::pull byte from stack and push it back
P:100E4::save player entrance control bits
P:100E6::shift bits over to LSBs
P:100E9::save value here as player entrance control
P:100EC::pull byte again but do not push it back
P:100ED::save 2 MSB for game timer setting
P:100F0::rotate bits over to LSBs
P:100F3::save value here as game timer setting
P:100F7::load second byte of header
P:100F9::save to stack
P:100FA::mask out all but lower nybble
P:100FF::pull and push byte to copy it to A
P:10101::save 2 MSB for background scenery type
P:10104::shift bits to LSBs
P:10107::save as background scenery
P:1010E::rotate bits over to LSBs
P:10111::if set to 3, store here
P:10113::and nullify other value
P:10115::otherwise store value in other place
P:1011A:StoreStyle
P:1011D::increment area data address by 2 bytes
P:1012B:BrickQBlockMetatiles1:used by question blocks
P:1012F::these two sets are functionally identical, but look different\n, $70, $6f, $c4, $72 ;used by ground level types
P:10136::, $71, $6f, $c4, $72 ;used by other level types
P:1013D:MetatileGraphics_Low
P:10141:MetatileGraphics_High
P:10145:Palette0_MTiles:blank 00
P:10149::.db $a5, $a7, $a6, $a8 ;blank coin sprite\n.db $24, $24, $24, $24 ;blank\nblack metatile 01
P:1014D::bush left 02
P:10151::bush middle 03
P:10155::bush right 04
P:10159::mountain left 05
P:1015D::mountain left bottom/middle center 06
P:10161::mountain middle top 07
P:10165::mountain right 08
P:10169::mountain right bottom 09
P:1016D::mountain middle bottom 0a
P:10171::bridge guardrail 0b
P:10175::chain 0c
P:10179::tall tree top, top half 0d
P:1017D::short tree top 0e
P:10181::tall tree top, bottom half 0f
P:10185::warp pipe end left, points up 10
P:10189::warp pipe end right, points up 11
P:1018D::decoration pipe end left, points up 12
P:10191::decoration pipe end right, points up 13
P:10195::pipe shaft left 14
P:10199::pipe shaft right 15
P:1019D::tree ledge left edge 16
P:101A1::tree ledge middle 17
P:101A5::tree ledge right edge 18
P:101A9::mushroom left edge 19
P:101AD::mushroom middle 1a
P:101B1::mushroom right edge 1b
P:101B5::sideways pipe end top 1c
P:101B9::sideways pipe shaft top 1d
P:101BD::sideways pipe joint top 1e
P:101C1::sideways pipe end bottom 1f
P:101C5::sideways pipe shaft bottom 20
P:101C9::sideways pipe joint bottom 21
P:101CD::seaplant 22
P:101D1::blank, used on bricks or blocks that are hit 23
P:101D5::flagpole ball 24
P:101D9::flagpole shaft 25
P:101DD::vine 26
P:101E1::breakable brick w/ line 27
P:101E5::breakable brick 28
P:101E9::hidden block (1 coin) 29
P:101ED::hidden block (1-up) 2a
P:101F1::hidden block (power-up) 2b
P:101F5::decoration pipe end left, points down 2c
P:101F9::decoration pipe end right, points down 2d
P:101FD::warp pipe end left, points down 2e
P:10201::warp pipe end right, points down 2f
P:10205::hidden block (star) 30
P:10209::brick (power-up) 31
P:1020D::brick (vine) 32
P:10211::brick (star) 33
P:10215::brick (coins) 34
P:10219::brick (1-up) 35
P:1021D::sideways pipe end top 36
P:10221::sideways pipe end bottom 37
P:10225::hidden block (1 coin) 38
P:10229::hidden block (1-up) 39
P:1022D::hidden block (power-up) 3a
P:10231::hidden block (star) 3b
P:10235::brick (coin) 3c
P:10239::pipe shaft right 3d
P:1023D::sideways pipe shaft bottom 3e
P:10241:Palette1_MTiles:vertical rope 40
P:10245::horizontal rope 41
P:10249::left pulley 42
P:1024D::right pulley 43
P:10251::blank used for balance rope 44
P:10255::castle top 45
P:10259::castle window left 46
P:1025D::castle brick wall 47
P:10261::castle window right 48
P:10265::castle top w/ brick 49
P:10269::entrance top 4a
P:1026D::entrance bottom 4b
P:10271::green ledge stump 4c
P:10275::fence 4d
P:10279::tree trunk 4e
P:1027D::mushroom stump top 4f
P:10281::mushroom stump bottom 50
P:10285::breakable brick w/ line 51  
P:10289::breakable brick 52
P:1028D::breakable brick (not used) 53
P:10291::cracked rock terrain 54
P:10295::brick with line (power-up) 55
P:10299::brick with line (vine) 56
P:1029D::brick with line (star) 57
P:102A1::brick with line (coins) 58
P:102A5::brick with line (1-up) 59
P:102A9::brick (power-up) 5a
P:102AD::brick (vine) 5b
P:102B1::brick (star) 5c
P:102B5::brick (coins) 5d
P:102B9::brick (1-up) 5e
P:102BD::hidden block (1 coin) 5f
P:102C1::hidden block (1-up) 60
P:102C5::solid block (3-d block) 61
P:102C9::solid block (white wall) 62
P:102CD::bridge 63
P:102D1::bullet bill cannon barrel 64
P:102D5::bullet bill cannon top 65
P:102D9::bullet bill cannon bottom 66
P:102DD::blank used for jumpspring 67
P:102E1::half brick used for jumpspring 68
P:102E5::solid block (water level, green rock) 69
P:102E9::half brick (???) 6a
P:102ED::water pipe top 6b
P:102F1::water pipe bottom 6c
P:102F5::flag ball (residual object) 6d
P:102F9::yoquse 6e
P:102FD::hidden block (power-up) 6f
P:10301::castle stop 70
P:10305::slope 71
P:10309::p-block 72
P:1030D::hidden block (star) 73
P:10311::anticheese bumpable block 74
P:10315:Palette2_MTiles:cloud left 80
P:10319::cloud middle 81 
P:1031D::cloud right 82 
P:10321::cloud bottom left 83
P:10325::cloud bottom middle 84
P:10329::cloud bottom right 85
P:1032D::water/lava top 86
P:10331::water/lava 87
P:10335::cloud level terrain 88
P:10339::bowser's bridge 89
P:1033D::spikes 8a
P:10341::noteblock 8b
P:10345::p-switch 8c
P:10349::on off switch 8d
P:1034D::on off block 8e
P:10351::on off block (on) 8f
P:10355::water/lava top swimmable 90
P:10359::water/lava swimmable 91
P:1035D::door 92
P:10361:Palette3_MTiles:question block (coin) c0
P:10365::question block (power-up) c1
P:10369::coin c2
P:1036D::underwater coin c3
P:10371::empty block c4
P:10375::axe c5
P:10379::question block (star) c6
P:1037D::question block (1up) c7
P:10381::sideways pipe shaft top c8
P:10385::sideways pipe joint top c9
P:10389::sideways pipe shaft bottom ca
P:1038D::sideways pipe joint bottom cb
P:10391::decoration pipe end left, points up cc
P:10395::decoration pipe end right, points up cd
P:10399::pipe shaft left ce
P:1039D::pipe shaft right cf
P:103A1::decoration pipe end left, points down d0
P:103A5::decoration pipe end right, points down d1
P:103A9::w3 star d2
P:103AD::w3 star d3
P:103B1::w3 star d4
P:103B5::w3 star d5
P:103B9::w4,7 sand d6
P:103BD::pipe shaft right d7
P:103C1::sideways pipe shaft bottom d8
P:103C5::w4 palmtree 1 d9
P:103C9::w4 palmtree 2 da
P:103CD::w4 palmtree 3 db
P:103D1::sideways pipe end top dc
P:103D5::sideways pipe end bottom dd
P:103D9::w5 cloud block de
P:103DD::w5 cloud ledge left edge df
P:103E1::w5 cloud ledge middle e0
P:103E5::w5 cloud ledge right edge e1
P:103E9::w6 snow ground e2
P:103ED::w6 snow ground bottom e3
P:103F1::w6 snow ground bottom (hurts) e4
P:103F5::w6 snow ground bottom (no collision) e5
P:103F9::w7 desert sea plant e6
P:103FD::w7 tree trunk top e7
P:10401::w7 solid block (3-d block) pal0 e8
P:10405::w7 castle top pal0 e9
P:10409::w7 castle window left pal0 ea
P:1040D::w7 castle brick wall pal0 eb
P:10411::w7 castle window right pal0 ec
P:10415::w7 castle top w/ brick pal0 ed
P:10419::w7 entrance top pal0 ee
P:1041D::w7 entrance bottom pal0 ef
P:10421::w7 castle stop pal0 f0
P:10425::w7 fence pal0 f1
P:10429:AreaParserTaskHandler:-------------------------------------------------------------------------------------\nVRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM
P:1046C::check number of tasks here
P:1046F::if already set, go ahead
P:10471::ldy Player_X_Scroll\nbmi SkipATRender
P:10473::otherwise, set eight by default
P:10476:DoAPTasks
P:1047B::if all tasks not complete do not
P:1047E::render attribute table yet
P:10488:SkipATRender
P:10489:AreaParserTasks:dec AreaParserTaskNum\nlda AreaParserTaskNum\nrts
P:10489:NoThing
P:104A0:RenderAreaGraphics
P:104AA:NoSkipATRender:store LSB of where we're at
P:104B8::store vram buffer offset
P:104BD::get current name table address we're supposed to render
P:104E0:ExitDrawM1
P:104F4:@bru
P:10504::store length byte of 26 here with d7 set
P:10506::to increment by 32 (in columns)
P:10509::init attribute row
P:1050E:DrawMTLoop:store init value of 0 or incremented offset for buffer
P:10529::get first metatile number, and mask out all but 2 MSB
P:1052B::cmp #$10\nbeq ++\ncmp #$12\nbne +\npha\nlda AreaParserTaskNum        ;get current task number for level processing and\neor olddirscroll\nand #%00000001  \njmp ++\njsr FindEmptyEnemySlot   ;check for an empty moving data buffer space\n  bcs ++             ;if not found, too many enemies, thus skip\n  lda $fa\n  sub #$66\n; tay\nlda $ff\nand #$0f\nasl\nasl\nasl\nasl\nclc\nadc #$08                 ;add eight to put the piranha plant in the center\nsta Enemy_X_Position,x   ;store as enemy's horizontal coordinate\ntya\nadc #$00\nsta Enemy_PageLoc,x      ;store as enemy's page coordinate\nlda #$01\nsta Enemy_Y_HighPos,x\nsta Enemy_Flag,x         ;activate enemy flag\nlda $02  					;get piranha plant's vertical coordinate and store here\nand #$f0\nclc\nadc #$20\nsta Enemy_Y_Position,x\nlda #PiranhaPlant\nsta Enemy_ID,x\njsr InitPiranhaPlant1\nldy $02\npla
P:1052F::sta $03                      ;store attribute table bits here\nnote that metatile format is:
P:10530::%xx000000 - attribute table bits, 
P:10531::%00xxxxxx - metatile number
P:10532::rotate bits to d1-d0 and use as offset here
P:10533::get address to graphics table from here
P:1054C::get metatile number again
P:1054D::multiply by 4 and use as tile offset
P:10554::get current task number for level processing and
P:1055A::mask out all but LSB, then invert LSB, multiply by 2
P:1055C::eor #%00000001               ;to get the correct column position in the metatile,\nthen add to the tile offset so we can draw either side
P:1055D::of the metatiles
P:10560::use vram buffer offset from before as X
P:10564::get first tile number (top left or top right) and store
P:10568::now get the second (bottom left or bottom right) and store
P:1056D::get current attribute row
P:1056F::get LSB of current column where we're at, and
P:10571::branch if set (clear = left attrib, set = right)
P:10573::get current row we're rendering
P:10575::branch if LSB set (clear = top left, set = bottom left)
P:10578::rotate attribute bits 3 to the left
P:1057A::thus in d1-d0, for upper left square
P:10581:RightCheck:get LSB of current row we're rendering
P:10583::branch if set (clear = top right, set = bottom right)
P:10586::shift attribute bits 4 to the right
P:10588::thus in d3-d2, for upper right square
P:10591:DrawMTLoop1
P:10594:LLeft:shift attribute bits 2 to the right
P:10596::thus in d5-d4 for lower left square
P:10598:NextMTRow:move onto next attribute row  
P:1059A:SetAttrib:get previously saved bits from before
P:1059D::if any, and put new bits, if any, onto
P:1059F::the old, and store
P:105A2::increment vram buffer offset by 2
P:105A6::get current gfx buffer row, and check for
P:105A8::the bottom of the screen
P:105AB::if not there yet, loop back
P:105AD::get current vram buffer offset, increment by 3
P:105AF::(for name table address and length bytes)
P:105B4::put null terminator at end of data for name table
P:105B7::store new buffer offset
P:105CF::increment name table address low
P:105D2::check current low byte
P:105D5::if no wraparound, just skip this part
P:105D9::if wraparound occurs, make sure low byte stays
P:105DB::just under the status bar
P:105DE::and then invert d2 of the name table address high
P:105E1::to move onto the next appropriate name table
P:105E6:ExitDrawM:jump to set buffer to $0341 and leave
P:105E9:RenderAttributeTables:-------------------------------------------------------------------------------------\n$00 - temp attribute table address high (big endian order this time!)\n$01 - temp attribute table address low\nget low byte of next name table address
P:105EC::to be written to, mask out all but 5 LSB,
P:105F6::subtract four 
P:105F9::mask out bits again and store
P:105FD::get high byte and branch if borrow not set
P:10602::otherwise invert d2
P:10604:SetATHigh:mask out all other bits
P:10606::add $2300 to the high byte and store
P:1060A::get low byte - 4, divide by 4, add offset for
P:1060C::attribute table and store
P:1060E::we should now have the appropriate block of
P:10610::attribute table in our temp address
P:10614::get buffer offset
P:10617:AttribLoop
P:10619::store high byte of attribute table address
P:1061E::get low byte, add 8 because we want to start
P:1061F::below the status bar, and store
P:10624::also store in temp again
P:10626::fetch current attribute table byte and store
P:10629::in the buffer
P:1062E::store length of 1 in buffer
P:10632::clear current byte in attribute buffer
P:10635::increment buffer offset by 4 bytes
P:10639::increment attribute offset and check to see
P:1063A::if we're at the end yet
P:1063E::put null terminator at the end
P:10641::store offset in case we want to do any more
P:10644:SetVRAMCtrl
P:10646::set buffer to $0341 and leave
P:1064A::-------------------------------------------------------------------------------------
P:10668:IncrementColumnPosS:increment column where we're at
P:1066E::mask out higher nybble
P:10672::if no bits left set, wrap back to zero (0-f)
P:10675::and increment page number where we're at
P:10678::increment column offset where we're at
P:1067C:IncrementColumnPos
P:10699:oke1
P:106B4::inc CurrentColumnPos\nlda temp9\nbne +
P:106D3:DecrementColumnPos:inc ColumnSets\ndec CurrentNTAddr_Low
P:106E0::cmp #$00
P:106E7:oke
P:106F1:eadoek
P:10704::cmp #$00
P:10706:aeujh
P:1070D::increment column where we're at
P:10720:BSceneDataOffsets:-------------------------------------------------------------------------------------\n$00 - used as counter, store for low nybble for background, ceiling byte for terrain\n$01 - used to store floor byte for terrain\n$07 - used to store terrain metatile\n$06-$07 - used to store block buffer address
P:10720:BackSceneryData
P:10720:BackSceneryMetatiles
P:10720:FSceneDataOffsets
P:10720:ForeSceneryData
P:10720:TerrainMetatiles
P:10720:TerrainRenderBits
P:1072A:AreaParserCore
P:1073B:AreaParserCoreS
P:10741::check to see if we are starting right of start
P:10744::if not, go ahead and render background, foreground and terrain
P:10746::otherwise skip ahead and load level data
P:10749:RenderSceneryTerrain
P:1074C:BlockBuffLowBounds:		  ldx #$0c\n          lda #$00\nClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer\n          dex\n          bpl ClrMTBuf\n          ldy BackgroundScenery      ;do we need to render the background scenery?\n          beq RendFore               ;if not, skip to check the foreground\n          lda CurrentPageLoc         ;otherwise check for every third page\nThirdP:   cmp #$03\n          bmi RendBack               ;if less than three we're there\n          sec\n          sbc #$03                   ;if 3 or more, subtract 3 and \n          bpl ThirdP                 ;do an unconditional branch\nRendBack: asl                        ;move results to higher nybble\n          asl\n          asl\n          asl\n          adc BSceneDataOffsets-1,y  ;add to it offset loaded from here\n          adc CurrentColumnPos       ;add to the result our current column position\n          tax\n          lda BackSceneryData,x      ;load data from sum of offsets\n          beq RendFore               ;if zero, no scenery for that part\n          pha\n          and #$0f                   ;save to stack and clear high nybble\n          sec\n          sbc #$01                   ;subtract one (because low nybble is $01-$0c)\n          sta $00                    ;save low nybble\n          asl                        ;multiply by three (shift to left and add result to old one)\n          adc $00                    ;note that since d7 was nulled, the carry flag is always clear\n          tax                        ;save as offset for background scenery metatile data\n          pla                        ;get high nybble from stack, move low\n          lsr\n          lsr\n          lsr\n          lsr\n          tay                        ;use as second offset (used to determine height)\n          lda #$03                   ;use previously saved memory location for counter\n          sta $00\nSceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3\n		  ;lda #$71\n          sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)\n          inx\n          iny\n          cpy #$0b                   ;if at this location, leave loop\n          beq RendFore\n          dec $00                    ;decrement until counter expires, barring exception\n          bne SceLoop1\nRendFore: ldx ForegroundScenery      ;check for foreground data needed or not\n          beq RendTerr               ;if not, skip this part\n          ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then\n          ldx #$00                   ;reinit X\nSceLoop2: lda ForeSceneryData,y      ;load data until counter expires\n          beq NoFore                 ;do not store if zero found\n          sta MetatileBuffer,x\nNoFore:   iny\n          inx\n          cpx #$0d                   ;store up to end of metatile buffer\n          bne SceLoop2\nRendTerr: ldy AreaType               ;check world type for water level\n          bne TerMTile               ;if not water level, skip this part\n          lda WorldNumber            ;check world number, if not world number eight\n          cmp #FinalWorld            ;then skip this part\n          bne TerMTile\n          lda #$6e                   ;if set as water level and world number eight,\n          jmp StoreMT                ;use castle wall metatile as terrain type\nTerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type\n          ldy CloudTypeOverride      ;check for cloud type override\n          beq StoreMT                ;if not set, keep value otherwise\n          lda #$88                   ;use cloud block terrain\nStoreMT:  sta $07                    ;store value here\n          ldx #$00                   ;initialize X, use as metatile buffer offset\n          lda TerrainControl         ;use yet another value from the header\n          asl                        ;multiply by 2 and use as yet another offset\n          tay\nTerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data\n          sta $00\n          iny                        ;increment Y and use as offset next time around\n          sty $01\n          lda CloudTypeOverride      ;skip if value here is zero\n          beq NoCloud2\n          cpx #$00                   ;otherwise, check if we're doing the ceiling byte\n          beq NoCloud2\n          lda $00                    ;if not, mask out all but d3\n          and #%00001000\n          sta $00\nNoCloud2: ldy #$00                   ;start at beginning of bitmasks\nTerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte\n          bit $00\n          beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)\n          lda $07\n          sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here\nNextTBit: inx                        ;continue until end of buffer\n          cpx #$0d\n          beq RendBBuf               ;if we're at the end, break out of this loop\n          lda AreaType               ;check world type for underground area\n          cmp #$02\n          bne EndUChk                ;if not underground, skip this part\n          cpx #$0b\n          bne EndUChk                ;if we're at the bottom of the screen, override\n          lda #$54                   ;old terrain type with ground level terrain type\n          sta $07\nEndUChk:  iny                        ;increment bitmasks offset in Y\n          cpy #$08\n          bne TerrBChk               ;if not all bits checked, loop back    \n          ldy $01\n          bne TerrLoop               ;unconditional branch, use Y to load next byte\nRendBBuf: jsr ProcessAreaData        ;do the area data loading routine now\n		  ldx #$00\n          ldy #$00                   ;init index regs and start at beginning of smaller buffer\nChkMTLow: sty $00\n          ;lda MetatileBuffer,x       ;load stored metatile number\n          ;and #%11000000             ;mask out all but 2 MSB\n          ;asl\n          ;rol                        ;make %xx000000 into %000000xx\n          ;rol\n		  ;tay\n		  rts\n          ldy MetatileBuffer,x       ;reload original unmasked value here\n		  lda MetatileThingy1,y\n		  bne +++\n		  ;lda #$c2\n		  ;bne ++++\n+++:	  lda MetatileBuffer,x\n++++:	  ldy $00                    ;get offset for block buffer\n		  sta ($fb),y                ;store value into block buffer\n+:        tya\n          clc                        ;add 16 (move down one row) to offset\n          adc #$10\n          tay\n          inx                        ;increment column value\n          cpx #$0d\n          bcc ChkMTLow               ;continue until we pass last row, then leave\n++:       rts\nnumbers lower than these with the same attribute bits\nwill not be stored in the block buffer\n.db $10, $51, $88, $c0\n-------------------------------------------------------------------------------------\n$00 - used to store area object identifier\n$07 - used as adder to find proper area object code
P:1074C:RdyDecode1
P:1074D:LevelBanks
P:1075F:ProcessAreaData
P:1078C:EndAParse
P:1078D:BehindAreaIncrement:jmp ProcessAreaData \ndo things to get correct offset
P:1078D:ProcessAreaData2
P:107B4::reset page select
P:107BD::reset page select
P:107C3:D3Bytes:inc AreaDataOffset\ninc AreaDataOffset
P:107C3:D4Bytes
P:107C3:IncAreaObjOffset
P:107C9::reset page select
P:107CE:XD
P:107D3:StarTable
P:107D7:DecodeAreaData
P:1084F::run the object!
P:10852:StopFrenzy:s: scenery\nb: background\nj: change only background flag\n-------------------------------------------------------------------------------------\n(these apply to all area object subroutines in this section unless otherwise stated)\n$00 - used to store offset used to find object code\n$07 - starts with adder from area parser, used to store row offset
P:1085A:AlterAreaAttributes:load offset for level object data saved in buffer
P:1085D::load second byte
P:10860::save in stack for now
P:10863::branch if d6 is set
P:10866::pull and push offset to copy to A
P:10867::mask out high nybble and store as
P:10869::new terrain height type bits
P:1086D::pull and mask out all but d5 and d4
P:1086F::move bits to lower nybble and store
P:10870::as new background scenery bits
P:10873::then leave
P:10877:Alter2
P:10878::mask out all but 3 LSB
P:1087A::if four or greater, set color control bits
P:1087C::and nullify foreground scenery bits
P:10883:SetFore:otherwise set new foreground scenery bits
P:10887:ScrollLockObject_Warp:--------------------------------
P:108AB:ScrollLockObject
P:108C9:FrenzyIDData:--------------------------------\n$00 - used to store enemy identifier in KillEnemies\n--------------------------------
P:108CC:AreaFrenzy:use area object identifier bit as offset
P:108CE::note that it starts at 8, thus weird address here
P:108D3:FreCompLoop:check regular slots of enemy object buffer
P:108D4::if all slots checked and enemy object not found, branch to store
P:108D6::check for enemy object in buffer versus frenzy object
P:108DB::if enemy object already present, nullify queue and leave
P:108DD:ExitAFrenzy:store enemy into frenzy queue
P:108E1:AreaStyleObject:--------------------------------\n$06 - used by MushroomLedge to store length\nload level object style and jump to the right sub
P:108E7::also used for cloud type levels
P:108ED:TreeLedge:get row and length of green ledge
P:108F0::check length counter for expiration
P:108F8::store lower nybble into buffer flag as length of ledge
P:108FE::are we at the start of the level?
P:10903::render start of tree ledge
P:10908:MidTreeL
P:1090A::render middle of tree ledge
P:1090C::note that this is also used if ledge position is
P:1090F::at the start of level for continuous effect
P:10911::now render the part underneath
P:10914:EndTreeL:render end of tree ledge
P:10919:MushroomLedge:get shroom dimensions
P:1091C::store length here for now
P:10920::divide length by 2 and store elsewhere
P:10927::render start of mushroom
P:1092C:EndMushL:if at the end, render end of mushroom
P:10933::get divided length and store where length
P:10936::was stored originally
P:1093C::render middle of mushroom
P:1093F::are we smack dab in the center?
P:10941::if not, branch to leave
P:10946::render stem top of mushroom underneath the middle
P:1094B:AllUnder
P:1094C::set $0f to render all way down
P:1094E::now render the stem of mushroom
P:10951:NoUnder:load row of ledge
P:10953::set 0 for no bottom on this part
P:10958:PulleyRopeMetatiles:--------------------------------\ntiles used by pulleys and rope object
P:1095B:PulleyRopeObject:get length of pulley/rope object
P:1095E::initialize metatile offset
P:10960::if starting, render left pulley
P:10963::if not at the end, render rope
P:10968::otherwise render right pulley
P:10969:RenderPul
P:1096C::render at the top of the screen
P:1096F:MushLExit:and leave
P:10970:CastleMetatiles:--------------------------------\n$06 - used to store upper limit of rows for CastleObject
P:109A7:CastleObject:save lower nybble as starting row
P:109AA::if starting row is above $0a, game will crash!!! ok bummer
P:109B6::load length of castle if not already loaded
P:109BA::save obj buffer offset to stack
P:109BB::use current length as offset for castle data
P:109BE::begin at starting row
P:109C2::load upper limit of number of rows to print
P:109C4:CRendLoop:load current byte using offset
P:109CA::store in buffer and increment buffer offset
P:109CD::have we reached upper limit yet?
P:109CF::if not, increment column-wise
P:109D0::to byte in next row
P:109D4::move closer to upper limit
P:109D6:ChkCFloor:have we reached the row just before floor?
P:109D8::if not, go back and do another row
P:109DB::get obj buffer offset from before
P:109DF::if we're at page 0, we do not need to do anything else
P:109E1::check length
P:109E4::if length almost about to expire, put brick at floor
P:109E8::check starting row for tall castle ($00)
P:109EC::if found, then check to see if we're at the second column
P:109F0:NotTall:if not tall castle, check to see if we're at the third column
P:109F2::if we aren't and the castle is tall, don't create flag yet
P:109F5:PlayerStop:put brick at floor to stop player at end of level
P:109F7::this is only done if we're on the second column
P:109FA:ExitCastle
P:109FB:WaterPipe:--------------------------------\nget row and lower nybble
P:109FE::get length (residual code, water pipe is 1 col thick)
P:10A01::get row
P:10A05::draw something here and below it
P:10A0E:IntroPipe:--------------------------------\n$05 - used to store length of vertical shaft in RenderSidewaysPipe\n$06 - used to store leftover horizontal length in RenderSidewaysPipe\n and vertical length in VerticalPipe and GetPipeHeight\ncheck if length set, if not set, set it
P:10A13::set fixed value and render the sideways part
P:10A18::if carry flag set, not time to draw vertical pipe part
P:10A1A::blank everything above the vertical pipe part
P:10A1C:VPipeSectLoop:all the way to the top of the screen
P:10A1E::because otherwise it will look like exit pipe
P:10A24::draw the end of the vertical pipe part
P:10A2A:NoBlankP
P:10A2B:SidePipeShaftData:used to control whether or not vertical pipe shaft
P:10A2D::is drawn, and if so, controls the metatile number
P:10A2F:SidePipeTopPart:top part of sideways part of pipe
P:10A33:SidePipeBottomPart:bottom part of sideways part of pipe
P:10A37:SidePipeBottomPartW:bottom part of sideways part of pipe
P:10A3B:ExitPipe:check if length set, if not set, set it
P:10A40::get vertical length, then plow on through RenderSidewaysPipe
P:10A43:RenderSidewaysPipe:decrement twice to make room for shaft at bottom
P:10A44::and store here for now as vertical length
P:10A47::get length left over and store here
P:10A4C::get vertical length plus one, use as buffer offset
P:10A4F::check for value $00 based on horizontal offset
P:10A52::cmp #$00\nif found, do not draw the vertical pipe shaft
P:10A56::init buffer offset and get vertical length
P:10A58::and render vertical shaft using tile number in A
P:10A5B::clear carry flag to be used by IntroPipe
P:10A5C:DrawSidePart:render side pipe part at the bottom
P:10A61::note that the pipe parts are stored
P:10A70::backwards horizontally
P:10A77:VerticalPipeData:used by pipes that lead somewhere
P:10A7B::used by decoration pipes
P:10A7F::used by upside-down pipes
P:10A81::used by upside-down pipes (enterable)
P:10A83:VerticalPipeDataUW:used by pipes that lead somewhere
P:10A87::used by decoration pipes
P:10A8B::used by upside-down pipes
P:10A8D::used by upside-down pipes (enterable)
P:10A8F:VerticalPipe
P:10A99::check to see if value was nullified earlier
P:10A9B::(if d3, the usage control bit of second byte, was set)
P:10AA0::add four if usage control bit was not set
P:10AA1:WarpPipe:save value in stack
P:10AA6::if at world 1-1, do not add piranha plant ever
P:10AAB::lda AreaType\nbeq DrawPipe
P:10AB0::if on second column of pipe, branch
P:10AB3::(because we only need to do this once)
P:10AB5::check for an empty moving data buffer space
P:10AB8::if not found, too many enemies, thus skip
P:10ABA::get horizontal pixel coordinate
P:10ABE::add eight to put the piranha plant in the center
P:10AC0::store as enemy's horizontal coordinate
P:10AC2::add carry to current page number
P:10AC7::store as enemy's page coordinate
P:10ACD::activate enemy flag
P:10ACF::get piranha plant's vertical coordinate and store here
P:10AD4::write piranha plant's value into buffer
P:10ADB:DrawPipe:get value saved earlier and use as Y
P:10ADD::get buffer offset
P:10ADF::draw the appropriate pipe with the Y we loaded earlier
P:10AE2::render the top of the pipe
P:10AE6::render the rest of the pipe
P:10AE9::subtract one from length and render the part underneath
P:10AEF:VerticalPipeUW
P:10AF3::check to see if value was nullified earlier
P:10AF5::(if d3, the usage control bit of second byte, was set)
P:10AFA::add four if usage control bit was not set
P:10AFB:WarpPip1:save value in stack
P:10B00::if at world 1-1, do not add piranha plant ever
P:10B05::lda AreaType\nbeq DrawPipe
P:10B0A::if on second column of pipe, branch
P:10B0D::(because we only need to do this once)
P:10B0F::check for an empty moving data buffer space
P:10B12::if not found, too many enemies, thus skip
P:10B14::get horizontal pixel coordinate
P:10B18::add eight to put the piranha plant in the center
P:10B1A::store as enemy's horizontal coordinate
P:10B1C::add carry to current page number
P:10B21::store as enemy's page coordinate
P:10B27::activate enemy flag
P:10B29::get piranha plant's vertical coordinate and store here
P:10B2E::write piranha plant's value into buffer
P:10B35:DrawPip1:get value saved earlier and use as Y
P:10B37::get buffer offset
P:10B39::draw the appropriate pipe with the Y we loaded earlier
P:10B3C::render the top of the pipe
P:10B40::render the rest of the pipe
P:10B43::subtract one from length and render the part underneath
P:10B49:GetPipeHeight:check for length loaded, if not, load
P:10B4B::pipe length of 2 (horizontal)
P:10B51::get saved lower nybble as height
P:10B52::save only the three lower bits as
P:10B54::vertical length, then load Y with
P:10B56::length left over
P:10B5A:UpsideDownWarpPipe
P:10B67:UpsideDownPipe
P:10B77::get pipe height from object byte
P:10B7B::save buffer offset temporarily
P:10B80::save pipe height temporarily
P:10B84::if at world 1-1, do not add piranha plant ever
P:10B89:NoUDP:lda AreaType\nbeq NoUDP
P:10B8A::return tile offset
P:10B91::render the pipe shaft
P:10B9E::and render the pipe end
P:10BA5::and render the pipe end
P:10BAC:UpsideDownWarpPipeUW
P:10BB4:UpsideDownPipeUW
P:10BBF::get pipe height from object byte
P:10BC3::save buffer offset temporarily
P:10BC8::save pipe height temporarily
P:10BCC::if at world 1-1, do not add piranha plant ever
P:10BD1::lda AreaType\nbeq NoUDP\nif on second column of pipe, skip this
P:10BD6::otherwise try to insert upside-down
P:10BD9::piranha plant, if no empty slots, skip this
P:10BDB::set up upside-down piranha plant
P:10BE1::multiply height of pipe by 16
P:10BE2::and add enemy Y position previously set up
P:10BE3::then subtract 10 pixels, save as new Y position
P:10BEC::set as "down" position
P:10BEF::add 24 pixels, save as "up" position
P:10BF0::note up and down here are reversed
P:10BF5::set movement flag
P:10BF7:NoUD1
P:10BF8::return tile offset
P:10BFF::render the pipe shaft
P:10C0C::and render the pipe end
P:10C13::and render the pipe end
P:10C1A:FindEmptyEnemySlot:start at first enemy slot
P:10C1C:EmptyChkLoop:clear carry flag by default
P:10C1D::check enemy buffer for nonzero
P:10C1F::if zero, leave
P:10C22::if nonzero, check next value
P:10C26:ExitEmptyChk:if all values nonzero, carry flag is set
P:10C27:SetupPiranhaPlant
P:10C2B::get horizontal pixel coordinate
P:10C2F::add eight to put the piranha plant in the center
P:10C31::store as enemy's horizontal coordinate
P:10C33::add carry to current page number
P:10C38::store as enemy's page coordinate
P:10C3E::activate enemy flag
P:10C40::get piranha plant's vertical coordinate and store here
P:10C48:Hole_Water:--------------------------------\nget low nybble and save as length
P:10C52::now render the water underneath
P:10C59:QuestionBlockRow_High:--------------------------------\nstart on the fourth row
P:10C5B::BIT instruction opcode
P:10C5C:QuestionBlockRow_Low:start on the eighth row
P:10C5E::save whatever row to the stack for now
P:10C5F::get low nybble and save as length
P:10C63::render question boxes with coins
P:10C6A:Bridge_High:--------------------------------\nstart on the seventh row from top of screen
P:10C6C::BIT instruction opcode
P:10C6D:Bridge_Middle:start on the eighth row
P:10C6F::BIT instruction opcode
P:10C70:Bridge_Low:start on the tenth row
P:10C72::save whatever row to the stack for now
P:10C73::get low nybble and save as length
P:10C77::render bridge railing
P:10C7E::now render the bridge itself
P:10C85:FlagpoleObject:--------------------------------\nVine:\n	  jsr GetLrgObjAttrib  ;get low nybble from object byte\n      lda ExtendedLength,x   ;render flag balls on third row from top\n	  tax\n      lda #$26             ;of screen downwards based on low nybble\n     jmp RenderUnderPart\n--------------------------------\nrender flagpole ball on top
P:10C8A::now render the flagpole shaft
P:10C93::render solid block at the bottom
P:10C9C::apparently this sometimes refuses to work correctly lmao
P:10CA8:EndlessRope:--------------------------------\nrender rope from the top to the bottom of screen
P:10CAF:BalancePlatRope:save object buffer offset for now
P:10CB1::blank out all from second row to the bottom
P:10CB3::with blank used for balance platform rope
P:10CBA::get back object buffer offset
P:10CBC::get vertical length from lower nybble
P:10CC1:DrawRope:render the actual rope
P:10CC6:RowOfCoins:--------------------------------\nget area type
P:10CC9::load appropriate coin metatile
P:10CCE:C_ObjectRow:--------------------------------
P:10CD1:C_ObjectMetatile
P:10CD4:CastleBridgeObj:load length of 13 columns
P:10CDC:AxeObj:load bowser's palette into sprite portion of palette
P:10CE1:ChainObj:get value loaded earlier from decoder
P:10CE3::get appropriate row and metatile for object
P:10CEC:EmptyBlock:get row location
P:10CF3:ColObj:column length of 1
P:10CF8:SolidBlockMetatiles:--------------------------------
P:10CFC:BrickMetatiles
P:10D00::used only by row of bricks object
P:10D01:CustomMTObject
P:10D0D::get row number, load length
P:10D25:SidewayPipeShaft
P:10D2B::lda AreaType\nbne +
P:10D30:WaterXD
P:10D3C:SidewayPipeRight
P:10D6C::dec AreaObjectLength,x
P:10D6D:webos
P:10D71:webos2
P:10D75:SidewayPipeLeft
P:10DA5::dec AreaObjectLength,x
P:10DA6:RowOfBricks:load area type obtained from area offset pointer
P:10DA9::check for cloud type override
P:10DAE::if cloud type, override area type
P:10DB0:DrawBricks:get appropriate metatile
P:10DB3::and go render it
P:10DB6:RowOfSolidBlocks:load area type obtained from area offset pointer
P:10DB9::get metatile
P:10DBC:GetRow:store metatile here
P:10DBD::get row number, load length
P:10DC0:DrawRow
P:10DC2::set vertical height of 1
P:10DC5::render object
P:10DC8:ColumnOfBricks:ldy AreaType          ;load area type obtained from area offset\nlda BrickMetatiles,y  ;get metatile (no cloud override as for row)\njmp GetRow2
P:10DEA:ColumnOfSolidBlocks:load area type obtained from area offset
P:10DED::get metatile
P:10DF0:GetRow2:save metatile to stack for now
P:10DF1::get length and row
P:10DF4::restore metatile
P:10DF5::get starting row
P:10DF7::now render the column
P:10DFA:BulletBillCannon:--------------------------------\nget row and length of bullet bill cannon
P:10DFD::start at first row
P:10DFF::render bullet bill cannon
P:10E05::done yet?
P:10E08::if not, render middle part
P:10E0E::done yet?
P:10E11::if not, render bottom until length expires
P:10E16:SetupCannon:get offset for data used by cannons and whirlpools
P:10E19::get proper vertical coordinate for cannon
P:10E1C::and store it here
P:10E22::store page number for cannon here
P:10E25::get proper horizontal coordinate for cannon
P:10E28::and store it here
P:10E2C::increment and check offset
P:10E2E::if not yet reached sixth cannon, branch to save offset
P:10E30::otherwise initialize it
P:10E32:StrCOffset:save new offset and leave
P:10E36:StaircaseHeightData:--------------------------------
P:10E3F:StaircaseRowData
P:10E48:StaircaseObject:check and load length
P:10E4B::if length already loaded, skip init part
P:10E4D::start past the end for the bottom
P:10E4F::of the staircase
P:10E52:NextStair:move onto next step (or first if starting)
P:10E58::get starting row and height to render
P:10E5F::now render solid block staircase
P:10E64:Jumpspring:--------------------------------
P:10E6B::load third byte and store here
P:10E77:ExitJumpspring
P:10E78:QuestionBlock:--------------------------------\n$07 - used to save ID of brick object\nget value saved from area parser routine ;get value from level decoder routine
P:10E87::go to render it
P:10E8A:HiddenCoin
P:10E9E:HiddenMushRoom
P:10EB2:Hidden1UpBlock
P:10EC3:DHB
P:10EC9:QuestionBlock1Up
P:10ECE:QuestionBlockStar
P:10ED3:HiddenStar
P:10EE7:BrickWithCoins:initialize multi-coin timer flag
P:10EEF:BrickWithItem:get value saved from area parser routine         ;save area object ID
P:10EF3::load default adder for bricks with lines
P:10EF5::check level type for ground level
P:10EF9::if ground type, do not start with 5
P:10EFB::otherwise use adder for bricks without lines
P:10EFD:BWithL:add object ID to adder
P:10F00::use as offset for metatile
P:10F01:DrawQBlk:get appropriate metatile for brick (question block)
P:10F04::if branched to here from question block routine)
P:10F05::get row from location byte
P:10F08::now render the object
P:10F0B:BrickPowerUp:GetAreaObjectID:\nldy $00    ;get value saved from area parser routine\ntay        ;save to Y\nExitDecBlock: rts
P:10F0B:Bricks
P:10F0F:BrickVine
P:10F13:BrickStar
P:10F17:BrickCoins
P:10F1B:Brick1up
P:10F1F:BrickWithVine
P:10F24:BrickWithStar
P:10F29:BrickWithCoins2
P:10F2E:BrickWith1up
P:10F33:BrickWithPowerUp
P:10F37::apparently this sometimes refuses to work correctly lmao
P:10F42:HoleMetatiles:--------------------------------
P:10F46:Hole_Empty:get lower nybble and save as length
P:10F49::skip this part if length already loaded
P:10F4B::check for water type level
P:10F4E::if not water type, skip this part
P:10F55::get offset for data used by cannons and whirlpools
P:10F58::get proper vertical coordinate of where we're at
P:10F5C::subtract 16 pixels
P:10F5E::store as left extent of whirlpool
P:10F61::get page location of where we're at
P:10F64::subtract borrow
P:10F66::save as page location of whirlpool
P:10F6A::increment length by 2
P:10F6C::multiply by 16 to get size of whirlpool
P:10F6D::note that whirlpool will always be
P:10F6E::two blocks bigger than actual size of hole
P:10F6F::and extend one block beyond each edge
P:10F70::save size of whirlpool here
P:10F74::increment and check offset
P:10F76::if not yet reached fifth whirlpool, branch to save offset
P:10F78::otherwise initialize it
P:10F7A:StrWOffset:save new offset here
P:10F7D:NoWhirlP:get appropriate metatile, then
P:10F80::render the hole proper
P:10F85::start at ninth row and go to bottom, run RenderUnderPart
P:10F87:RenderUnderPart:--------------------------------\nstore vertical length to render
P:10F8A::check current spot to see if there's something
P:10F8D::we need to keep, if nothing, go ahead
P:10F91::if middle part (tree ledge), wait until next row
P:10F95::if middle part (mushroom ledge), wait until next row
P:10F99::if question block w/ coin, overwrite
P:10F9D::if any other metatile with palette 3, wait until next row
P:10FA5::if cracked rock terrain, overwrite
P:10FA9::if stem top of mushroom, wait until next row
P:10FAF:DrawThisRow:render contents of A from routine that called this
P:10FB2:WaitOneRow
P:10FB3::stop rendering if we're at the bottom of the screen
P:10FB7::decrement, and stop rendering if there is no more length
P:10FBD:ExitUPartR
P:10FBE:ChkLrgObjLength:--------------------------------\nget row location and size (length if branched to from here)
P:10FC1:ChkLrgObjFixedLength:check for set length counter
P:10FC4::clear carry flag for not just starting
P:10FC5::if counter not set, load it, otherwise leave alone
P:10FC7::save length into length counter
P:10FCB::set carry flag if just starting
P:10FCC:LenSet
P:10FCD:GetLrgObjAttrib:get offset saved from area obj decoding routine
P:10FD0::get first byte of level object
P:10FD4::save row location
P:10FD7::get next byte, save lower nybble (length or height)
P:10FD9::as Y, then leave
P:10FDD:GetAreaObjXPosition:--------------------------------\nmultiply current offset where we're at by 16
P:10FE0::to obtain horizontal pixel coordinate
P:10FE5:GetAreaObjYPosition:--------------------------------\nmultiply value by 16
P:10FE8::this will give us the proper vertical pixel coordinate
P:10FEC::add 32 pixels for the status bar
P:10FEF:WarpZoneNumbers1:-------------------------------------------------------------------------------------\n$06-$07 - used to store block buffer address used as indirect\nBlockBufferAddr:\n      .db <Block_Buffer_1, <Block_Buffer_2\n      .db >Block_Buffer_1, >Block_Buffer_2\nGetBlockBufferAddr:\n      pha                      ;take value of A, save\n     lsr                      ;move high nybble to low\n     lsr\n     lsr\n     lsr\n     tay                      ;use nybble as pointer to high byte\n    lda BlockBufferAddr+2,y  ;of indirect here\n    sta $07\n    pla\n    and #%00001111           ;pull from stack, mask out high nybble\n    clc\n    adc BlockBufferAddr,y    ;add to low byte\n    sta $06                  ;store here and leave\n    rts\n-------------------------------------------------------------------------------------\n world 1-2
P:10FF3:: warp zone responsible for minus world
P:10FF7:: world 4-2
P:10FFB:: world 4-2 to world 5
P:10FFF:HandlePipeEntry:check saved controller bits from earlier
P:11001::for pressing down
P:11003::if not pressing down, branch to leave
P:11007::check right foot metatile for warp pipe right metatile
P:11009::branch to leave if not found
P:1100D::check left foot metatile for warp pipe left metatile
P:1100F::branch to leave if not found
P:11013::set timer for change of area
P:1101D::set to run vertical pipe entry routine on next frame
P:11021::load pipedown/injury sound
P:11025::set background priority bit in player's attributes
P:11028::check warp zone control
P:1102B::branch to leave if none found
P:1102D::mask out all but 2 LSB
P:11030::multiply by four
P:11031::save as offset to warp zone numbers (starts at left pipe)
P:11032::get player's horizontal position
P:11036::if player at left, not near middle, use offset and skip ahead
P:11038::otherwise increment for middle pipe
P:1103B::if player at middle, but not too far right, use offset and skip
P:1103D::otherwise increment for last pipe
P:1103E:GetWNum:get warp zone numbers
P:11041::decrement for use as world number
P:11042::store as world number and offset
P:11045::get offset to where this world's area offsets are
P:11048::get area offset based on world offset
P:1104B::store area offset here to be used to change areas
P:11050::silence music
P:11054::initialize starting page number
P:11057::initialize area number used for area address offset
P:1105A::initialize level number used for world display
P:1105D::initialize mode of entry
P:11060::set flag for hidden 1-up blocks
P:11063::set flag to load new game timer
P:11066:ExPipeE
P:11067:HandleUpPipeEntry
P:11070::check right foot metatile for warp pipe right metatile
P:11072::branch to leave if not found
P:1107D::set timer for change of area
P:11087::set to run vertical pipe entry routine on next frame
P:1108B::load pipedown/injury sound
P:1108F::set background priority bit in player's attributes
P:11092:ExPipeU
P:1109B:ChkEnemyFrenzy:jmp ChkEnemyFrenzy\n--------------------------------
P:1109B:ProcLoopCommand
P:110AC::check for enemy object in frenzy queue
P:110AF::if not, skip this part
P:110B1::store as enemy object identifier here
P:110B5::activate enemy object flag
P:110B9::initialize state and frenzy queue
P:110BE::and then jump to deal with this enemy
P:110C1:ProcessEnemyData:--------------------------------\n$06 - used to hold page location of extended right boundary\n$07 - used to hold high nybble of position of extended right boundary
P:110CB::get offset of enemy object data
P:110CE::load first byte
P:110D0::check for EOD terminator
P:110D4::if found, jump to check frenzy buffer, otherwise
P:110D7:CheckEndofBuffer:check for special row $0e
P:110DB::if found, branch, otherwise
P:110DD::check for end of buffer
P:110DF::if not at end of buffer, branch
P:110E1::get identifier back and use as offset for jump engine
P:110E2::check for specific value here
P:110E4::not sure what this was intended for, exactly
P:110E6::this part is quite possibly residual code
P:110E8::but it has the effect of keeping enemies out of
P:110EE::the sixth slot
P:110EF:CheckRightBounds:add 48 to pixel coordinate of right boundary
P:110F5::store high nybble
P:110F9::add carry to page location of right boundary
P:110FE::store page location + carry
P:11104::if MSB of enemy object is clear, branch to check for row $0f\nif MSB of enemy object is clear, branch to check for row $0f
P:11106::if page select already set, do not set again
P:1110B::otherwise, if MSB is set, set page select 
P:1110E::and increment page control
P:11111:CheckPageCtrlRow
P:11112::reread first byte
P:11116::check for special row $0f
P:11118::if not found, branch to position enemy object
P:1111A::if page select set,
P:1111D::branch without reading second byte
P:11120::otherwise, get second byte, mask out 2 MSB
P:11124::store as page control for enemy object data
P:11136::set page select for enemy object data and 
P:11139::jump back to process loop commands again
P:1113C:CheckThreeBytes2
P:1113F:ParseRow0e1
P:11142:PositionEnemyObj:store page control as page location
P:11145::for enemy object
P:11147::get first byte of enemy object
P:1114B::store column position
P:1114D::without subtracting, then subtract borrow
P:11156::check column position against right boundary
P:11159::without subtracting, then subtract borrow
P:1115B::from page location
P:1115E::if enemy object beyond or at boundary, branch
P:11162::check for special row $0e
P:11164::if found, jump elsewhere
P:11178::lda Enemy_PageLoc,x\ncmp ScreenRight_PageLoc\nbne CheckRightExtBounds
P:11179::if not found, unconditional jump
P:1117C:CheckRightExtBounds:check right boundary + 48 against
P:1117E::column position without subtracting,
P:11180::then subtract borrow from page control temp
P:11182::plus carry
P:11184::if enemy object beyond extended boundary, branch
P:11186::store value in vertical high byte
P:1118A::get first byte again
P:1118C::multiply by four to get the vertical
P:1118D::coordinate
P:11192::do one last check for special row $0e
P:11194::(necessary if branched to $c1cb)
P:11197:CheckForEnemyGroup:lda (EnemyData),y        ;get second byte of object\nand #%01000000           ;check to see if hard mode bit is set\nbeq CheckForEnemyGroup   ;if not, branch to check for group enemy objects\nlda SecondaryHardMode    ;if set, check to see if secondary hard mode flag\nbeq Inc2B2                ;is on, and if not, branch to skip this object completely\nget second byte and mask out 2 MSB
P:1119B::check for value below $37
P:1119F::if $37 or greater, check for value
P:111A1::below $3f, branch if below $3f
P:111A3:BuzzyBeetleMutate:if below $37, check for goomba
P:111A5::value ($3f or more always fails)
P:111A7::check if primary hard mode flag is set
P:111AA::and if so, change goomba to buzzy beetle
P:111AE:StrID:store enemy object number into buffer
P:111B2::set flag for enemy in buffer
P:111BC::check to see if flag is set
P:111BE::if not, leave, otherwise branch
P:111C1:Inc2B3
P:111C4:Inc2B2
P:111C7:CheckFrenzyBuffer:if enemy object stored in frenzy buffer
P:111CA::then branch ahead to store in enemy object buffer
P:111CC::otherwise check vine flag offset
P:111D1::if other value <> 1, leave
P:111D3::otherwise put vine in enemy identifier
P:111D5:StrFre
P:111DD::store contents of frenzy buffer into enemy identifier value
P:111DF:InitEnemyObject:initialize enemy state
P:111E3::jump ahead to run jump engine and subroutines
P:111E6:ExEPar
P:111E7::then leave
P:111E8:DoGroup:handle enemy group objects
P:111EB:ParseRow0e:increment Y to load third byte of object
P:111F7::skip world number check if >= world 9\nmove 3 MSB to the bottom, effectively
P:111F8::making %xxx00000 into %00000xxx
P:111FC::is it the same world number as we're on?
P:111FF::if not, do not use (this allows multiple uses
P:11201:W9Skip:of the same area, like the underground bonus areas)
P:11202::otherwise, get second byte and use as offset
P:11204::to addresses for level and enemy object data
P:11208::get third byte again, and this time mask out
P:1120A::the 3 MSB from before, save as page number to be
P:1120C::used upon entry to area, if area is entered
P:1120F:NotUse
P:11212:CheckThreeBytes:load current offset for enemy object data
P:11215::get first byte
P:11217::check for special row $0e
P:1121D:Inc3B
P:11227:Inc2B
P:11238::init page select for enemy objects
P:1123D::reload current offset in enemy buffers
P:1123F::and leave
P:11240:CheckpointEnemyID
P:1127D::add eight pixels to what will eventually be the
P:1127F::enemy object's vertical coordinate ($00-$14 only)
P:1128E::add eight pixels to what will eventually be the
P:11290::enemy object's vertical coordinate ($00-$14 only)
P:11298::check enemy object identifier for $15 or greater
P:1129A::and branch straight to the jump engine if found
P:1129C::save identifier in Y register for now
P:1129F::add eight pixels to what will eventually be the
P:112A1::enemy object's vertical coordinate ($00-$14 only)
P:112A5::set offscreen masked bit
P:112A9:InitEnemyRoutines2:jmp InitEnemyRoutines
P:112CC::cpy #Spiny\nbeq InitEnemyRoutines
P:112D4::cpy #GreyCheepCheep\nbeq InitEnemyRoutines\ncpy #RedCheepCheep\nbeq InitEnemyRoutines
P:11321::get identifier back and use as offset for jump engine
P:11322:InitEnemyRoutines
P:1132C::jump engine table for newly loaded enemy objects\n00 for objects $00-$0f
P:1132E::01
P:11330::02
P:11332::03
P:11334::04
P:11336::05
P:11338::06
P:1133A::07
P:1133C::08
P:1133E::09
P:11340::0a
P:11342::0b
P:11344::0c
P:11346::0d
P:11348::0e
P:1134A::0f
P:1134C::10 for objects $10-$1f
P:1134E::11
P:11350::12 spiny
P:11352::13
P:11354::14 flying cheep-cheeps zone
P:11356::15 bowser's fire
P:11358::16 fireworks (unstable)
P:1135A::17 bullet bills / underwater cheep-cheeps
P:1135C::18 enf frenzy
P:1135E::19	
P:11360::1a null sprite
P:11362::1b
P:11364::1c
P:11366::1d
P:11368::1e
P:1136A::1f
P:1136C::20 for objects $20-$2f
P:1136E::21 those 3 are long firebars (malfunctions)
P:11370::22
P:11372::23 
P:11374::24
P:11376::25
P:11378::26
P:1137A::27
P:1137C::28
P:1137E::29
P:11380::2a
P:11382::2b
P:11384::2c
P:11386::2d
P:11388::2e
P:1138A::2f
P:1138C::30 for objects $30-$36, flagpole flag object
P:1138E::31 star flag object
P:11390::32 jumpspring object
P:11392::33 bullet bill cannon var
P:11394::34 warp zone
P:11396::35
P:11398::36
P:1139A::37
P:1139C::38
P:1139E::39
P:113A0::3a
P:113A2::3b
P:113A4::3c
P:113A6::3d
P:113A8::3e
P:113AA::3f
P:113AC::40
P:113AE::41
P:113B0::42
P:113B2::43
P:113B4::expandablen't (crash entity)
P:113B6:InitScrollLock1
P:113B9:InitPlatformRem
P:113BF::sta Enemy_Flag,y\ndey\n	bpl -\n		rts
P:113D2:InitCannon
P:11404:InitSign:$37-$3e are gruped goombas and koopas\n$3f crashes so is a potentially free slot
P:1140B::set buffer flag
P:1140F::set bounding box size control for sign object 
P:11419:NoInitCode
P:1141A:InitScrollLock
P:11454:InitFlag
P:11463::sta Enemy_X_Position,x   ;coordinate for the flag
P:11465::page location for the flag
P:11469::subtract borrow from page location and use as
P:11470::set vertical coordinate for flag
P:11474::set initial vertical coordinate for flagpole's floatey number
P:11483::use last space in enemy object buffer
P:11486:DoSaveEnemyIntoSex
P:114D0::get identifier back and use as offset for jump engine
P:114D2:InitGoomba:--------------------------------\nset appropriate horizontal speed
P:114D5::set $09 as bounding box control, set other values
P:114D8:InitPowerUp
P:114DA::set power-up object's state
P:114DE::set buffer flag
P:114E2::set bounding box size control for power-up object
P:114E6:InitFastGoomba:--------------------------------
P:114F0:InitKoopaShell:--------------------------------\nload appropriate horizontal speed
P:114FD:InitPodoboo:--------------------------------\nset enemy position to below
P:114FF::the bottom of the screen
P:11504::set timer for enemy
P:11508::initialize enemy state, then jump to use
P:1150A::$09 as bounding box size and set other things
P:1150D:InitRetainerObj:--------------------------------\nset fixed vertical position for
P:1150F::princess/mushroom retainer object
P:11512:NormalXSpdData:--------------------------------
P:11516:InitNormalEnemy:load offset of 1 by default
P:11518::check for primary hard mode flag set
P:11526:GetESpd:get appropriate horizontal speed
P:11529:SetESpd
P:11533::store as speed for enemy object
P:1153F::branch to set bounding box control and other data
P:11548:InitRedKoopa:--------------------------------\nload appropriate horizontal speed
P:1154B::set enemy state for red koopa troopa $03
P:11550:HBroWalkingTimerData:--------------------------------
P:11552:InitHammerBro:init horizontal speed and timer used by hammer bro
P:11554::apparently to time hammer throwing
P:1155E::get secondary hard mode flag
P:11564::set value as delay for hammer bro to walk left
P:11567:NoHB:set specific value for bounding box size control
P:1156C:InitHorizFlySwimEnemy:--------------------------------\ninitialize horizontal speed
P:11571:InitBloober:--------------------------------\ninitialize horizontal speed
P:11575:SmallBBox:set specific bounding box size control
P:11577::unconditional branch
P:11579:SemiSmallBBox
P:1157D:InitRedPTroopa:--------------------------------\nload central position adder for 48 pixels down
P:1157F::set vertical coordinate into location to
P:11581::be used as original vertical coordinate
P:11584::if vertical coordinate < $80
P:11586::if => $80, load position adder for 32 pixels up
P:11588:GetCent:send central position adder to A
P:11589::add to current vertical coordinate
P:1158B::store as central vertical coordinate
P:1158D:TallBBox:set specific bounding box size control
P:1158F:SetBBox:set bounding box control here
P:11594::ldy Enemy_ID,x\ncpy #RedCheepCheep\nbeq +\ncpy #GreyCheepCheep\nbeq +
P:1159D:InitVStf:initialize vertical speed
P:1159F::and movement force
P:115A5:InitBulletBill:--------------------------------\nset moving direction for left
P:115A9::set bounding box control for $09
P:115AF:InitCheepCheep:--------------------------------\nset vertical bounding box, speed, init others
P:115B2::check one portion of LSFR
P:115B5::get d4 from it
P:115B7::save as movement flag of some sort
P:115BB::save original vertical coordinate here
P:115BF:InitLakitu:--------------------------------\ncheck to see if an enemy is already in
P:115C2::the frenzy buffer, and branch to kill lakitu if so
P:115C4:SetupLakitu:erase counter for lakitu's reappearance
P:115CC::set $03 as bounding box, set other attributes
P:115CF:KillLakitu:jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
P:115D2:PRDiffAdjustData:--------------------------------\n$01-$03 - used to hold pseudorandom difference adjusters
P:115DE:LakituSpinyTimer
P:115E0:LakituAndSpinyHandler
P:115E2::if timer here not expired, leave
P:115E7::if we are on the special use slot, leave
P:115F4::start with the last enemy slot
P:115F6:ChkLak:check all enemy slots to see
P:115F9::if lakitu is on one of them
P:115FB::if so, branch out of this loop
P:115FD::otherwise check another slot
P:115FE::loop until all slots are checked
P:11608::increment reappearance timer
P:1160E::check to see if we're up to a certain value yet
P:11610::if not, leave
P:11612::start with the last enemy slot again
P:11614:ChkNoEn:check enemy buffer flag for non-active enemy slot
P:11616::branch out of loop if found
P:11618::otherwise check next slot
P:11619::branch until all slots are checked
P:1161B::if no empty slots were found, branch to leave
P:1161D:CreateL:initialize enemy state
P:11621::create lakitu enemy object
P:11625::do a sub to set up lakitu
P:1162A::finish setting up lakitu
P:1162D:RetEOfs:get enemy object buffer offset again and leave
P:1162F:ExLSHand
P:11630:CreateSpiny:--------------------------------\nif player above a certain point, branch to leave
P:11636::if lakitu is not in normal state, branch to leave
P:1163B::store horizontal coordinates (high and low) of lakitu
P:1163E::into the coordinates of the spiny we're going to create
P:11645::put spiny within vertical screen unit
P:11649::put spiny eight pixels above where lakitu is
P:11651::get 2 LSB of LSFR and save to Y
P:11659:DifLoop:get three values and save them
P:1165C::to $01-$03
P:1165F::increment Y four bytes for each value
P:11662::decrement X for each one
P:11663::loop until all three are written
P:11665::get enemy object buffer offset
P:11667::move enemy, change direction, get value - difference
P:1166A::check player's horizontal speed
P:1166E::if moving faster than a certain amount, branch elsewhere
P:11670::otherwise save value in A to Y for now
P:11674::get one of the LSFR parts and save the 2 LSB
P:11676::branch if neither bits are set
P:11679::otherwise get two's compliment of Y
P:1167D:UsePosv:put value from A in Y back to A (they will be lost anyway)
P:1167E:SetSpSpd:set bounding box control, init attributes, lose contents of A
P:11689::set horizontal speed to zero because previous contents
P:1168B::cmp #$00                   ;of A were lost...branch here will never be taken for\nthe same reason
P:1168E::set bounding box control, init attributes
P:11693:SpinyRte:set moving direction to the right
P:11697::set vertical speed to move upwards
P:1169F::enable enemy object by setting flag
P:116A1::lda #$05
P:116A3::put spiny in egg state and leave
P:116A5:ChpChpEx
P:116A6:FirebarSpinSpdData:--------------------------------
P:116AB:FirebarSpinDirData
P:116B0:InitLongFirebar:create enemy object for long firebar
P:116B3:InitShortFirebar:initialize low byte of spin state
P:116B7::subtract $1b from enemy identifier
P:116B9::to get proper offset for firebar data
P:116BD::get spinning speed of firebar
P:116C3::get spinning direction of firebar
P:116CA::add four pixels to vertical coordinate
P:116D1::add four pixels to horizontal coordinate
P:116D8::add carry to page location
P:116DD:FlyCCXPositionData:jmp TallBBox2               ;set bounding box control (not used) and leave\n--------------------------------\n$00-$01 - used to hold pseudorandom bits
P:116ED:FlyCCXSpeedData
P:116F9:FlyCCTimerData
P:116FD:ChpChpEx2
P:116FE:InitFlyingCheepCheep:if timer here not expired yet, branch to leave
P:11703::jump to set bounding box size $09 and init other values
P:11709::set pseudorandom offset here
P:1170C::load timer with pseudorandom offset
P:11714::load Y with default value
P:11719::if secondary hard mode flag not set, do not increment Y
P:1171B::otherwise, increment Y to allow as many as four onscreen
P:1171C:MaxCC:store whatever pseudorandom bits are in Y
P:1171E::compare enemy object buffer offset with Y
P:11720::if X => Y, branch to leave
P:11725::get last two bits of LSFR, first part
P:11727::and store in two places
P:1172B::set vertical speed for cheep-cheep
P:1172F::load default value
P:11731::check player's horizontal speed
P:11733::if player not moving left or right, skip this part
P:11737::if moving to the right but not very quickly,
P:11739::do not change A
P:1173B::otherwise, multiply A by 2
P:1173C:GSeed:save to stack
P:1173E::add to last two bits of LSFR we saved earlier
P:11740::save it there
P:11745::if neither of the last two bits of second LSFR set,
P:11747::skip this part and save contents of $00
P:1174C::otherwise overwrite with lower nybble of
P:1174E::third LSFR part
P:11750:RSeed:get value from stack we saved earlier
P:11752::add to last two bits of LSFR we saved in other place
P:11754::use as pseudorandom offset here
P:11755::get horizontal speed using pseudorandom offset
P:1175A::set to move towards the right
P:1175E::if player moving left or right, branch ahead of this part
P:11762::get first LSFR or third LSFR lower nybble
P:11764::and check for d1 set
P:11767::if d1 not set, branch
P:1176B::if d1 set, change horizontal speed
P:1176D::into two's compliment, thus moving in the opposite
P:1176E::direction
P:11772::increment to move towards the left
P:11774:D2XPos1:get first LSFR or third LSFR lower nybble again
P:11777::check for d1 set again, branch again if not set
P:11779::get player's horizontal position
P:1177C::if d1 set, add value obtained from pseudorandom offset
P:1177F::and save as enemy's horizontal position
P:11781::get player's page location
P:11783::add carry and jump past this part
P:11788:D2XPos2:get player's horizontal position
P:1178B::if d1 not set, subtract value obtained from pseudorandom
P:1178E::offset and save as enemy's horizontal position
P:11790::get player's page location
P:11792::subtract borrow
P:11794:FinCCSt:save as enemy's page location
P:11798::set enemy's buffer flag
P:1179A::set enemy's high vertical byte
P:1179E::put enemy below the screen, and we are done
P:117A1:BowserPoints:--------------------------------
P:117A9:InitBowser
P:117B8::jump to create another bowser object
P:117BB::save offset of first here
P:117C3::initialize bowser's body controls
P:117C6::and bridge collapse offset
P:117CB::store original horizontal position here
P:117D0::store something here
P:117D3::and in moving direction
P:11807::otherwise, check number of pts
P:1180B::more than 9 pts?
P:1180F::if so, subtract 10 and add one to the 10s digit
P:11812::instead of showing 100 pts, A0 will show, etc.
P:11833::apparently this sometimes refuses to work correctly lmao
P:1183D::set bowser's feet timer and in enemy timer
P:11843::set default movement speed here
P:11847:Setup_Vine:--------------------------------\nload identifier for vine object
P:11849::store in buffer
P:1184D::set flag for enemy object buffer
P:11852::copy page location from previous object
P:11857::copy horizontal coordinate from previous object
P:1185C::copy vertical coordinate from previous object
P:1185E::load vine flag/offset to next available vine slot
P:11861::if set at all, don't bother to store vertical
P:11863::otherwise store vertical coordinate here
P:11866:NextVO1:store object offset to next available vine slot
P:11867::using vine flag as offset
P:1186A::increment vine flag offset
P:1186F::load vine grow sound
P:11872:DuplicateEnemyObj:start at beginning of enemy slots
P:11874:FSLoop
P:11878::increment one slot
P:11879::check enemy buffer flag for empty slot
P:1187C::if set, branch and keep checking
P:1187E::otherwise set offset here
P:11881::transfer original enemy buffer offset
P:11882::store with d7 set as flag in new enemy
P:11884::slot as well as enemy offset
P:11889::copy page location and horizontal coordinates
P:1188C::from original enemy to new enemy
P:11893::set flag as normal for original enemy
P:11895::set high vertical byte for new enemy
P:1189A::copy vertical coordinate from original to new
P:1189D:FlmEx:and then leave
P:1189E:FlameYPosData:--------------------------------
P:118A2:FlameYMFAdderData
P:118A4:FW
P:118AA:InitBowserFlame:if timer not expired yet, branch to leave
P:118AF::reset something here
P:118B4::load bowser's flame sound into queue
P:118B8::get bowser's buffer offset
P:118BB::check for bowser
P:118C0::branch if found
P:118C2::get timer data based on flame counter
P:118C6::add 32 frames by default
P:118D2::if secondary mode flag not set, use as timer setting
P:118D5::otherwise subtract 16 frames for secondary hard mode
P:118D7:SetFrT:set timer accordingly
P:118DD::get 2 LSB from first part of LSFR
P:118DF::set here
P:118E2::use as offset
P:118E3::load vertical position based on pseudorandom offset
P:118E6:PutAtRightExtent:set vertical position
P:118EC::place enemy 32 pixels beyond right side of screen
P:118F3::add carry
P:118F7::skip this part to finish setting values
P:118FA:SpawnFromMouth:get bowser's horizontal position
P:118FE::subtract 14 pixels
P:11900::save as flame's horizontal position
P:11905::copy page location from bowser to flame
P:1190A::add 8 pixels to bowser's vertical position
P:1190D::save as flame's vertical position
P:11912::get 2 LSB from first part of LSFR
P:11914::save here
P:11917::use as offset
P:11918::get value here using bits as offset
P:1191B::load default offset
P:1191D::compare value to flame's current vertical position
P:1191F::if less, do not increment offset
P:11921::otherwise increment now
P:11922:SetMF:get value here and save
P:11925::to vertical movement force
P:1192A::clear enemy frenzy buffer
P:1192D:FinishFlame:set $08 for bounding box control
P:11932::set high byte of vertical and
P:11934::enemy buffer flag
P:11939::initialize horizontal movement force, and
P:1193C::enemy state
P:1193F:FireworksXPosData:--------------------------------
P:11945:FireworksYPosData
P:1194B:ExitFWk
P:1194C:InitFireworks:if timer not expired yet, branch to leave
P:11951::otherwise reset timer
P:11956::decrement for each explosion
P:11959::start at last slot
P:1195B:StarFChk
P:1195C::lda Enemy_ID,y               ;check for presence of star flag object\ncmp #StarFlagObject          ;if there isn't a star flag object,\nbne StarFChk                 ;routine goes into infinite loop = crash (fixed)
P:1195F::get horizontal coordinate of star flag object, then
P:11960::subtract 48 pixels from it and save to
P:11962::the stack
P:11966::subtract the carry from the page location
P:11968::of the star flag object
P:1196A::get fireworks counter
P:1196E::add state of star flag object (possibly not necessary)
P:11971::use as offset
P:11972::get saved horizontal coordinate of star flag - 48 pixels
P:11974::add number based on offset of fireworks counter
P:11977::store as the fireworks object horizontal coordinate
P:1197B::add carry and store as page location for
P:1197D::the fireworks object
P:1197F::get vertical position using same offset
P:11982::and store as vertical coordinate for fireworks object
P:11986::store in vertical high byte
P:11988::and activate enemy buffer flag
P:1198B::initialize explosion counter
P:1198F::set explosion timing counter
P:11993:Bitmasks:--------------------------------
P:1199B:Enemy17YPosData
P:119A3:SwimCC_IDData
P:119A5:BulletBillCheepCheep:if timer not expired yet, branch to leave
P:119AA::are we in a water-type level?
P:119AD::if not, branch elsewhere
P:119AF::are we past third enemy slot?
P:119B1::if so, branch to leave
P:119B3::load default offset
P:119B8::check first part of LSFR against preset value
P:119BA::if less than preset, do not increment offset
P:119BC::otherwise increment
P:119BD:ChkW2:check world number
P:119C2::if we're on world 2, do not increment offset
P:119C4::otherwise increment
P:119C5:Get17ID
P:119C6::mask out all but last bit of offset
P:119C9::load identifier for cheep-cheeps
P:119CC:Set17ID:store whatever's in A as enemy identifier
P:119D1::if not all bits set, skip init part and compare bits
P:119D5::initialize vertical position filter
P:119DA:GetRBit:get first part of LSFR
P:119DD::mask out all but 3 LSB
P:119DF:ChkRBit:use as offset
P:119E0::load bitmask
P:119E3::perform AND on filter without changing it
P:119E8::increment offset
P:119EA::mask out all but 3 LSB thus keeping it 0-7
P:119EC::do another check
P:119EF:AddFBit:add bit to already set bits in filter
P:119F2::and store
P:119F5::load vertical position using offset
P:119F8::set vertical position and other values
P:119FB::initialize dummy variable
P:119FE::set timer
P:11A03::process our new enemy object
P:11A06:DoBulletBills:start at beginning of enemy slots
P:11A08:BB_SLoop:move onto the next slot
P:11A09::branch to play sound if we've done all slots
P:11A0D::if enemy buffer flag not set,
P:11A10::loop back and check another slot
P:11A15::check enemy identifier for
P:11A17::bullet bill object (frenzy variant)
P:11A19:ExF17:if found, leave
P:11A1A:FireBulletBill
P:11A1C::play fireworks/gunfire sound
P:11A20::load identifier for bullet bill object
P:11A22::unconditional branch
P:11A24:HandleGroupEnemies:--------------------------------\n$00 - used to store Y position of group enemies\n$01 - used to store enemy ID\n$02 - used to store page location of right side of screen\n$03 - used to store X position of right side of screen\nload value for green koopa troopa
P:11A27::subtract $37 from second byte read
P:11A29::save result in stack for now
P:11A2A::was byte in $3b-$3e range?
P:11A2C::if so, branch
P:11A2E::save another copy to stack
P:11A2F::load value for goomba enemy
P:11A31::if primary hard mode flag not set,
P:11A34::branch, otherwise change to value
P:11A36::for buzzy beetle
P:11A38:PullID:get second copy from stack
P:11A39:SnglID:save enemy id here
P:11A3B::load default y coordinate
P:11A3D::check to see if d1 was set
P:11A3F::if so, move y coordinate up,
P:11A41::otherwise branch and use default
P:11A43:SetYGp:save y coordinate here
P:11A45::get page number of right edge of screen
P:11A48::save here
P:11A4A::get pixel coordinate of right edge
P:11A4D::save here
P:11A4F::load two enemies by default
P:11A51::get first copy from stack
P:11A52::check to see if d0 was set
P:11A53::if not, use default value
P:11A55::otherwise increment to three enemies
P:11A56:CntGrp:save number of enemies here
P:11A59:GrLoop:start at beginning of enemy buffers
P:11A5B:GSltLp:increment and branch if past
P:11A5C::end of buffers
P:11A60::check to see if enemy is already
P:11A62::stored in buffer, and branch if so
P:11A66::store enemy object identifier
P:11A6A::store page location for enemy object
P:11A6E::store x coordinate for enemy object
P:11A71::add 24 pixels for next enemy
P:11A75::add carry to page location for
P:11A77::next enemy
P:11A7B::store y coordinate for enemy object
P:11A7F::activate flag for buffer, and
P:11A81::put enemy within the screen vertically
P:11A85::get identifier back and use as offset for jump engine\nprocess each enemy object separately
P:11A88::do this until we run out of enemy objects
P:11A8D:NextED:jump to increment data offset and leave
P:11A90:PPhitbox:--------------------------------
P:11A92:InitPiranhaPlant
P:11A95::apparently this sometimes refuses to work correctly lmao
P:11A9C::apparently this sometimes refuses to work correctly lmao
P:11AA0:InitPiranhaPlant1:set initial speed
P:11AA5::initialize enemy state and what would normally
P:11AA7::be used as vertical speed, but not in this case
P:11AAB::save original vertical coordinate here
P:11AB1::save original vertical coordinate - 24 pixels here
P:11ABA::set specific value for bounding box control
P:11ABD:InitUDPiranhaPlant
P:11AC0::apparently this sometimes refuses to work correctly lmao
P:11AC7::apparently this sometimes refuses to work correctly lmao
P:11ACB:InitUDPiranhaPlant1:set initial speed
P:11AD0::initialize enemy state and what would normally
P:11AD2::be used as vertical speed, but not in this case
P:11AD6::save original vertical coordinate here
P:11ADC::save original vertical coordinate - 24 pixels here
P:11AE1::set specific value for bounding box control
P:11AE4:InitEnemyFrenzy:--------------------------------\nload enemy identifier
P:11AE6::save in enemy frenzy buffer
P:11AEA::subtract 12 and use as offset for jump engine
P:11AEF::frenzy object jump table
P:11AFB:NoFrenzyCode:--------------------------------
P:11AFC:EndFrenzy:--------------------------------\nstart at last slot
P:11AFE:LakituChk:check enemy identifiers
P:11B01::for lakitu
P:11B05::if found, set state
P:11B0A:NextFSlot:move onto the next slot
P:11B0B::do this until all slots are checked
P:11B0F::empty enemy frenzy buffer
P:11B12::disable enemy buffer flag for this object
P:11B15:InitJumpGPTroopa:--------------------------------\nset for movement to the left
P:11B19::set horizontal speed
P:11B1D:TallBBox2:set specific value for bounding box control
P:11B1F:SetBBox2:set bounding box control then leave
P:11B23:InitBalPlatform:--------------------------------\nraise vertical position by two pixels
P:11B27::if secondary hard mode flag not set,
P:11B2A::branch ahead
P:11B2C::otherwise set value here
P:11B2E::do a sub to add or subtract pixels
P:11B31:AlignP:set default value here for now
P:11B33::get current balance platform alignment
P:11B36::set platform alignment to object state here
P:11B38::if old alignment $ff, put $ff as alignment for negative
P:11B3A::if old contents already $ff, put
P:11B3B::object offset as alignment to make next positive
P:11B3C:SetBPA:store whatever value's in Y here
P:11B41::init moving direction
P:11B43::init Y
P:11B44::do a sub to add 8 pixels, then run shared code here
P:11B47:InitDropPlatform:--------------------------------
P:11B49::set some value here
P:11B4C::then jump ahead to execute more code
P:11B4F:InitHoriPlatform:--------------------------------
P:11B51::init one of the moving counters
P:11B53::jump ahead to execute more code
P:11B56:InitVertPlatform:--------------------------------\nset default value here
P:11B58::check vertical position
P:11B5A::if above a certain point, skip this part
P:11B5E::otherwise get two's compliment
P:11B61::get alternate value to add to vertical position
P:11B63:SetYO:save as top vertical position
P:11B67::load value from earlier, add number of pixels 
P:11B68::to vertical position
P:11B6A::save result as central vertical position
P:11B6C:CommonPlatCode:--------------------------------\ninitialize vertical speed
P:11B6E::and movement force
P:11B73:SPBBox:set default bounding box size control
P:11B78::check for castle-type level
P:11B7A::use default value if found
P:11B7C::otherwise check for secondary hard mode flag
P:11B7F::if set, use default value
P:11B81::use alternate value if not castle or secondary not set
P:11B83:CasPBB:set bounding box size control here and leave
P:11B87:LargeLiftUp:--------------------------------\nexecute code for platforms going up
P:11B8A::overwrite bounding box for large platforms
P:11B8D:LargeLiftDown:execute code for platforms going down
P:11B90:LargeLiftBBox:jump to overwrite bounding box size control
P:11B93:PlatLiftUp:--------------------------------\nset movement amount here
P:11B98::set moving speed for platforms going up
P:11B9C::skip ahead to part we should be executing
P:11B9F:PlatLiftDown:--------------------------------\nset movement amount here
P:11BA4::set moving speed for platforms going down
P:11BA8:CommonSmallLift:--------------------------------
P:11BAA::do a sub to add 12 pixels due to preset value  
P:11BAF::set bounding box control for small platforms
P:11BB3:PlatPosDataLow:--------------------------------
P:11BB6:PlatPosDataHigh
P:11BB9:PosPlatform:get horizontal coordinate
P:11BBC::add or subtract pixels depending on offset
P:11BBF::store as new horizontal coordinate
P:11BC3::add or subtract page location depending on offset
P:11BC6::store as new page location
P:11BC8::and go back
P:11BC9:EndOfEnemyInitCode:--------------------------------
P:11BCA:GameText1:.db $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
P:11BCA:TopStatusBarLine1
P:11BDB:: "WORLD"\n "WORLD  TIME"
P:11BE9:: score trailing digit and coin display
P:11BF1:: attribute table data, clears name table 0 to palette 2
P:11BF5:: attribute table data, used for coin icon in status bar
P:11BF9:: end of data block
P:11BFA:WorldLivesDisplay1: cross with spaces used on
P:11BFF:: lives display
P:11C04:: "WORLD  - " used on lives display
P:11C10:: possibly used to clear time up
P:11C14:: attribute table data for crown if more than 9 lives
P:11C15:OnePlayerTimeUp1:TwoPlayerTimeUp1:\n .db $21, $cd, $05, $16, $0a, $1b, $12, $18 ; "MARIO"\n "TIME UP"
P:11C20:TwoPlayerGameOver1: "MARIO"
P:11C28:GameOver1:"GAME OVER"
P:11C28:OnePlayerGameOver1
P:11C34::"CONTINUE"
P:11C43::"END"
P:11C4A:WarpZoneWelcome1: "MARIO"\n "GAME OVER"\n "WELCOME TO WARP ZONE!"
P:11C62:: placeholder for left pipe
P:11C66:: placeholder for middle pipe
P:11C6A:: placeholder for right pipe
P:11C6E:: attribute data
P:11C77:GameTextOffsets1:LuigiName:\n  .db $15, $1e, $12, $10, $12    ; "LUIGI", no address or length00         ; world 4-2 to world 5
P:11C81:WriteGameText1:save text number to stack
P:11C83::multiply by 2 and use as offset
P:11C84::if set to do top status bar or world/lives display,
P:11C86::branch to use current offset as-is
P:11C88::if set to do time-up or game over,
P:11C8A::branch to check players
P:11C8C::otherwise warp zone, therefore set offset
P:11C8E:Chk2Players1:lda NumberOfPlayers     ;check for number of players\nbne LdGameText          ;if there are two, use current offset to also print name\notherwise increment offset by one to not print name
P:11C8F:LdGameText1:get offset to message we want to print
P:11C94:GameTextLoop1:load message data
P:11C97::check for terminator
P:11C99::branch to end text if found
P:11C9B::otherwise write data to buffer
P:11C9E::and increment increment
P:11CA0::do this for 256 bytes if no terminator found
P:11CA2:EndGameText1:put null terminator at end
P:11CA7::pull original text number from stack
P:11CA9::are we printing warp zone?
P:11CAB::subtract 4 and then shift to the left
P:11CAD::twice to get proper warp zone number
P:11CAE::offset
P:11CB2:WarpNumLoop1:print warp zone numbers into the
P:11CB5::placeholders from earlier
P:11CB9::put a number in every fourth space
P:11CC1::load new buffer pointer at end of message
P:11CC7:PaletteMTtable
P:11DC7:WorldAddrOffsets
P:11DCF::world 9
P:11DD0:AreaAddrOffsets: Why is it $c0 and not $40?  Does it matter?
P:11DD0:World1Areas
P:11DD5:World2Areas
P:11DDA:World3Areas
P:11DDE:World4Areas
P:11DE2:World5Areas
P:11DE6:World6Areas
P:11DEA:World7Areas
P:11DEF:World8Areas
P:11DF3:World9Areas
P:11DF7:EnemyAddrHOffsets:AreaAddrOffsets:\nWorld1Areas: .db $25, $29, $40, $26, $60 ; Why is it $c0 and not $40?  Does it matter?\nWorld2Areas: .db $28, $29, $01, $27, $62\nWorld3Areas: .db $24, $35, $20, $63\nWorld4Areas: .db $22, $29, $41, $2c, $61\nWorld5Areas: .db $2a, $31, $26, $62\nWorld6Areas: .db $2e, $23, $2d, $60\nWorld7Areas: .db $33, $29, $01, $27, $64\nWorld8Areas: .db $30, $32, $21, $65\nWorld9Areas: .db $27, $66\nbonus area data offsets, included here for comparison purposes\nunderground bonus area  - c2\ncloud area 1 (day)      - 2b\ncloud area 2 (night)    - 34\nwater area (5-2/6-2)    - 00\nwater area (8-4)        - 02\nwarp zone area (4-2)    - 2f\nEnemyAddrHOffsets:\n      .db $1f, $06, $1c, $00\nEnemyDataAddrLow:\n      .db <E_CastleArea1, <E_CastleArea2, <E_CastleArea3, <E_CastleArea4, <E_CastleArea5, <E_CastleArea6\n      .db <E_GroundArea1, <E_GroundArea2, <E_GroundArea3, <E_GroundArea4, <E_GroundArea5, <E_GroundArea6\n      .db <E_GroundArea7, <E_GroundArea8, <E_GroundArea9, <E_GroundArea10, <E_GroundArea11, <E_GroundArea12\n      .db <E_GroundArea13, <E_GroundArea14, <E_GroundArea15, <E_GroundArea16, <E_GroundArea17, <E_GroundArea18\n      .db <E_GroundArea19, <E_GroundArea20, <E_GroundArea21, <E_GroundArea22, <E_UndergroundArea1\n      .db <E_UndergroundArea2, <E_UndergroundArea3, <E_WaterArea1, <E_WaterArea2, <E_WaterArea3\n Water
P:11DF8:: Ground
P:11DF9:: Underground
P:11DFA:: castle
P:11DFB:EnemyDataAddrLow:.db "98uj3urh3q2nwfyw3q2ghf276"\n Castle
P:11DFB:EnemyDataAddrLow_CastleStart
P:11E03:EnemyDataAddrLow_GroundStart: Ground
P:11E1E:EnemyDataAddrLow_UndergroundStart: UnderGround
P:11E21:EnemyDataAddrLow_WaterStart: Water
P:11E24:EnemyDataAddrHigh: Castle
P:11E2C:: Ground
P:11E47:: Underground
P:11E4A:: Water
P:11E4D:AreaDataHOffsets:AreaDataHOffsets:\n      .db $00, $03, $19, $1c\n.db "AreaDataHOffsets"\n Water
P:11E4E:: Ground
P:11E4F:: Underground
P:11E50:: castle
P:11E51:AreaDataAddrLow: Water
P:11E51:AreaDataAddrLow_WaterStart
P:11E54:AreaDataAddrLow_GroundStart: Ground
P:11E6F:AreaDataAddrLow_UndergroundStart: Underground
P:11E72:AreaDataAddrLow_CastleStart: Castle
P:11E7A:AreaDataAddrHigh: Water
P:11E7D:: Ground
P:11E98:: Underground
P:11E9B:: Castle
P:11EA3::ENEMY OBJECT DATA
P:13FFF:E_CastleArea1: bank 05 -- level banks\n bank identifier\n -----------\n LEVEL BANKS\n -----------\n07\n [e] used in enemy data\n [l] used in level data\n [e] Two Goombas\n [e] Three Goombas\n [e] Use on first byte to skip a number of pages specified by the second byte.\n [e,l] Add to second byte to skip to the next page\n [l] Tree ledge to Vertical pipe.  Add to second byte\n [l] Hole to low ? blocks.  Add to first byte\n [l] Intro pipe to loop keeper.  Add to first byte.  use this for flagpole\n [l] Intro pipe to loop keeper.  Add to first byte\n [l] Add this to a pipe to make it a warp pipe\nGAME LEVELS DATA\n.db "GAMELEVELSDATA"\n.db "ENEMYOBJECTDATA"\nlevel 1-4
P:14035:E_CastleArea5:level 7-4
P:14036:E_CastleArea6:level 8-4
P:14037:E_CastleArea7:level 9-2
P:14038:E_GroundArea2:level 8-3
P:14039:E_GroundArea6:level 1-1\n      .db $1e, $c2, $00, $6b, $06, $8b, $86, $63, $b7, $0f, $05\n      .db $03, $06, $23, $06, $4b, $b7, $bb, $00, $5b, $b7\n      .db $fb, $37, $3b, $b7, $0f, $0b, $1b, $37\n      .db $ff\nTwoGoombas = $37\nPageFlag = $80\nPageSkip = $0f\n.db $55, $16 + $80\n.db $55, $1b + $80 ; clockwise firebar\n.db $55, $1c + $80 ; fast clockwise firebar\n.db $55, $1d + $80 ; counterclockwise firebar\n.db $55, $1e + $80 ; fast counterclockwise firebar\n.db $55, $1f + $80 ; clockwise long firebar\n      .db $55, $20 + $80 ; glitchy firebar (counterclockwise long firebar)\n      .db $55, $21 + $80 ; glitchy firebar (clockwise fast long firebar)\n      .db $55, $22 + $80 ; glitchy firebar (counterclockwise fast long firebar)\n      .db $ff\n.db $00, $b5 ; Mushroom Retainer\n.db $8b, PageFlag+Spiny\n.db $1e, PageFlag+$42, $00\n.db $4a, HammerBro + PageFlag\n.db $5a, HammerBro\n.db $6a, HammerBro\n.db $7a, HammerBro\n.db $8a, HammerBro\n.db $9a, HammerBro
P:1403E::.db $94, PowerUpObject, $00
P:1405F:E_GroundArea7:level 1-3
P:14069::.db $aa, $14 ;fish
P:140A0:E_GroundArea9:level 2-1
P:140DB:E_GroundArea10:end of data terminator here is also used by pipe intro area
P:140DE:E_GroundArea12:cloud level used in levels 2-1 and 5-2
P:140DF:E_GroundArea16:warp zone area used in level 4-2
P:140E0:E_GroundArea17:level 8-1
P:140E1:E_GroundArea19:level 8-2
P:140E2:E_GroundArea21:cloud level used in levels 3-1 and 6-2
P:140E3:E_UndergroundArea1:level 1-2
P:1412D:E_UndergroundArea2:level 9-2
P:1412E:E_UndergroundArea3:underground bonus rooms area used in many levels
P:1412F:E_WaterArea1:water area used in levels 5-2 and 6-2
P:14130:E_WaterArea3:level 7-2
P:14131:L_CastleArea1:AREA OBJECT DATA\n.db "AREAOBJECTDATA"\nlevel 1-4/6-4
P:146D4:L_CastleArea5:level 7-4
P:146D7:L_CastleArea6:level 8-4
P:146DA:L_CastleArea7:level 9-2
P:146DD:L_GroundArea2:level 8-3
P:146E0:L_GroundArea6:level 1-1\nL_GroundArea6:\n header (first byte)
P:146E2:: .db $24, $00, $01, $8C, $02, $00, $01, $8C, $01, $00, $01, $8C, $0A, $00, $01, $88, $02, $00, $01, $88, $01, $00, $01, $88, $0D, $00, $01, $88, $01, $00, $01, $88, $0D, $00, $01, $88, $01, $00, $01, $88, $0A, $00, $01, $88, $03, $00, $01, $88, $05, $00, $02, $C2, $0E, $00, $02, $C2, $0E, $00, $02, $C2, $0E, $00, $02, $C2, $0D, $00, $03, $C2, $20, $54, $A0, $00, $01, $C2, $0F, $00, $02, $54, $0E, $00, $02, $54, $AE, $00\n.db $00 + $02*$08 + $01*$40                               ; header (first byte)\n.db $01 + $02*$10 + $00*$40                               ; header (second byte)\n.db Objects3Flag + $06 * $10, $40 + $01 + PageFlag        ; (6,) flagpole\n x=10, id=02, y=06\n.db Objects4Flag + $0a * $10, $02 * $10 + $06             ; (10,6) castle\n.db $fd\nL_GroundArea6a:\n Still needs work; have to see how castle terrain and water levels work.\n PageFlag = $80      ; Add to second byte to skip to the next page\n Objects1Flag = $10  ; Tree ledge to Vertical pipe.  Add to second byte\n Objects2Flag = $0c  ; Hole to low ? blocks.  Add to first byte\n Objects3Flag = $0d  ; Intro pipe to loop keeper.  Add to first byte.  use this for flagpole\n Objects4Flag = $0f  ; Intro pipe to loop keeper.  Add to first byte\n WarpFlag = $08      ; Add this to a pipe to make it a warp pipe\n ----------------------------------------------------------------------------------------------------\n Header (first byte): scenery/bg color + player entrance control * $08 + timer setting * $40\n Scenery/bg color (3 bits 00000xxx)\n 00 = green bushes\n 01 = water\n 02 = castle wall\n 03 = green bushes\n 04 = night sky, green bushes\n 05 = snow bushes, pipes\n 06 = night sky, snow bushes, pipes\n 07 = night sky, snow bushes, pipes, terrain, enemies\n Player entrance control (3 bits 00xxx000)\n 00 = drop in from top of screen on the left\n 01 = drop in from near top of screen on the left\n 02 = start standing to the left\n 03 = drop in from middle height on the left\n 04 = drop in from top of screen on the left\n 05 = drop in from top of screen on the left\n 06 = start to the left, auto walk to right\n 07 = start to the left, auto walk to right\n Timer setting (2 bits xx000000)\n 00 = 0\n 01 = 300\n 02 = 200\n 03 = 100\n ----------------------------------------------------------------------------------------------------\n ----------------------------------------------------------------------------------------------------\n Header (second byte): terrain control + background scenery type * $10 + background scenery * $40\n terrain control (4 bits xxxx0000)\n 00 = (no terrain)\n 01 = ground (1 block height)\n 02 = ground (1 block height) + ceiling (1 block height)\n 03 = ground (1 block height) + ceiling (3 block height)\n 04 = ground (1 block height) + ceiling (4 block height)\n 05 = ground (1 block height) + ceiling (8 block height)\n 06 = ground (5 block height) + ceiling (1 block height)\n 07 = ground (5 block height) + ceiling (3 block height)\n 08 = ground (5 block height) + ceiling (4 block height)\n 09 = ground (6 block height) + ceiling (1 block height)\n 0a = ceiling (1 block height)\n 0b = ground (6 block height) + ceiling (4 block height)\n 0c = ground (9 block height) + ceiling (1 block height)\n 0d = ground (2 block height) + ceiling (1 block height), middle section (y=03, 5 block height)\n 0e = ground (2 block height) + ceiling (1 block height), middle section (y=04, 5 block height)\n 0f = full of blocks (13 block height)\n background scenery type (2 bits 0000xx00)\n 00 = no scenery\n 01 = clouds\n 02 = hills, bushes, clouds\n 03 = fences\n background scenery (2 bits 000000xx)\n 00 = green pipes and bushes\n 01 = copper color pipes and bushes\n 02 = green pipes and bushes\n 03 = cloud type override\n ----------------------------------------------------------------------------------------------------\n.db $4a, custom, $71\n.db $59, custom, $71\n.db $5a, coin\n.db $69, coin
P:14AC5:L_UndergroundArea1:level 1-2
P:14F1C:L_GroundArea7:	  .db $17, $0c\n	  .db $37, $0d\n	  .db $57, $0e\n	  .db $77, $0f\n	  ;.db $07, $01 + PageFlag                                   ; (0,7) ? block with coin (+0x80 for page skip)\n	  ;.db $00, Objects1Flag + $05 * $10 + $02 - $01             ; (14,10) column of 3D blocks (1 high)\n	  ;.db $09, Objects1Flag + $05 * $10 + $02 - $01             ; (14,10) column of 3D blocks (1 high)\n	  .db Objects4Flag + $01 * $10, $06 * $10 + $06 - $01 + PageFlag, $00  ; (6,1) upside down pipe\n	  .db Objects4Flag + 1*$10, $07 * $10 + 4 - $01, (1-$01)*$10+ 9, $36 ;1,9,4,1,$36 ;x,y,w,h,mt\n	  ;customobj 3,2,3,1,$20 ;x,y,w,h,mt\n	  .db Objects4Flag + 3*$10, $07 * $10 + 3 - $01, (1-$01)*$10+ 2, $20\n	  .db $57, Objects1Flag + $06 * $10 + $02 - $01             ; (12,9) Vertical pipe (2 blocks height)\n	  ;customobj 5,9,2,2,$61\n	  .db Objects4Flag + 5*$10, $07 * $10 + 2 - $01, (2-$01)*$10+ 9, $61\n	  .db Objects4Flag + 7*$10, $07 * $10 + 5 - $01, (3-$01)*$10+ 8, $90\n	  ;customobj 7,8,5,3,$90 ;x,y,w,h,mt\n	  .db Objects4Flag + 7*$10, $07 * $10 + 3 - $01, (1-$01)*$10+ 9, $20\n	  ;customobj 7,9,3,1,$20 ;x,y,w,h,mt\n	  .db $c6, Objects1Flag + $06 * $10 + $05 - $01\n	  .db Objects4Flag + $d*$10, $07 * $10 + 1 - $01, (1-$01)*$10+ 2, $8d\n	  ;customobj $d,2,1,1,$8d ;x,y,w,h,mt\n	  \n	  \n	  ;.db Objects4Flag + $01 * $10, $07 * $10 + $09 - $01, $05	; (12,6) bridge\n      ;.db $47, Objects1Flag + $01 * $10 + $05 - $01             ; (4,7) row of 5 bricks\n      ;.db $57, $00                                              ; (5,7) ? block with power-up\n	  \n	  ;customobj 5,6,1,1,$71									;commented this until i fix those fucking slopes\n	  ;customobj 6,5,1,1,$71\n	  \n      ;.db $66, Objects1Flag + $02 * $10 + $01 - $01\n	  ;.db $75, Objects1Flag + $02 * $10 + $01 - $01\n	  \n	  ;.db $63, $01                                               ; (6,3) ? block with coin\n	  ;.db Objects4Flag + 7*$10, $07 * $10 + 1 - $01 +$80, (1-$01)*$10+ 6, $8c\n	  ;customobj 7,6,1,1,$8c ;x,y,w,h,mt\n	  ;customobj 7,6,1,1,$8c ;x,y,w,h,mt\n\n	  ;.db Objects4Flag + $07 * $10, $07 * $10 + $01 - $01, $06, $8c\n      ;.db $77, $01                                              ; (7,7) ? block with coin\n	  ;.db $d0, Objects1Flag + $05 * $10 + $02 - $01             ; (14,10) column of 3D blocks (1 high)\n	  .db Objects4Flag + $e*$10, $07 * $10 + 8 - $01, (1-$01)*$10+ $b, $8a\n	  ;customobj $e,$b,8,1,$8a ;x,y,w,h,mt\n	  .db Objects4Flag + $e*$10, $07 * $10 + 8 - $01, (1-$01)*$10+ 8, $8e\n	  ;customobj $e,8,8,1,$8e ;x,y,w,h,mt\n	  ;customobjp $5,11,1,2,$00 ;x,y,w,h,mt\n	  .db Objects4Flag + 6*$10, $07 * $10 + 1 - $01 + $80, (6-$01)*$10 + 2, $8f\n	  ;customobjp 6,2,1,6,$8f ;x,y,w,h,mt\n	  \n      .db $68, Objects1Flag + $06 * $10 + $03 - $01; + PageFlag  ; (6,8) Vertical pipe (3 blocks height)\n	  \n      .db $e7, Objects1Flag + $06 * $10 + $04 - $01             ; (14,7) Vertical pipe (4 blocks height)\n      .db $97, Objects1Flag + $06 * $10 + WarpFlag + $04 - $01 + PageFlag ; (9,7) Vertical warp pipe (4 blocks height)\n	  .db Objects4Flag + $b*$10, $07 * $10 + 1 - $01, (1-$01)*$10+ $a, $8c\n      .db $06, $03 + PageFlag                                   ; (0,6) invisible block with 1-up\n	  customobj 0,4,6,1,$72 ;x,y,w,h,mt\n	  ;customobj 0,10,1,1,$8c ;x,y,w,h,mt\n	  \n	  .db $60, Objects1Flag + $02 * $10 + $02 - $01				; (6,0) row of blocks\n	  .db Objects4Flag + $06 * $10, $06 * $10 + $08 - $01, $01  ; (6,1) upside down pipe\n	  ;.db $83, Objects1Flag + $02 * $10 + $03 - $01\n	  .db $90, Objects1Flag + $02 * $10 + $02 - $01				; (9,0) row of blocks\n	  .db Objects4Flag + $09 * $10, $05 * $10 + $06 - $01, $01  ; (9,1) upside down pipe (enterable)\n	  \n	  ;.db Objects4Flag + $0b * $10, $07 * $10 + $05 - $01, $27, $8b	; (11,7) custom object with customizable lenght and height\n	  customobj 11,3,5,1,$72  ;x,y,w,h,mt\n	  customobj 12,7,5,3,$8b ;x,y,w,h,mt\n      ; x = 5, id = 0, width = 2\n      .db Objects2Flag + $05 * $10, $00 * $10 + $02 - $01       ; (5,) pit (2 blocks wide)\n      ; x = 13, y=7, id = 1, width = 3\n      .db $d7, Objects1Flag + $01 * $10 + $03 - $01             ; (13,7) row of 3 bricks\n      .db $e7, $00                                              ; (14,7) ? block with power-up\n      .db $03, Objects1Flag + $01 * $10 + $08 - $01 + PageFlag  ; (0,3) row of 8 bricks\n      ; x = 6, id = 0, width = 3\n      .db Objects2Flag + $06 * $10, $00 * $10 + $03 - $01       ; (6,) pit (3 blocks wide)\n\n      .db $b3, Objects1Flag + $01 * $10 + $03 - $01             ; (11,3) row of 3 bricks\n      .db $e3, $01                                              ; (14,3) ? block with coin\n      .db $e7, $07                                              ; (14,7) brick with multi-coin\n      .db $47, Objects1Flag + $01 * $10 + $01 - $01 + PageFlag  ; (4,7) single brick\n      .db $57, $06                                              ; (5,7) brick with starman\n      .db $a7, $01                                              ; (10,7) ? block with coin\n      .db $d3, $00                                              ; (13,3) ? block with power-up\n      .db $d7, $01                                              ; (13,7) ? block with coin\n      .db $07, $01 + PageFlag                                   ; (0,7) ? block with coin\n      .db $67, Objects1Flag + $01 * $10 + $01 - $01             ; (6,7) single brick\n\n      .db $93, Objects1Flag + $01 * $10 + $03 - $01             ; (9,3) row of 3 bricks\n      .db $03, Objects1Flag + $01 * $10 + $04 - $01 + PageFlag  ; (0,3) row of 4 bricks\n      ; x=1, id = 6, width = 2\n      .db Objects2Flag + $01 * $10, $06 * $10 + $02 - $01       ; (0,3) high ?-block row (2 wide)\n      .db $17, Objects1Flag + $01 * $10 + $02 - $01             ; (1,7) row of 2 bricks\n      ; x=6, id=3, width = 4\n      .db Objects4Flag + $06 * $10, $03 * $10 + $04 - $01       ; (6,) 3D block stairs ascending (4 width)\n      \n      ; x=12, y=7, id=5, height = 4\n      .db $c7, Objects1Flag + $05 * $10 + $04 - $01             ; (12,7) column of 3D blocks (4 high)\n      .db $d8, Objects1Flag + $05 * $10 + $03 - $01             ; (13,8) column of 3D blocks (3 high)\n      .db $e9, Objects1Flag + $05 * $10 + $02 - $01             ; (14,9) column of 3D blocks (2 high)\n      .db $fa, Objects1Flag + $05 * $10 + $01 - $01             ; (15,10) column of 3D blocks (1 high)\n      .db Objects4Flag + $04 * $10, $03 * $10 + $03 + PageFlag  ; (6,) 3D block stairs ascending (4 width)\n      \n      .db $87, Objects1Flag + $05 * $10 + $04 - $01             ; (8,7) column of 3D blocks (4 high)\n      .db Objects2Flag + $09 * $10, $00 * $10 + $02 - $01       ; (9,) pit (2 blocks wide)\n      .db $b7, Objects1Flag + $05 * $10 + $04 - $01             ; (11,7) column of 3D blocks (4 high)\n      .db $c8, Objects1Flag + $05 * $10 + $03 - $01             ; (12,8) column of 3D blocks (3 high)\n      .db $d9, Objects1Flag + $05 * $10 + $02 - $01             ; (13,9) column of 3D blocks (2 high)\n\n      .db $ea, Objects1Flag + $05 * $10 + $01 - $01             ; (14,10) column of 3D blocks (1 high)\n      .db $39, Objects1Flag + $06 * $10 + $02 - $01 + PageFlag  ; (3,9) Vertical pipe (2 blocks height)\n      .db $87, Objects1Flag + $01 * $10 + $02 - $01             ; (8,7) row of 2 bricks\n      .db $a7, $01                                              ; (10,7) ? block with coin\n      .db $b7, Objects1Flag + $01 * $10 + $01 - $01             ; (11,7) single brick\n      \n      .db $39, Objects1Flag + $06 * $10 + $02 - $01 + PageFlag  ; (3,9) Vertical pipe (2 blocks height)\n      ; x=5, id=3, width = 9\n      .db Objects4Flag + $05 * $10, $03 * $10 + $09 - $01       ; (5,) 3D block stairs ascending (9 width)\n      ; x=6, ?=$40, id = 1 \n      .db Objects3Flag + $06 * $10, $40 + $01 + PageFlag        ; (6,) flagpole\n      ; x=10, id=02, y=06\n      .db Objects4Flag + $0a * $10, $02 * $10 + $06             ; (10,6) castle\n\n      .db $fd                                                   ; end of level data marker\n.db $50, $21, $98, $72, $c6, $00, $d7, $00, $e7, $14\n.db $e8, $00, $f6, $15, $f9, $00, $0a, $80, $18, $11\n.db $29, $00, $38, $00, $47, $00, $56, $00, $68, $f2\n.db $e7, $73, $97, $fb, $06, $83, $5c, $01, $d7, $22\n.db $e7, $00, $03, $a7, $6c, $02, $b3, $22, $e3, $01\n.db $e7, $07, $47, $a0, $57, $06, $a7, $01, $d3, $00\n.db $d7, $01, $07, $81, $67, $20, $93, $22, $03, $a3\n.db $17, $21, $1c, $61, $6f, $33, $c7, $63, $d8, $62\n.db $e9, $61, $fa, $60, $4f, $b3, $87, $63, $9c, $01\n.db $b7, $63, $c8, $62, $d9, $61, $ea, $60, $39, $f1\n.db $87, $21, $a7, $01, $b7, $20, $39, $f1, $5f, $38\n.db $6d, $c1, $af, $26, $fd\nlevel 1-3/5-3
P:14F1C:TestLevel
P:155BF:L_GroundArea9:level 2-1
P:15CCC:L_GroundArea10:pipe intro area
P:15D41:L_GroundArea12:cloud level used in levels 2-1 and 5-2
P:15D56:L_GroundArea16:warp zone area used in level 4-2
P:15D59:L_GroundArea17:level 8-1
P:15D5C:L_GroundArea19:level 8-2
P:15D5F:L_GroundArea21:cloud level used in levels 3-1 and 6-2
P:15D62:L_UndergroundArea2:level 4-2
P:15D65:L_UndergroundArea3:underground bonus rooms area used in many levels
P:15D68:L_WaterArea1:water area used in levels 5-2 and 6-2
P:15D6B:L_WaterArea3:level 2-2/7-2\nlevel 7-2
P:15D6E:E73
P:15D6E:E91
P:15D6E:E93
P:15D6F:L73
P:15D6F:L91
P:15D6F:L93
P:15D72::-------------------------------------------------------------------------------------
P:15FFF:E_CastleArea3:level 2-4
P:1603C:E_GroundArea8:level 2-3
P:16071:E_WaterArea2:level 2-2
P:160B0:E_GroundArea5:level 3-1
P:160E3:E_GroundArea22:level 3-2
P:1611A:L_CastleArea3:level 2-4
P:1664D:L_GroundArea5:level 3-1
P:16A52:L_GroundArea8:level 2-3
P:1709F:L_GroundArea22:level 3-2
P:17544:L_WaterArea2:level 2-2
P:17FFF:E_CastleArea4:08\nlevel 3-4
P:18038:E_GroundArea1:level 3-3
P:18075:E_GroundArea3:level 4-1
P:180BB:E42
P:1810A:E_GroundArea13:level 4-3
P:1813D:L_CastleArea4:level 3-4
P:18532:L_GroundArea1:level 3-3
P:189E5:L_GroundArea3:level 4-1
P:18F7C:L_GroundArea13:level 4-3
P:196A7:L42
P:19FFF:E_CastleArea2:level 4-4
P:1A044:E_GroundArea18:level 5-2
P:1A079:E_GroundArea11:level 5-1
P:1A0B0:E53:level 5-2
P:1A0EB:E54
P:1A126:L_CastleArea2:level 4-4
P:1A5CD:L_GroundArea11:level 5-1
P:1AC32:L_GroundArea18:level 5-2
P:1B251:L53:level 5-3
P:1B83A:L54
P:1BFFF:E_GroundArea15:09\nlevel 6-1
P:1C050:E_GroundArea4:level 6-2
P:1C087:E_GroundArea14:level 6-3
P:1C0CE:E64:level 6-4
P:1C0FF:E_GroundArea20:level 7-1
P:1C13A:L_GroundArea15: :--\nlevel 6-1
P:1C70B:L_GroundArea4:level 6-2
P:1CD0C:L_GroundArea14:level 6-3	  
P:1D39B:L64:level 6-4
P:1D636:L_GroundArea20:level 7-1
P:1FFFF::fucking size inflation because fuck the nes and its fucking powers of fucking two\n0a
P:23FFF::0b
P:27FFF::0c
P:2BFFF::0d
P:2FFFF::0e
P:33FFF::0f
P:37FFF::10
P:3BFFF:: fixed bank -- second half of original SMB code\n Relocated $c000-$ffff rom\nStart:\npretty standard 6502 type init here
P:3C001:Start:init PPU control register 1 
P:3C006::reset stack pointer
P:3C009:VBlank1:wait two frames
P:3C00E:VBlank2
P:3C013::load default cold boot pointer
P:3C015::this is where we check for a warm boot
P:3C017:WBootCheck:check each score digit in the top score
P:3C01A::to see if we have a valid digit
P:3C01C::if not, give up and proceed with cold boot
P:3C021::second checkpoint, check to see if 
P:3C024::another location has a specific value
P:3C028::if passed both, load warm boot pointer
P:3C02A:ColdBoot:clear memory using pointer in Y
P:3C02D::reset delta counter load register
P:3C030::reset primary mode of operation
P:3C033::set warm boot flag
P:3C038::set seed for pseudorandom register
P:3C03D::enable all sound channels except dmc
P:3C042::turn off clipping for OAM and background
P:3C048::initialize both name tables
P:3C04B::set flag to disable screen output
P:3C04E::disable frame counter to make irq work
P:3C057::enable NMIs
P:3C05C:EndlessLoop:jmp EndlessLoop\njsr _FamitoneInit\nlda $00						 ;idk if this does something but literally is in smb2j\nendless loop, need I say more? -yes
P:3C087::lda #$01\nsta FramesMissed		;enable this to compensate the missed frame in the next frame logic (don't)
P:3C089::read joypads so emulators doesn't mark this as lag frame hehe
P:3C08F::perform spr-ram DMA access on $0200-$02ff
P:3C094::never disable NMI
P:3C097::save all other bits
P:3C0A3::(essentially $2000) but save other bits
P:3C0AE::set irq registers
P:3C105:NonMaskableInterrupt
P:3C12E::do sub to check if parallax level type and set if so if the textbox is not displaying
P:3C13B::(essentially $2000) but save other bits
P:3C13E::disable OAM and background display by default
P:3C143::get screen disable flag
P:3C146::if set, used bits as-is
P:3C148::otherwise reenable bits and save them
P:3C14D:ScreenOff:save bits for later but not in register at the moment
P:3C150::disable screen for now
P:3C155::reset flip-flop and reset scroll registers to zero
P:3C15A::store contents of A into scroll registers
P:3C15D::and end whatever subroutine led us here
P:3C160::reset spr-ram address register
P:3C163::perform spr-ram DMA access on $0200-$02ff
P:3C168::load control for pointer to buffer contents
P:3C16B::set indirect at $00 to pointer
P:3C175::update screen with buffer contents
P:3C17A::check for usage of $0341
P:3C181::get offset based on usage
P:3C182:InitBuffer
P:3C185::clear buffer header at last location
P:3C18D::reinit address control to $0301
P:3C190::copy mirror of $2001 to register
P:3C1AD::read joypads
P:3C1B0::handle pause
P:3C1B3::start with mario's score
P:3C1B5:TopScoreCheck:start with the lowest digit
P:3C1B8:GetScoreDiff:subtract each player digit from each high score digit
P:3C1BB::from lowest to highest, if any top score digit exceeds
P:3C1BE::any player digit, borrow will be set until a subsequent
P:3C1BF::subtraction clears it (player digit is higher than top)
P:3C1C2::check to see if borrow is still set, if so, no new high score
P:3C1C4::increment X and Y once to the start of the score
P:3C1C6:CopyScore:store player's score digits into high score memory area
P:3C1CE::do this until we have stored them all
P:3C1D2:NoTopSc
P:3C1DA::check for pause status
P:3C1E0::if master timer control not set, decrement
P:3C1E3::all frame and interval timers
P:3C1EA:DecTimers:load end offset for end of frame timers
P:3C1EC::decrement interval timer control,
P:3C1EF::if not expired, only frame timers will decrement
P:3C1F3::if control for interval timers expired,
P:3C1F6::interval timers will decrement along with frame timers
P:3C1F8:DecTimersLoop:check current timer
P:3C1FB::if current timer expired, branch to skip,
P:3C1FD::otherwise decrement the current timer
P:3C200:SkipExpTimer:ldy FramesMissed\nbeq +\nlda Timers,x\nbeq +\ndec Timers,x\nmove onto next timer
P:3C201::do this until all timers are dealt with
P:3C203:NoDecTimers:increment frame counter
P:3C205:PauseSkip
P:3C208::run the bankswitch thingy and the code of the bank 01
P:3C210::do sub to check if parallax level type and set if so 
P:3C213::if in pause mode, do not bother with sprites at all
P:3C219::check for flag here
P:3C224:SkipThisThing:lda FinishedDemo\ncmp #$07\nbcs SkipMainOper\notherwise do one of many, many possible subroutines
P:3C227:SkipMainOper
P:3C22F::lda Mirror_PPU_CTRL_REG1\nora #%10000000            ;reactivate NMIs\nsta Mirror_PPU_CTRL_REG1\nsta PPU_CTRL_REG1\nwe are done until the next frame!
P:3C230:VRAM_AddrTable_Low:-------------------------------------------------------------------------------------
P:3C244:VRAM_AddrTable_High
P:3C258:VRAM_Buffer_Offset
P:3C25A:EnemiesAndLoopsCore:check data here for MSB set
P:3C25C::if MSB set in enemy flag, branch ahead of jumps
P:3C25E::if data zero, branch
P:3C260::otherwise, jump to run enemy subroutines
P:3C263:ChkAreaTsk:check number of tasks to perform
P:3C268::if at a specific task, jump and leave
P:3C26C::otherwise, jump to process loop command/load enemies
P:3C26F:ChkBowserF:mask out high nybble
P:3C272::use as pointer and load same place with different offset
P:3C277::if second enemy flag not set, also clear first one
P:3C279:ExitELCore
P:3C27A:ChangeSizeOffsetAdder
P:3C28E:G:ColorRotatePalette:\n       .db $16, $30\nBlankPalette:\n      .db $3f, $08, $04, $ff, $ff, $ff, $ff, $00\nused based on area type\nPalette3Data:\n     .db $0f, $30, $22, $0f \n    .db $0f, $30, $21, $0f \n   .db $0f, $30, $21, $0c\n   .db $0f, $30, $16, $2d\n--------------------------------\nColorRotation:\nrts\n			  ;lda HurryUp\nbeq ExitColorRot\nldx VRAM_Buffer1_Offset  ;check vram buffer offset\ncpx #$31\nbcs ExitColorRot         ;if offset over 48 bytes, branch to leave\nldy #$00\nGetBlankPal:  ;lda BlankPalette,y       ;get blank palette for palette 3\nsta VRAM_Buffer1,x       ;store it in the vram buffer\ninx                      ;increment offsets\niny\ncpy #$08\nbcc GetBlankPal          ;do this until all bytes are copied\nldx VRAM_Buffer1_Offset  ;get current vram buffer offset\nlda #$03\nsta $00                  ;set counter here\nlda AreaType             ;get area type\nasl                      ;multiply by 4 to get proper offset\nasl\ntay                      ;save as offset here\netAreaPal:   ;lda Palette3Data,y       ;fetch palette to be written based on area type\nsta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer\niny\n inx\n dec $00                  ;decrement counter\n bpl GetAreaPal           ;do this until the palette is all copied\n ldx VRAM_Buffer1_Offset  ;get current vram buffer offset\n ldy timerupthing   	   ;get color cycling offset\n lda ColorRotatePalette,y\n sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette\n lda VRAM_Buffer1_Offset\n clc                      ;add seven bytes to vram buffer offset\n adc #$07\n sta VRAM_Buffer1_Offset\nExitColorRot:; rts                      ;leave\nloop command data\n-------------------------------------------------------------------------------------\n	   lda GameEngineSubroutine\n	   cmp #$05\n	   bne +\n	   ldx ObjectOffset\n	   lda Enemy_ID,x\n	   cmp #Fireworks\n	   beq +\n	   jmp RunStarFlagObj\nget offset for enemy object buffer
P:3C28E:RunEnemyObjectsCore
P:3C290::load value 0 for jump engine by default
P:3C294::if enemy object < $15, use default value
P:3C298::otherwise subtract $14 from the value and use
P:3C299::as value for jump engine
P:3C29B:JmpEO
P:3C2A2::for objects $00-$14
P:3C2A4::15 for objects $15-$1f
P:3C2A6::16
P:3C2A8::17
P:3C2AA::18
P:3C2AC::19
P:3C2AE::1a
P:3C2B0::1b
P:3C2B2::1c
P:3C2B4::1d
P:3C2B6::1e
P:3C2B8::1f
P:3C2BA::20 for objects $20-$2f
P:3C2BC::21
P:3C2BE::22
P:3C2C0::23
P:3C2C2::24
P:3C2C4::25
P:3C2C6::26
P:3C2C8::27
P:3C2CA::28
P:3C2CC::29
P:3C2CE::2a
P:3C2D0::2b
P:3C2D2::2c
P:3C2D4::2d
P:3C2D6::2e
P:3C2D8::2f
P:3C2DA::30 for objects $30-$35
P:3C2DC::31
P:3C2DE::32
P:3C2E0::33
P:3C2E2::34
P:3C2E4::35
P:3C2E6::36
P:3C2E8::37
P:3C2EA::38
P:3C2EC::39
P:3C2EE::3a
P:3C2F0::3b
P:3C2F2::3c
P:3C2F4::3d
P:3C2F6::3e
P:3C2F8::3f
P:3C2FA::40
P:3C2FC::41
P:3C2FE::42
P:3C300::43
P:3C302:NoRunCode:--------------------------------
P:3C303:SignDo
P:3C30F:RunRetainerObj:--------------------------------
P:3C318:RunNormalEnemies:--------------------------------\ninit sprite attributes
P:3C31D::set A to add 1 byte in order to get enemy offset
P:3C31F::set Y to put offscreen bits in Enemy_OffscreenBits
P:3C322::add contents of X to A to get
P:3C323::appropriate offset, then give back to X
P:3C326::save offscreen bits offset to stack for now
P:3C328::do subroutine here
P:3C32F::store here
P:3C338::mask together with previously saved low nybble
P:3C33A::store both here
P:3C33C::get offscreen bits offset from stack
P:3C33E::get value here and store elsewhere
P:3C345::get coordinates of enemy object 
P:3C347::relative to the screen
P:3C348::store value to add to A here
P:3C34B::add A to value stored
P:3C34D::use as enemy offset
P:3C34E::load vertical coordinate low
P:3C350::store here
P:3C353::load horizontal coordinate
P:3C355::subtract left edge coordinate
P:3C359::store result here
P:3C361::store bitmask here for now
P:3C365::store another bitmask here for now and jump
P:3C367::get enemy object position relative
P:3C369::to the left side of the screen
P:3C36D::store here
P:3C36F::subtract borrow from current page location
P:3C371::of left side
P:3C374::if enemy object is beyond left edge, branch
P:3C378::if precisely at the left edge, branch
P:3C37A::if to the right of left edge, use value in $00 for A
P:3C37C:CMBit1:otherwise use contents of Y
P:3C37D::preserve bitwise whatever's in here
P:3C380::save masked offscreen bits here
P:3C383::if anything set here, branch
P:3C385::otherwise, do something else
P:3C38B:MoveBoundBoxOffscreen1:multiply offset by 4
P:3C38E::use as offset here
P:3C391::load value into four locations here and leave
P:3C3A6::check counter for d0 set
P:3C3B4::if master timer control set, skip to last routine
P:3C3BE:SkipMove
P:3C3C1:MovePiranhaPlant1
P:3C3C4:MoveUpsideDownPiranhaP1
P:3C3C7:EnemyMovementSubs
P:3C3D2::00 only objects $00-$14 use this table
P:3C3D4::01
P:3C3D6::02
P:3C3D8::03
P:3C3DA::04
P:3C3DC::05
P:3C3DE::06
P:3C3E0::07
P:3C3E2::08
P:3C3E4::09
P:3C3E6::0a
P:3C3E8::0b
P:3C3EA::0c
P:3C3EC::0d
P:3C3EE::0e
P:3C3F0::0f
P:3C3F2::10
P:3C3F4::11
P:3C3F6::12
P:3C3F8::dummy     ;13
P:3C3FA::14
P:3C3FC::15
P:3C3FE::16
P:3C400::17
P:3C402::18
P:3C404::19
P:3C406::1a
P:3C408::1b
P:3C40A::1c
P:3C40C::1d
P:3C40E::1e
P:3C410::1f
P:3C412::20
P:3C414::21
P:3C416::22
P:3C418:NoMoveCode:--------------------------------
P:3C419:RunBowserFlame:--------------------------------
P:3C42B:RunFirebarObj:--------------------------------
P:3C431:RunSmallPlatform:--------------------------------
P:3C440::get OAM data offset
P:3C443::load tile number for small platforms
P:3C445::increment offset for tile numbers
P:3C446::dump A contents
P:3C449::into third row sprites
P:3C44C::into second row sprites
P:3C452::and into first row sprites
P:3C455::dump tile number into all six sprites
P:3C458::increment offset for attributes
P:3C459::load palette controls
P:3C45B::dump A contents
P:3C45E::into third row sprites
P:3C461::into second row sprites
P:3C467::and into first row sprites
P:3C46A::dump attributes into all six sprites
P:3C46D::decrement for original offset
P:3C46F::get relative horizontal coordinate
P:3C475::dump as X coordinate into first and fourth sprites
P:3C479::add eight pixels
P:3C47B::dump into second and fifth sprites
P:3C482::add eight more pixels
P:3C484::dump into third and sixth sprites
P:3C48A::get vertical coordinate
P:3C48D::save to stack
P:3C48E::if vertical coordinate below status bar,
P:3C490::do not mess with it
P:3C492::otherwise move first three sprites offscreen
P:3C494:TopSP
P:3C497::and into first row sprites
P:3C49A::dump vertical coordinate into Y coordinates
P:3C49D::pull from stack
P:3C49F::add 128 pixels
P:3C4A2::if below status bar (taking wrap into account)
P:3C4A4::then do not change altered coordinate
P:3C4A6::otherwise move last three sprites offscreen
P:3C4A8:BotSP:dump vertical coordinate + 128 pixels
P:3C4AB::into Y coordinates
P:3C4B1::get offscreen bits
P:3C4B4::save to stack
P:3C4B5::check d3
P:3C4B9::if d3 was set, move first and
P:3C4BB::fourth sprites offscreen
P:3C4C1:SOfs:move out and back into stack
P:3C4C3::check d2
P:3C4C7::if d2 was set, move second and
P:3C4C9::fifth sprites offscreen
P:3C4CF:SOfs2:get from stack
P:3C4D0::check d1
P:3C4D4::if d1 was set, move third and
P:3C4D6::sixth sprites offscreen
P:3C4DC:ExSPl:get enemy object offset and leave
P:3C4E4:RunLargePlatform:--------------------------------
P:3C4F0::if master timer control set,
P:3C4F3::skip subroutine tree
P:3C4F8:SkipPT
P:3C501:LargePlatformSubroutines:--------------------------------
P:3C503::subtract $24 to get proper offset for jump table
P:3C50B::table used by objects $24-$2a
P:3C519:EraseEnemyObject:-------------------------------------------------------------------------------------\nclear all enemy object variables
P:3C521::sta FloateyNum_Control,x
P:3C539:MovePodoboo:-------------------------------------------------------------------------------------
P:3C53F::check enemy timer
P:3C542::branch to move enemy if not expired
P:3C544::otherwise set up podoboo again
P:3C547::get part of LSFR
P:3C54A::set d7
P:3C54C::store as movement force
P:3C54F::mask out high nybble
P:3C551::set for at least six intervals
P:3C553::store as new enemy timer
P:3C558::set vertical speed to move podoboo upwards
P:3C55A:PdbM:branch to impose gravity on podoboo
P:3C55D:ProcHammerBro:--------------------------------\n$00 - used in HammerBroJumpCode as bitmask\ncheck hammer bro's enemy state for d5 set
P:3C561::if not set, go ahead with code
P:3C563::otherwise jump to something else
P:3C566:ChkJH:check jump timer
P:3C568::if expired, branch to jump
P:3C56A::otherwise decrement jump timer
P:3C56F::check offscreen bits
P:3C571::if hammer bro a little offscreen, skip to movement code
P:3C573::check hammer throwing timer
P:3C576::if not expired, skip ahead, do not throw hammer
P:3C578::otherwise get secondary hard mode flag
P:3C57B::get timer data using flag as offset
P:3C57E::set as new timer
P:3C581::do a sub here to spawn hammer object
P:3C584::if carry clear, hammer not spawned, skip to decrement timer
P:3C588::set d3 in enemy state for hammer throw
P:3C58C::jump to move hammer bro
P:3C58F:DecHT:decrement timer
P:3C592::jump to move hammer bro
P:3C595:HammerBroJumpLData
P:3C597:HammerBroJumpCode:get hammer bro's enemy state
P:3C599::mask out all but 3 LSB
P:3C59B::check for d0 set (for jumping)
P:3C59D::if set, branch ahead to moving code
P:3C59F::load default value here
P:3C5A1::save into temp variable for now
P:3C5A3::set default vertical speed
P:3C5A5::check hammer bro's vertical coordinate
P:3C5A7::if on the bottom half of the screen, use current speed
P:3C5A9::otherwise set alternate vertical speed
P:3C5AB::check to see if hammer bro is above the middle of screen
P:3C5AD::increment preset value to $01
P:3C5AF::if above the middle of the screen, use current speed and $01
P:3C5B1::otherwise return value to $00
P:3C5B3::get part of LSFR, mask out all but LSB
P:3C5B8::if d0 of LSFR set, branch and use current speed and $00
P:3C5BA::otherwise reset to default vertical speed
P:3C5BC:SetHJ:set vertical speed for jumping
P:3C5BE::set d0 in enemy state for jumping
P:3C5C4::load preset value here to use as bitmask
P:3C5C6::and do bit-wise comparison with part of LSFR
P:3C5C9::then use as offset
P:3C5CA::check secondary hard mode flag
P:3C5CF::if secondary hard mode flag clear, set offset to 0
P:3C5D0:HJump:get jump length timer data using offset from before
P:3C5D3::save in enemy timer
P:3C5D9::get contents of part of LSFR, set d7 and d6, then
P:3C5DB::store in jump timer
P:3C5DD:MoveHammerBroXDir:move hammer bro a little to the left
P:3C5E1::change hammer bro's direction every 64 frames
P:3C5E5::if d6 set in counter, move him a little to the right
P:3C5E7:Shimmy:store horizontal speed
P:3C5E9::set to face right by default
P:3C5EB::get horizontal difference between player and hammer bro
P:3C5EE::if enemy to the left of player, skip this part
P:3C5F0::set to face left
P:3C5F1::check walking timer
P:3C5F4::if not yet expired, skip to set moving direction
P:3C5F8::otherwise, make the hammer bro walk left towards player
P:3C5FA:SetShim:set moving direction
P:3C5FC:MoveNormalEnemy:init Y to leave horizontal movement as-is 
P:3C600::check enemy state for d6 set, if set skip
P:3C602::to move enemy vertically, then horizontally if necessary
P:3C606::if set, branch to move enemy horizontally
P:3C60A::check enemy state for d5 set
P:3C60E::if set, branch to move defeated enemy object
P:3C613::check d2-d0 of enemy state for any set bits
P:3C615::if enemy in normal state, branch to move enemy horizontally
P:3C619::if enemy in state used by spiny's egg, go ahead here
P:3C61D::if enemy in states $03 or $04, skip ahead to yet another part
P:3C61F:FallE:set quick movement amount downwards
P:3C621::then check enemy state
P:3C623::if not set to unique state for spiny's egg, go ahead
P:3C625::and use, otherwise set different movement amount, continue on
P:3C627::set movement amount
P:3C629::set maximum speed in A
P:3C62B::set movement amount here
P:3C62D::increment X for enemy offset
P:3C62E::set maximum speed here
P:3C630::set value to move downwards
P:3C632::jump to the code that actually moves it
P:3C635::get enemy object buffer offset and leave
P:3C639::check for enemy state $02
P:3C63D::if found, branch to move enemy horizontally
P:3C63F::check for d6 set
P:3C641::if not set, branch to something else
P:3C645::check for power-up object
P:3C649::if any other object where d6 set, jump to set Y
P:3C64B:MEHor:increment offset for enemy offset
P:3C64C::position object horizontally according to
P:3C64F:SlowM:ldx ObjectOffset            ;counters, return with saved value in A,\nrts
P:3C651:SteadM:get current horizontal speed
P:3C653::save to stack
P:3C654::if not moving or moving right, skip, leave Y alone    
P:3C658:AddHS
P:3C659::add value here to slow enemy down if necessary
P:3C65C::save as horizontal speed temporarily
P:3C65E::increment offset for enemy offset
P:3C65F::position object horizontally according to
P:3C662::counters, return with saved value in A, ;then do a sub to move horizontally
P:3C665::get old horizontal speed from stack and return to
P:3C667::original memory location, then leave
P:3C668:PlayerEnemyDiff:get distance between enemy object's
P:3C66A::horizontal coordinate and the player's
P:3C66B::horizontal coordinate
P:3C66D::and store here
P:3C671::subtract borrow, then leave
P:3C674:ReviveStunned
P:3C67E::if enemy timer not expired yet,
P:3C681::skip ahead to something else
P:3C683::otherwise initialize enemy state to normal
P:3C687::get d0 of frame counter
P:3C689::use as Y and increment for movement direction
P:3C68B::store as pseudorandom movement direction
P:3C68D::decrement for use as pointer
P:3C68E::check primary hard mode flag
P:3C691::if not set, use pointer as-is
P:3C694::otherwise increment 2 bytes to next data
P:3C695:SetRSpd:load and store new horizontal speed
P:3C698::and leave
P:3C69B:MoveDefeatedEnemy:set quick movement amount downwards
P:3C69D::then check enemy state
P:3C69F::if not set to unique state for spiny's egg, go ahead
P:3C6A1::and use, otherwise set different movement amount, continue on
P:3C6A3::set movement amount
P:3C6A5::set maximum speed in A
P:3C6A7::set movement amount here
P:3C6A9::increment X for enemy offset
P:3C6AA::set maximum speed here
P:3C6AC::set value to move downwards
P:3C6AE::jump to the code that actually moves it
P:3C6B1::get enemy object buffer offset and leave
P:3C6B3::increment offset for enemy offset
P:3C6B4::position object horizontally according to
P:3C6B7::counters, return with saved value in A,rai
P:3C6BA:ChkKillGoomba:check to see if enemy timer has reached
P:3C6BC::a certain point, and branch to leave if not
P:3C6C0::check for goomba object
P:3C6C6::branch if not found
P:3C6C8::clear all enemy object variables
P:3C6E7:NKGmba:leave!
P:3C6E8:ProcMoveRedPTroopa:--------------------------------\n--------------------------------
P:3C6EA::check for any vertical force or speed
P:3C6ED::branch if any found
P:3C6EF::initialize something here
P:3C6F2::check current vs. original vertical coordinate
P:3C6F7::if current => original, skip ahead to more code
P:3C6F9::get frame counter
P:3C6FB::mask out all but 3 LSB
P:3C6FD::if any bits set, branch to leave
P:3C6FF::otherwise increment red paratroopa's vertical position
P:3C701:NoIncPT:leave
P:3C702:MoveRedPTUpOrDown:check current vs. central vertical coordinate
P:3C706::if current < central, jump to move downwards
P:3C708::otherwise jump to move upwards
P:3C70B:MovPTDwn:move downwards
P:3C70E:MoveFlyGreenPTroopa:--------------------------------\n$00 - used to store adder for movement, also used as adder for platform\n$01 - used to store maximum value for secondary counter\ndo sub to increment primary and secondary counters
P:3C711::do sub to move green paratroopa accordingly, and horizontally
P:3C714::set Y to move green paratroopa down
P:3C718::check frame counter 2 LSB for any bits set
P:3C71A::branch to leave if set to move up/down every fourth frame
P:3C71E::check frame counter for d6 set
P:3C720::branch to move green paratroopa down if set
P:3C722::otherwise set Y to move green paratroopa up
P:3C724:YSway:store adder here
P:3C728::add or subtract from vertical position
P:3C729::to give green paratroopa a wavy flight
P:3C72D:NoMGPT:leave!
P:3C72E:XMoveCntr_GreenPTroopa:load preset maximum value for secondary counter
P:3C730:XMoveCntr_Platform:store value here
P:3C734::branch to leave if not on
P:3C736::every fourth frame
P:3C738::get secondary counter
P:3C73A::get primary counter
P:3C73D::if d0 of primary counter set, branch elsewhere
P:3C73F::compare secondary counter to preset maximum value
P:3C741::if equal, branch ahead of this part
P:3C743::increment secondary counter and leave
P:3C745:NoIncXM
P:3C746:IncPXM:increment primary counter and leave
P:3C749:DecSeXM:put secondary counter in A
P:3C74A::if secondary counter at zero, branch back
P:3C74C::otherwise decrement secondary counter and leave
P:3C74F:MoveWithXMCntrs:save secondary counter to stack
P:3C752::set value here by default
P:3C756::if d1 of primary counter is
P:3C758::set, branch ahead of this part here
P:3C75C::otherwise change secondary
P:3C75E::counter to two's compliment
P:3C763::load alternate value here
P:3C765:XMRight:store as moving direction
P:3C767::increment offset for enemy offset
P:3C768::position object horizontally according to
P:3C76B::counters, return with saved value in A,
P:3C76D::save value obtained from sub here
P:3C76F::get secondary counter from stack
P:3C770::and return to original place
P:3C773:BlooberBitmasks:--------------------------------
P:3C775:MoveBloober
P:3C777::check enemy state for d5 set
P:3C779::branch if set to move defeated bloober
P:3C77B::use secondary hard mode flag as offset
P:3C77E::get LSFR
P:3C781::mask out bits in LSFR using bitmask loaded with offset
P:3C784::if any bits set, skip ahead to make swim
P:3C787::check to see if on second or fourth slot (1 or 3)
P:3C788::if not, branch to figure out moving direction
P:3C78A::otherwise, load player's moving direction and
P:3C78C::do an unconditional branch to set
P:3C78E:FBLeft:set left moving direction by default
P:3C790::get horizontal difference between player and bloober
P:3C793::if enemy to the right of player, keep left
P:3C795::otherwise decrement to set right moving direction
P:3C796:SBMDir:set moving direction of bloober, then continue on here
P:3C798:BlooberSwim:execute sub to make bloober swim characteristically
P:3C79B::get vertical coordinate
P:3C79E::subtract movement force
P:3C7A1::check to see if position is above edge of status bar
P:3C7A3::if so, don't do it
P:3C7A5::otherwise, set new vertical position, make bloober swim
P:3C7A7:SwimX:check moving direction
P:3C7AA::if moving to the left, branch to second part
P:3C7AE::add movement speed to horizontal coordinate
P:3C7B1::store result as new horizontal coordinate
P:3C7B5::add carry to page location
P:3C7B7::store as new page location and leave
P:3C7BA:LeftSwim
P:3C7BC::subtract movement speed from horizontal coordinate
P:3C7BF::store result as new horizontal coordinate
P:3C7C3::subtract borrow from page location
P:3C7C5::store as new page location and leave
P:3C7C8:MoveDefeatedBloober:jump to move defeated bloober downwards
P:3C7CB:ProcSwimmingB:get enemy's movement counter
P:3C7CD::check for d1 set
P:3C7CF::branch if set
P:3C7D3::get 3 LSB of frame counter
P:3C7D5::and save it to the stack
P:3C7D6::get enemy's movement counter
P:3C7D8::check for d0 set
P:3C7D9::branch if set
P:3C7DB::pull 3 LSB of frame counter from the stack
P:3C7DC::branch to leave, execute code only every eighth frame
P:3C7E1::add to movement force to speed up swim
P:3C7E4::set movement force
P:3C7E7::set as movement speed
P:3C7EB::if certain horizontal speed, branch to leave
P:3C7ED::otherwise increment movement counter
P:3C7EF:BSwimE
P:3C7F0:SlowSwim:pull 3 LSB of frame counter from the stack
P:3C7F1::branch to leave, execute code only every eighth frame
P:3C7F6::subtract from movement force to slow swim
P:3C7F9::set movement force
P:3C7FC::set as movement speed
P:3C7FE::if any speed, branch to leave
P:3C800::otherwise increment movement counter
P:3C804::set enemy's timer
P:3C807:NoSSw:leave
P:3C808:ChkForFloatdown:get enemy timer
P:3C80B::branch if expired
P:3C80D:Floatdown:get frame counter
P:3C80F::check for d0 set
P:3C810::branch to leave on every other frame
P:3C812::otherwise increment vertical coordinate
P:3C814:NoFD:leave
P:3C815:ChkNearPlayer:get vertical coordinate
P:3C817::add sixteen pixels (NTSC) or twelve pixels (PAL).
P:3C819::compare result with player's vertical coordinate
P:3C81B::if modified vertical less than player's, branch
P:3C81F::otherwise nullify movement counter
P:3C822:SwimCCXMoveData:--------------------------------\n--------------------------------\n$02 - used to hold preset values\n$03 - used to hold enemy state
P:3C824:MoveSwimmingCheepCheep:.db $04, $04 ;residual data, not used\ncheck cheep-cheep's enemy object state
P:3C826::for d5 set
P:3C828::if not set, continue with movement code
P:3C82A::otherwise jump to move defeated cheep-cheep downwards
P:3C82D:CCSwim:save enemy state in $03
P:3C82F::get enemy identifier
P:3C832::subtract ten for cheep-cheep identifiers
P:3C834::use as offset
P:3C835::load value here
P:3C840::load horizontal force
P:3C844::subtract preset value from horizontal force
P:3C846::store as new horizontal force
P:3C849::get horizontal coordinate
P:3C84B::subtract borrow (thus moving it slowly)
P:3C84D::and save as new horizontal coordinate
P:3C851::subtract borrow again, this time from the
P:3C853::page location, then save
P:3C858::load horizontal force
P:3C85C::subtract preset value from horizontal force
P:3C85E::store as new horizontal force
P:3C861::get horizontal coordinate
P:3C863::subtract borrow (thus moving it slowly)
P:3C865::and save as new horizontal coordinate
P:3C869::subtract borrow again, this time from the
P:3C86B::page location, then save
P:3C86F::save new value here
P:3C871::check enemy object offset
P:3C873::if in first or second slot, branch to leave
P:3C875::check movement flag
P:3C877::if movement speed set to $00,
P:3C879::branch to move upwards
P:3C87F::add preset value to dummy variable to get carry
P:3C881::and save dummy
P:3C884::get vertical coordinate
P:3C886::add carry to it plus enemy state to slowly move it downwards
P:3C888::save as new vertical coordinate
P:3C88C::add carry to page location and
P:3C88E::jump to end of movement code
P:3C891:CCSwimUpwards
P:3C895::subtract preset value to dummy variable to get borrow
P:3C897::and save dummy
P:3C89A::get vertical coordinate
P:3C89C::subtract borrow to it plus enemy state to slowly move it upwards
P:3C89E::save as new vertical coordinate
P:3C8A2::subtract borrow from page location
P:3C8A4:ChkSwimYPos:save new page location here
P:3C8A6::load movement speed to upwards by default
P:3C8A8::get vertical coordinate
P:3C8AB::subtract original coordinate from current
P:3C8AE::if result positive, skip to next part
P:3C8B0::otherwise load movement speed to downwards
P:3C8B4::get two's compliment of result
P:3C8B5::to obtain total difference of original vs. current
P:3C8B7:YPDiff:if difference between original vs. current vertical
P:3C8B9::coordinates < 15 pixels, leave movement speed alone
P:3C8BC::otherwise change movement speed
P:3C8BE:ExSwCC:leave
P:3C8BF:SkipFBar1:--------------------------------\n$00 - used as counter for firebar parts\n$01 - used for oscillated high byte of spin state or to hold horizontal adder\n$02 - used for oscillated high byte of spin state or to hold vertical adder\n$03 - used for mirror data\n$04 - used to store player's sprite 1 X coordinate\n$05 - used to evaluate mirror data\n$06 - used to store either screen X coordinate or sprite data offset\n$07 - used to store screen Y coordinate\n$ed - used to hold maximum length of firebar\n$ef - used to hold high byte of spinstate\nhorizontal adder is at first byte + high byte of spinstate,\nvertical adder is same + 8 bytes, two's compliment\nif greater than $08 for proper oscillation
P:3C8C0:ProcFirebar:set A to add 1 byte in order to get enemy offset
P:3C8C2::set Y to put offscreen bits in Enemy_OffscreenBits
P:3C8C5::add contents of X to A to get
P:3C8C6::appropriate offset, then give back to X
P:3C8C9::save offscreen bits offset to stack for now
P:3C8CB::do subroutine here
P:3C8D2::store here
P:3C8DB::mask together with previously saved low nybble
P:3C8DD::store both here
P:3C8DF::get offscreen bits offset from stack
P:3C8E1::get value here and store elsewhere
P:3C8E8::check for d3 set
P:3C8EB::if so, branch to leave
P:3C8EF::if master timer control set, branch
P:3C8F2::ahead of this part
P:3C8F4::load spinning speed of firebar
P:3C8F7::save spinning speed here
P:3C8F9::check spinning direction
P:3C8FB::if moving counter-clockwise, branch to other part
P:3C8FF::add spinning speed to what would normally be
P:3C900::the horizontal speed
P:3C904::add carry to what would normally be the vertical speed
P:3C90D::subtract spinning speed to what would normally be
P:3C90E::the horizontal speed
P:3C912::add carry to what would normally be the vertical speed
P:3C916::mask out all but 5 LSB
P:3C918::and store as new high byte of spinstate
P:3C91A:SusFbar:get high byte of spinstate
P:3C91C::check enemy identifier
P:3C920::if < $1f (long firebar), branch
P:3C922::check high byte of spinstate
P:3C924::if eight, branch to change
P:3C928::if not at twenty-four branch to not change
P:3C92A:SkpFSte
P:3C92B::add one to spinning thing to avoid horizontal state
P:3C92F:SetupGFB:save high byte of spinning thing, modified or otherwise
P:3C931::get coordinates of enemy object 
P:3C933::relative to the screen
P:3C934::store value to add to A here
P:3C937::add A to value stored
P:3C939::use as enemy offset
P:3C93A::load vertical coordinate low
P:3C93C::store here
P:3C93F::load horizontal coordinate
P:3C941::subtract left edge coordinate
P:3C945::store result here
P:3C948::reload old object offset and leave
P:3C94A::jsr GetFirebarPosition     ;do a sub here (residual, too early to be used now)\nget OAM data offset
P:3C94D::get relative vertical coordinate
P:3C950::store as Y in OAM data
P:3C953::also save here
P:3C955::get relative horizontal coordinate
P:3C958::store as X in OAM data
P:3C95B::also save here
P:3C95D::lda #$01\nsta $00                     ;set $01 value here (not necessary)\ndraw fireball part and do collision detection
P:3C960::load value for short firebars by default
P:3C964::are we doing a long firebar?
P:3C966::no, branch then
P:3C968::otherwise load value for long firebars
P:3C96A:SetMFbar:store maximum value for length of firebars
P:3C96E::initialize counter here
P:3C970:DrawFbar:load high byte of spinstate
P:3C972::save high byte of spinstate to the stack
P:3C973::mask out low nybble
P:3C977::if lower than $09, branch ahead
P:3C979::otherwise get two's compliment to oscillate
P:3C97E::store result, modified or not, here
P:3C980::load number of firebar ball where we're at
P:3C982::load offset to firebar position data
P:3C986::add oscillated high byte of spinstate
P:3C988::to offset here and use as new offset
P:3C989::get data here and store as horizontal adder
P:3C98E::pull whatever was in A from the stack
P:3C98F::save it again because we still need it
P:3C991::add eight this time, to get vertical adder
P:3C993::mask out high nybble
P:3C995::if lower than $09, branch ahead
P:3C999::otherwise get two's compliment
P:3C99E::store result here
P:3C9A2::load offset to firebar position data again
P:3C9A6::this time add value in $02 to offset here and use as offset
P:3C9A9::get data here and store as vertica adder
P:3C9AE::pull out whatever was in A one last time
P:3C9AF::divide by eight or shift three to the right
P:3C9B2::use as offset
P:3C9B3::load mirroring data here
P:3C9B8::position it properly, draw it and do collision detection
P:3C9BB::check which firebar part
P:3C9C1::if we arrive at fifth firebar part,
P:3C9C4::get offset from long firebar and load OAM data offset
P:3C9C7::using long firebar offset, then store as new one here
P:3C9C9:NextFbar:move onto the next firebar part
P:3C9CD::if we end up at the maximum part, go on and leave
P:3C9CF::otherwise go back and do another
P:3C9D1:SkipFBar
P:3C9D2:DrawFirebar_Collision:store mirror data elsewhere
P:3C9D6::load OAM data offset for firebar
P:3C9D8::load horizontal adder we got from position loader
P:3C9DA::shift LSB of mirror data
P:3C9DC::if carry was set, skip this part
P:3C9E0::otherwise get two's compliment of horizontal adder
P:3C9E2:AddHA:add horizontal coordinate relative to screen to
P:3C9E3::horizontal adder, modified or otherwise
P:3C9E6::store as X coordinate here
P:3C9E9::store here for now, note offset is saved in Y still
P:3C9EB::compare X coordinate of sprite to original X of firebar
P:3C9EE::if sprite coordinate => original coordinate, branch
P:3C9F3::otherwise subtract sprite X from the
P:3C9F4::original one and skip this part
P:3C9F9:NoColFB1
P:3C9FC:SubtR1:subtract original X from the
P:3C9FD::current sprite X
P:3CA00:ChkFOfs:if difference of coordinates within a certain range,
P:3CA02::continue by handling vertical adder
P:3CA04::otherwise, load offscreen Y coordinate
P:3CA06::and unconditionally branch to move sprite offscreen
P:3CA08:VAHandl:if vertical relative coordinate offscreen,
P:3CA0B::skip ahead of this part and write into sprite Y coordinate
P:3CA0F::load vertical adder we got from position loader
P:3CA11::shift LSB of mirror data one more time
P:3CA13::if carry was set, skip this part
P:3CA17::otherwise get two's compliment of second part
P:3CA19:AddVA:add vertical coordinate relative to screen to 
P:3CA1A::the second data, modified or otherwise
P:3CA1D:SetVFbr:store as Y coordinate here
P:3CA20::also store here for now
P:3CA22:FirebarCollision:get frame counter
P:3CA24::divide by four
P:3CA26::save result to stack
P:3CA27::mask out all but last bit
P:3CA29::set either tile $64 or $65 as fireball tile
P:3CA2B::thus tile changes every four frames
P:3CA2E::get from stack
P:3CA2F::divide by four again
P:3CA31::load value $02 to set palette in attrib byte
P:3CA33::if last bit shifted out was not set, skip this
P:3CA35::otherwise flip both ways every eight frames
P:3CA37::store attribute byte and leave
P:3CA3A::return OAM data offset and save
P:3CA3B::to the stack for now
P:3CA51::if star mario invincibility timer
P:3CA56::or master timer controls set
P:3CA59::then skip all of this
P:3CA5B::otherwise initialize counter
P:3CA5F::if player's vertical high byte offscreen,
P:3CA60::skip all of this
P:3CA62::get player's vertical position
P:3CA64::get player's size
P:3CA67::if player small, branch to alter variables
P:3CA6C::if player big and not crouching, jump ahead
P:3CA6E:AdjSm:if small or big but crouching, execute this part
P:3CA70::first increment our counter twice (setting $02 as flag)
P:3CA73::then add 24 pixels to the player's
P:3CA74::vertical coordinate
P:3CA77:BigJp:get vertical coordinate, altered or otherwise, from Y
P:3CA78:FBCLoop:subtract vertical position of firebar
P:3CA79::from the vertical coordinate of the player
P:3CA7B::if player lower on the screen than firebar, 
P:3CA7D::skip two's compliment part
P:3CA7F::otherwise get two's compliment
P:3CA82:ChkVFBD:if difference => 8 pixels, skip ahead of this part
P:3CA86::if firebar on far right on the screen, skip this,
P:3CA88::because, really, what's the point?
P:3CA8C::get OAM X coordinate for sprite #1
P:3CA90::add four pixels
P:3CA92::store here
P:3CA94::subtract horizontal coordinate of firebar
P:3CA95::from the X coordinate of player's sprite 1
P:3CA97::if modded X coordinate to the right of firebar
P:3CA99::skip two's compliment part
P:3CA9B::otherwise get two's compliment
P:3CA9E:ChkFBCl:if difference < 8 pixels, collision, thus branch
P:3CAA0::to process
P:3CAA2:Chk2Ofs:if value of $02 was set earlier for whatever reason,
P:3CAA4::branch to increment OAM offset and leave, no collision
P:3CAA8::otherwise get temp here and use as offset
P:3CAAD::add value loaded with offset to player's vertical coordinate
P:3CAB0::then increment temp and jump back
P:3CAB5:ChgSDir:set movement direction by default
P:3CAB7::if OAM X coordinate of player's sprite 1
P:3CAB9::is greater than horizontal coordinate of firebar
P:3CABB::then do not alter movement direction
P:3CABD::otherwise increment it
P:3CABE:SetSDir:store movement direction here
P:3CAC2::save value written to $00 to stack
P:3CAC5::perform sub to hurt or kill player
P:3CAC9::get value of $00 from stack
P:3CACB:NoColFB:get OAM data offset
P:3CACC::add four to it and save
P:3CAD1::get enemy object buffer offset and leave
P:3CAD4:PRandomSubtracter:--------------------------------
P:3CAD9:FlyCCBPriority
P:3CADE:SetLSpd2:--------------------------------\n$00 - used to hold horizontal difference\n$01-$03 - used to hold difference adjusters
P:3CAE1:MoveLakitu:check lakitu's enemy state
P:3CAE3::for d5 set
P:3CAE5::if not set, continue with code
P:3CAE7::otherwise jump to move defeated lakitu downwards
P:3CAEA:ChkLS:if lakitu's enemy state not set at all,
P:3CAEC::go ahead and continue with code
P:3CAF0::otherwise initialize moving direction to move to left
P:3CAF2::initialize frenzy buffer
P:3CAF7::load horizontal speed and do unconditional branch
P:3CAF9:Fr12S
P:3CAFB::set spiny identifier in frenzy buffer
P:3CB00:LdLDa:load values
P:3CB03::store in zero page
P:3CB07::do this until all values are stired
P:3CB09::execute sub to set speed and create spinys
P:3CB89:SetLSpd:set movement speed returned from sub
P:3CB8B::set moving direction to right by default
P:3CB8F::get LSB of moving direction
P:3CB91::if set, branch to the end to use moving direction
P:3CB95::get two's compliment of moving speed
P:3CB9A::store as new moving speed
P:3CB9C::increment moving direction to left
P:3CB9D:SetLMov:store moving direction
P:3CB9F::move lakitu horizontally
P:3CBA2:PlayerLakituDiff:set Y for default value
P:3CBA4::get horizontal difference between enemy and player
P:3CBA7::branch if enemy is to the right of the player
P:3CBA9::increment Y for left of player
P:3CBAD::get two's compliment of low byte of horizontal difference
P:3CBB0::store two's compliment as horizontal difference
P:3CBB4:ChkLakDif:get low byte of horizontal difference
P:3CBB6::if within a certain distance of player, branch
P:3CBBA::otherwise set maximum distance
P:3CBBE::check if lakitu is in our current enemy slot
P:3CBC2::if not, branch elsewhere
P:3CBC4::compare contents of Y, now in A
P:3CBC5::to what is being used as horizontal movement direction
P:3CBC7::if moving toward the player, branch, do not alter
P:3CBC9::if moving to the left beyond maximum distance,
P:3CBCB::branch and alter without delay
P:3CBD5::if horizontal speed not yet at zero, branch to leave
P:3CBD9:SetLMovD:set horizontal direction depending on horizontal
P:3CBDA::difference between enemy and player if necessary
P:3CBDC:ChkPSpeed
P:3CBDE::mask out all but four bits in the middle
P:3CBE0::divide masked difference by four
P:3CBE2::store as new value
P:3CBE4::init offset
P:3CBE8::if player not moving horizontally, branch
P:3CBED::if scroll speed not set, branch to same place
P:3CBEF::otherwise increment offset
P:3CBF2::if player not running, branch
P:3CBF9::if scroll speed below a certain amount, branch
P:3CBFB::to same place
P:3CBFD::otherwise increment once more
P:3CBFE:ChkSpinyO:check for spiny object
P:3CC02::branch if not found
P:3CC04::if player not moving, skip this part
P:3CC08:ChkEmySpd:check vertical speed
P:3CC0A::branch if nonzero
P:3CC0C::otherwise reinit offset
P:3CC0E:SubDifAdj:get one of three saved values from earlier
P:3CC11::get saved horizontal difference
P:3CC13:SPixelLak:subtract one for each pixel of horizontal difference
P:3CC14::from one of three saved values
P:3CC17::branch until all pixels are subtracted, to adjust difference
P:3CC19:ExMoveLak:leave!!!
P:3CC1A:BridgeCollapse:-------------------------------------------------------------------------------------\n$04-$05 - used to store name table address in little endian order\nget enemy offset for bowser
P:3CC1D::check enemy object identifier for bowser
P:3CC1F::if not found, branch ahead,
P:3CC21::metatile removal not necessary
P:3CC23::store as enemy offset here
P:3CC25::if bowser in normal state, skip all of this
P:3CC29::if bowser's state has d6 clear, skip to silence music
P:3CC2D::check bowser's vertical coordinate
P:3CC2F::if bowser not yet low enough, skip this part ahead
P:3CC33:SetM2:silence music
P:3CC37::move onto next secondary mode in autoctrl mode
P:3CC3A::jump to empty all enemy slots and then leave  
P:3CC3D:MoveD_Bowser:do a sub to move bowser downwards
P:3CC40::jump to draw bowser's front and rear, then leave
P:3CC43:RemoveBridge:decrement timer to control bowser's feet
P:3CC46::if not expired, skip all of this
P:3CC4A::otherwise, set timer now
P:3CC50::invert bit to control bowser's feet
P:3CC55::put high byte of name table address here for now
P:3CC59::get bridge collapse offset here
P:3CC5C::load low byte of name table address and store here
P:3CC61::increment vram buffer offset
P:3CC65::set offset for tile data for sub to draw blank metatile
P:3CC67::do sub here to remove bowser's bridge metatiles
P:3CC6A::get enemy offset
P:3CC6C::set new vram buffer offset
P:3CC6F::load the fireworks/gunfire sound into the square 2 sfx
P:3CC71::queue while at the same time loading the brick
P:3CC73::shatter sound into the noise sfx queue thus
P:3CC75::producing the unique sound of the bridge collapsing 
P:3CC77::increment bridge collapse offset
P:3CC7D::if bridge collapse offset has not yet reached
P:3CC7F::the end, go ahead and skip this part
P:3CC81::initialize vertical speed
P:3CC83::and movement force
P:3CC85::initialize whatever vertical speed bowser has
P:3CC8A::set bowser's state to one of defeated states (d6 set)
P:3CC8E::play bowser defeat sound
P:3CC90:NoBFall:jump to code that draws bowser
P:3CC93:PRandomRange:--------------------------------
P:3CC97:RunBowser:if d5 in enemy state is not set
P:3CC99::then branch elsewhere to run bowser
P:3CC9D::otherwise check vertical position
P:3CC9F::if above a certain point, branch to move defeated bowser
P:3CCA1::otherwise proceed to KillAllEnemies
P:3CCA3:KillAllEnemies:start with last enemy slot
P:3CCA5:KillLoop
P:3CCAF::branch to kill enemy objects
P:3CCB2::move onto next enemy slot
P:3CCB3::do this until all slots are emptied
P:3CCB5::empty frenzy buffer
P:3CCB8::get enemy object offset and leave
P:3CCBB:KillAllEnemiesNoFlag:start with last enemy slot
P:3CCC3::branch to kill enemy objects
P:3CCC6::move onto next enemy slot
P:3CCC7::do this until all slots are emptied
P:3CCC9::empty frenzy buffer
P:3CCCC::get enemy object offset and leave
P:3CCCF:BowserControl
P:3CCD1::empty frenzy buffer
P:3CCD4::if master timer control not set,
P:3CCD7::skip jump and execute code here
P:3CCD9::otherwise, jump over a bunch of code
P:3CCDC:ChkMouth:check bowser's mouth
P:3CCDF::if bit clear, go ahead with code here
P:3CCE1::otherwise skip a whole section starting here
P:3CCE4:FeetTmr:decrement timer to control bowser's feet
P:3CCE7::if not expired, skip this part
P:3CCE9::otherwise, reset timer
P:3CCEE::and invert bit used
P:3CCF1::to control bowser's feet
P:3CCF6:ResetMDr:check frame counter
P:3CCF8::if not on every sixteenth frame, skip
P:3CCFA::ahead to continue code
P:3CCFC::otherwise reset moving/facing direction every
P:3CCFE::sixteen frames
P:3CD00:B_FaceP:if timer set here expired,
P:3CD03::branch to next section
P:3CD05::get distance between enemy object's
P:3CD07::horizontal coordinate and the player's
P:3CD08::horizontal coordinate
P:3CD0A::and store here
P:3CD0E::subtract borrow, then leave
P:3CD10::and branch if bowser to the right of the player
P:3CD14::set bowser to move and face to the right
P:3CD18::set movement speed
P:3CD1D::set timer here
P:3CD20::set timer used for bowser's flame
P:3CD25::if bowser to the right past a certain point,
P:3CD27::skip ahead to some other section
P:3CD29:GetPRCmp:get frame counter
P:3CD2D::execute this code every fourth frame, otherwise branch
P:3CD31::if bowser not at original horizontal position,
P:3CD34::branch to skip this part
P:3CD39::get pseudorandom offset
P:3CD3C::load value using pseudorandom offset
P:3CD3F::and store here
P:3CD42:GetDToO
P:3CD49::add movement speed to bowser's horizontal
P:3CD4A::coordinate and save as new horizontal position
P:3CD51::if bowser moving and facing to the right, skip ahead
P:3CD55::set default movement speed here (move left)
P:3CD57::get difference of current vs. original
P:3CD58::horizontal position
P:3CD5B::if current position to the right of original, skip ahead
P:3CD5F::get two's compliment
P:3CD62::set alternate movement speed here (move right)
P:3CD64:CompDToO:compare difference with pseudorandom value
P:3CD67::if difference < pseudorandom value, leave speed alone
P:3CD69::otherwise change bowser's movement speed
P:3CD6C:HammerChk:if timer set here not expired yet, skip ahead to
P:3CD6F::some other section of code
P:3CD71::otherwise start by moving bowser downwards
P:3CD74::check world number
P:3CD79::if world 1-5, skip this part (not time to throw hammers yet)
P:3CD7D::check to see if it's time to execute sub
P:3CD7F::if not, skip sub, otherwise
P:3CD81::execute sub on every fourth frame to spawn misc object (hammer)
P:3CD84:SetHmrTmr
P:3CD89::then skip to world number check for flames
P:3CDA2::ora #%00000001
P:3CDA7::get pseudorandom offset
P:3CDAA::get value using pseudorandom offset
P:3CDAD::set for timer here
P:3CDB0:SkipToFB:jump to execute flames code
P:3CDB3:MakeBJump:if timer not yet about to expire,
P:3CDB5::skip ahead to next part
P:3CDB7::otherwise decrement vertical coordinate
P:3CDB9::initialize vertical speed
P:3CDBB::and movement force
P:3CDBD::initialize movement amount
P:3CDC2::set vertical speed to move bowser upwards
P:3CDC4:ChkFireB:check world number here
P:3CDC7::world 8?
P:3CDC9::if so, execute this part here
P:3CDCB::world 6-7?
P:3CDCD::if so, skip this part here
P:3CDCF:SpawnFBr:check timer here
P:3CDD2::if not expired yet, skip all of this
P:3CDD6::set timer here
P:3CDDC::invert bowser's mouth bit to open
P:3CDDE::and close bowser's mouth
P:3CDE1::if bowser's mouth open, loop back
P:3CDE3::get timing for bowser's flame
P:3CDE9::if secondary hard mode flag not set, skip this
P:3CDEC::otherwise subtract from value in A
P:3CDEE:SetFBTmr:set value as timer here
P:3CDF1::put bowser's flame identifier
P:3CDF3::in enemy frenzy buffer
P:3CDF6:BowserGfxHandler:--------------------------------\ndo a sub here to process bowser's front
P:3CDF9::load default value here to position bowser's rear
P:3CDFB::check moving direction
P:3CDFE::if moving left, use default
P:3CE00::otherwise load alternate positioning value here
P:3CE02:CopyFToR:move bowser's rear object position value to A
P:3CE04::add to bowser's front object horizontal coordinate
P:3CE09::store A as bowser's rear horizontal coordinate
P:3CE0E::add eight pixels to bowser's front object
P:3CE0F::vertical coordinate and store as vertical coordinate
P:3CE11::for bowser's rear
P:3CE16::copy enemy state directly from front to rear
P:3CE1B::copy moving direction also
P:3CE1E::save enemy object offset of front to stack
P:3CE21::put enemy object offset of rear as current
P:3CE26::set bowser's enemy identifier
P:3CE28::store in bowser's rear object
P:3CE2A::do a sub here to process bowser's rear
P:3CE2E::get original enemy object offset
P:3CE31::nullify bowser's front/rear graphics flag
P:3CE36:ExBGfxH:leave!
P:3CE37:ProcessBowserHalf:increment bowser's graphics flag, then run subroutines
P:3CE3A::to get offscreen bits, relative position and draw bowser (finally!)
P:3CE3F::if either enemy object not in normal state, branch to leave
P:3CE43::set bounding box size control
P:3CE46::get bounding box coordinates
P:3CE49::do player-to-enemy collision detection
P:3CE4C:FlameTimerData:-------------------------------------------------------------------------------------\n$00 - used to hold movement force and tile number\n$01 - used to hold sprite attribute data
P:3CE54:SetFlameTimer:load counter as offset
P:3CE57::increment
P:3CE5A::mask out all but 3 LSB
P:3CE5D::to keep in range of 0-7
P:3CE62::load value to be used then leave
P:3CE65:ExFl
P:3CE66:FlameYPosData1
P:3CE6A:ProcBowserFlame:if master timer control flag set,
P:3CE6D::skip all of this
P:3CE6F::load default movement force
P:3CE74::if secondary hard mode flag not set, use default
P:3CE76::otherwise load alternate movement force to go faster
P:3CE78:SFlmX:store value here
P:3CE7D::subtract value from movement force
P:3CE80::save new value
P:3CE85::subtract one from horizontal position to move
P:3CE87::to the left
P:3CE8B::subtract borrow from page location
P:3CE8F::get some value here and use as offset
P:3CE92::load vertical coordinate
P:3CE94::compare against coordinate data using $0417,x as offset
P:3CE97::if equal, branch and do not modify coordinate
P:3CE9A::otherwise add value here to coordinate and store
P:3CE9D::as new vertical coordinate
P:3CE9F:SetGfxF:get new relative coordinates
P:3CEA2::if bowser's flame not in normal state,
P:3CEA4::branch to leave
P:3CEA6::otherwise, continue
P:3CEA8::write first tile number
P:3CEAA::load attributes without vertical flip by default
P:3CEAE::invert vertical flip bit every 2 frames
P:3CEB0::if d1 not set, write default value
P:3CEB2::otherwise write value with vertical flip bit set
P:3CEB4:FlmeAt:set bowser's flame sprite attributes here
P:3CEB6::get OAM data offset
P:3CEBB:DrawFlameLoop:get Y relative coordinate of current enemy object
P:3CEBE::write into Y coordinate of OAM data
P:3CEC3::write current tile number into OAM data
P:3CEC6::increment tile number to draw more bowser's flame
P:3CECA::write saved attributes into OAM data
P:3CED0::write X relative coordinate of current enemy object
P:3CED6::then add eight to it and store
P:3CEDC::increment Y four times to move onto the next OAM
P:3CEDD::move onto the next OAM, and branch if three
P:3CEDE::have not yet been done
P:3CEE2::reload original enemy offset
P:3CEE4::get offscreen information
P:3CEE7::get OAM data offset
P:3CEEA::get enemy object offscreen bits
P:3CEED::move d0 to carry and result to stack
P:3CEEF::branch if carry not set
P:3CEF1::otherwise move sprite offscreen, this part likely
P:3CEF3::residual since flame is only made of three sprites
P:3CEF6:M3FOfs:get bits from stack
P:3CEF7::move d1 to carry and move bits back to stack
P:3CEF9::branch if carry not set again
P:3CEFB::otherwise move third sprite offscreen
P:3CF00:M2FOfs:get bits from stack again
P:3CF01::move d2 to carry and move bits back to stack again
P:3CF03::branch if carry not set yet again
P:3CF05::otherwise move second sprite offscreen
P:3CF0A:M1FOfs:get bits from stack one last time
P:3CF0B::move d3 to carry
P:3CF0C::branch if carry not set one last time
P:3CF10::otherwise move first sprite offscreen
P:3CF13:ExFlmeD:leave
P:3CF14:RunFireworks:--------------------------------\ndecrement explosion timing counter here
P:3CF17::if not expired, skip this part
P:3CF1B::reset counter
P:3CF1E::increment explosion graphics counter
P:3CF22::check explosion graphics counter
P:3CF24::if at a certain point, branch to kill this object
P:3CF26:SetupExpl:get relative coordinates of explosion
P:3CF29::copy relative coordinates
P:3CF2C::from the enemy object to the fireball object
P:3CF2F::first vertical, then horizontal
P:3CF35::get OAM data offset
P:3CF38::get explosion graphics counter
P:3CF3A::do a sub to draw the explosion then leave
P:3CF3D:FireworksSoundScore:disable enemy buffer flag
P:3CF41::play fireworks/gunfire sound
P:3CF45::set part of score modifier for 500 points
P:3CF4A::jump to award points accordingly then leave
P:3CF4D:StarFlagYPosAdder:--------------------------------
P:3CF51:StarFlagXPosAdder
P:3CF55:StarFlagTileData
P:3CF59:RunStarFlagObj:initialize enemy frenzy buffer
P:3CF5E::check star flag object task number here
P:3CF61::if greater than 5, branch to exit
P:3CF65::otherwise jump to appropriate sub
P:3CF6C:: This works pretty well to remove timer points count down
P:3CF72:GameTimerFireworks:set default state for star flag object
P:3CF74::get game timer's last digit
P:3CF79::if last digit of game timer set to 1, skip ahead
P:3CF7B::otherwise load new value for state
P:3CF7F::if last digit of game timer set to 3, skip ahead
P:3CF81::otherwise load one more potential value for state
P:3CF85::if last digit of game timer set to 6, skip ahead
P:3CF87::otherwise set value for no fireworks
P:3CF89:SetFWC:set fireworks counter here
P:3CF8C::set whatever state we have in star flag object
P:3CF8E:IncrementSFTask1:increment star flag object task number
P:3CF9B:StarFlagExit:jmp KillAllEnemiesNoFlag\nleave
P:3CF9C:Toyota2
P:3CF9E::set select timer (used for world 8 ending only)
P:3CFA3::another short delay, then on to the next task
P:3CFAA:AwardGameTimerPoints2
P:3CFAC::check all game timer digits for any intervals left
P:3CFB8::if no time left on game timer at all, branch to next task
P:3CFBD:AwardGameTimerPoints
P:3CFBF::check all game timer digits for any intervals left
P:3CFCB::if no time left on game timer at all, branch to next task
P:3CFCD:AwardTimerCastle
P:3CFCF::check frame counter for d2 set (skip ahead
P:3CFD1::for four frames every four frames) branch if not set
P:3CFDA::load timer tick sound
P:3CFDC:NoTTick:set offset here to subtract from game timer's last digit
P:3CFDE::set adder here to $ff, or -1, to subtract one
P:3CFE0::from the last digit of the game timer
P:3CFE5::subtract digit
P:3CFEA::set now to add 50 points
P:3CFF0::per game timer interval subtracted
P:3CFFB:EndAreaPoints:load offset for mario's score by default
P:3CFFD:ELPGive:award 50 points per game timer interval
P:3D000::add four to set nybble for game timer
P:3D002::jump to print the new score and game timer
P:3D005:RaiseFlagSetoffFWorks:lda Enemy_Y_Position,x  ;check star flag's vertical position\ncmp #$72                ;against preset value\nbcc SetoffF             ;if star flag higher vertically, branch to other code\ndec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel\njmp DrawStarFlag        ;and skip this part here\ncheck fireworks counter
P:3D005:SetoffF
P:3D008::if no fireworks left to go off, skip this part
P:3D00A::if no fireworks set to go off, skip this part
P:3D00E::otherwise set fireworks object in frenzy queue
P:3D011:DrawStarFlag
P:3D012:DSFLoop:jsr RelativeEnemyPosition  ;get relative coordinates of star flag\nldy Enemy_SprDataOffset,x  ;get OAM data offset\nldx #$03                   ;do four sprites\nlda Enemy_Rel_YPos         ;get relative vertical coordinate\nclc\nadc StarFlagYPosAdder,x    ;add Y coordinate adder data\nsta Sprite_Y_Position,y    ;store as Y coordinate\nlda StarFlagTileData,x     ;get tile number\nsta Sprite_Tilenumber,y    ;store as tile number\nlda #$22                   ;set palette and background priority bits\nsta Sprite_Attributes,y    ;store as attributes\nlda Enemy_Rel_XPos         ;get relative horizontal coordinate\nclc\nadc StarFlagXPosAdder,x    ;add X coordinate adder data\nsta Sprite_X_Position,y    ;store as X coordinate\niny\niny                        ;increment OAM data offset four bytes\niny                        ;for next sprite\niny\ndex                        ;move onto next sprite\nbpl DSFLoop                ;do this until all sprites are done\nldx ObjectOffset           ;get enemy object offset and leave\nrts\njsr DrawStarFlag          ;do sub to draw star flag
P:3D012:DrawFlagSetTimer
P:3D016::set interval timer here
P:3D019:IncrementSFTask2:move onto next task
P:3D01D:DelayToAreaEnd:jsr DrawStarFlag          ;do sub to draw star flag\nif interval timer set in previous task
P:3D020::not yet expired, branch to leave
P:3D02D::if event music buffer empty,
P:3D035:StarFlagExit2:jmp IncrementSFTask2      ;branch to increment task\notherwise leave
P:3D036:Player_Difference:--------------------------------\n$00 - used to store horizontal difference between player and piranha plant
P:3D038:MovePiranhaPlant:check enemy state
P:3D03A::if set at all, branch to leave
P:3D03C::check enemy's timer here
P:3D03F::branch to end if not yet expired
P:3D041::check movement flag
P:3D043::if moving, skip to part ahead
P:3D045::if currently rising, branch 
P:3D047::to move enemy upwards out of pipe
P:3D049::get distance between enemy object's
P:3D04B::horizontal coordinate and the player's
P:3D04C::horizontal coordinate
P:3D04E::and store here
P:3D052::subtract borrow, then leave
P:3D054::piranha plant, and branch if enemy to right of player
P:3D056::otherwise get saved horizontal difference
P:3D05A::and change to two's compliment
P:3D05D::save as new horizontal difference
P:3D05F:ChkPlayerNearPipe
P:3D06D::get saved horizontal difference
P:3D072::if player within a certain distance, branch to leave
P:3D074:ReversePlantSpeed:get vertical speed
P:3D078::change to two's compliment
P:3D07B::save as new vertical speed
P:3D07D::increment to set movement flag
P:3D07F:SetupToMovePPlant:get original vertical coordinate (lowest point)
P:3D082::get vertical speed
P:3D084::branch if moving downwards
P:3D086::otherwise get other vertical coordinate (highest point)
P:3D089:RiseFallPiranhaPlant:save vertical coordinate here
P:3D096::get frame counter
P:3D099::branch to leave if d0 set (execute code every other frame)
P:3D09B::get master timer control
P:3D09E::branch to leave if set (likely not necessary)
P:3D0A0::get current vertical coordinate
P:3D0A3::add vertical speed to move up or down
P:3D0A5::save as new vertical coordinate
P:3D0A7::compare against low or high coordinate
P:3D0A9::branch to leave if not yet reached
P:3D0AD::otherwise clear movement flag
P:3D0B1::set timer to delay piranha plant movement
P:3D0B4:PutinPipe:then leave
P:3D0B5:BalancePlatform:-------------------------------------------------------------------------------------\n$07 - spinning speed\n-------------------------------------------------------------------------------------\n$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope\n$01 - used to hold high byte of name table for rope\n$02 - used to hold page location of rope\ncheck high byte of vertical position
P:3D0BB::if far below screen, kill the object
P:3D0BE:DoBPl:get object's state (set to $ff or other platform offset)
P:3D0C0::if doing other balance platform, branch to leave
P:3D0C3:CheckBalPlatform:save offset from state as Y
P:3D0C4::get collision flag of platform
P:3D0C7::store here
P:3D0C9::get moving direction
P:3D0CD::if set, jump here
P:3D0D0:ChkForFall:check if platform is above a certain point
P:3D0D4::if not, branch elsewhere
P:3D0D6::if collision flag is set to same value as
P:3D0D8::enemy state, branch to make platforms fall
P:3D0DB::otherwise add 2 pixels to vertical position
P:3D0DD::of current platform and branch elsewhere
P:3D0DF::to make platforms stop
P:3D0E2:MakePlatformFall:make platforms fall
P:3D0E5:ChkOtherForFall:check if other platform is above a certain point
P:3D0E8::if not, branch elsewhere
P:3D0EA::if collision flag is set to same value as
P:3D0EC::enemy state, branch to make platforms fall
P:3D0EF::otherwise add 2 pixels to vertical position
P:3D0F1::of other platform and branch elsewhere
P:3D0F4::jump to stop movement and do not return
P:3D0F7:ChkToMoveBalPlat
P:3D0FA::save vertical position to stack
P:3D0FD::get collision flag
P:3D100::branch if collision
P:3D105::add $05 to contents of moveforce, whatever they be
P:3D108::store here
P:3D10C::add carry to vertical speed
P:3D10E::branch if moving downwards
P:3D110::branch elsewhere if moving upwards
P:3D114::check if there's still a little force left
P:3D116::if not enough, branch to stop movement
P:3D118::otherwise keep branch to move upwards
P:3D11A:ColFlg:if collision flag matches
P:3D11C::current enemy object offset, branch
P:3D11E:PlatUp:do a sub to move upwards
P:3D121::jump ahead to remaining code
P:3D124:PlatSt:do a sub to stop movement
P:3D127::jump ahead to remaining code
P:3D12A:PlatDn:do a sub to move downwards
P:3D12D:DoOtherPlatform:get offset of other platform
P:3D12F::get old vertical coordinate from stack
P:3D131::get difference of old vs. new coordinate
P:3D134::add difference to vertical coordinate of other
P:3D137::platform to move it in the opposite direction
P:3D13A::if no collision, skip this part here
P:3D13F::put offset which collision occurred here
P:3D140::and use it to position player accordingly
P:3D143:DrawEraseRope:get enemy object offset
P:3D145::check to see if current platform is
P:3D148::moving at all
P:3D14B::if not, skip all of this and branch to leave
P:3D14D::get vram buffer offset
P:3D150::if offset beyond a certain point, go ahead
P:3D152::and skip this, branch to leave
P:3D157::save two copies of vertical speed to stack
P:3D159::do a sub to figure out where to put new bg tiles
P:3D15C::write name table address to vram buffer
P:3D15E::first the high byte, then the low
P:3D166::set length for 2 bytes
P:3D16B::if platform moving upwards, branch 
P:3D16E::to do something else
P:3D172::otherwise put tile numbers for left
P:3D175::and right sides of rope in vram buffer
P:3D17A::jump to skip this part
P:3D17D:EraseR1:put blank tiles in vram buffer
P:3D17F::to erase rope
P:3D185:OtherRope:get offset of other platform from state
P:3D188::use as Y here
P:3D189::pull second copy of vertical speed from stack
P:3D18A::invert bits to reverse speed
P:3D18C::do sub again to figure out where to put bg tiles  
P:3D18F::write name table address to vram buffer
P:3D191::this time we're doing putting tiles for
P:3D194::the other platform
P:3D19B::set length again for 2 bytes
P:3D19E::pull first copy of vertical speed from stack
P:3D19F::if moving upwards (note inversion earlier), skip this
P:3D1A3::otherwise put tile numbers for left
P:3D1A6::and right sides of rope in vram
P:3D1A8::transfer buffer
P:3D1AB::jump to skip this part
P:3D1AE:EraseR2:put blank tiles in vram buffer
P:3D1B0::to erase rope
P:3D1B6:EndRp:put null terminator at the end
P:3D1BB::add ten bytes to the vram buffer offset
P:3D1BE::and store
P:3D1C4:ExitRp:get enemy object buffer offset and leave
P:3D1C7:SetupPlatformRope:save second/third copy to stack
P:3D1C8::get horizontal coordinate
P:3D1CC::add eight pixels
P:3D1CE::if secondary hard mode flag set,
P:3D1D1::use coordinate as-is
P:3D1D4::otherwise add sixteen more pixels
P:3D1D6:GetLRp:save modified horizontal coordinate to stack
P:3D1DA::add carry to page location
P:3D1DC::and save here
P:3D1DE::pull modified horizontal coordinate
P:3D1DF::from the stack, mask out low nybble
P:3D1E1::and shift three bits to the right
P:3D1E4::store result here as part of name table low byte
P:3D1E6::get vertical coordinate
P:3D1E8::get second/third copy of vertical speed from stack
P:3D1E9::skip this part if moving downwards or not at all
P:3D1ED::add eight to vertical coordinate and
P:3D1EF::save as X
P:3D1F0:GetHRp:move vertical coordinate to A
P:3D1F1::get vram buffer offset
P:3D1F5::rotate d7 to d0 and d6 into carry
P:3D1F6::save modified vertical coordinate to stack
P:3D1F7::rotate carry to d0, thus d7 and d6 are at 2 LSB
P:3D1F8::mask out all bits but d7 and d6, then set
P:3D1FA::d5 to get appropriate high byte of name table
P:3D1FC::address, then store
P:3D1FE::get saved page location from earlier
P:3D200::mask out all but LSB
P:3D203::shift twice to the left and save with the
P:3D204::rest of the bits of the high byte, to get
P:3D206::the proper name table and the right place on it
P:3D208::get modified vertical coordinate from stack
P:3D209::mask out low nybble and LSB of high nybble
P:3D20C::add to horizontal part saved here
P:3D20E::save as name table low byte
P:3D213::if vertical position not below the
P:3D215::bottom of the screen, we're done, branch to leave
P:3D219::mask out d6 of low byte of name table address
P:3D21D:ExPRp:leave!
P:3D21E:InitPlatformFall:move offset of other platform from Y to X
P:3D220::get offscreen bits
P:3D225::award 1000 points to player
P:3D22B::put floatey number coordinates where player is
P:3D233::set moving direction as flag for
P:3D235::falling platforms
P:3D237:StopPlatforms:initialize vertical speed
P:3D239::and movement force
P:3D23B::initialize vertical speed and low byte
P:3D23E::for both platforms and leave
P:3D245:PlatformFall:save offset for other platform to stack
P:3D247::make current platform fall
P:3D24B::pull offset from stack and save to X
P:3D24C::make other platform fall
P:3D251::if player not standing on either platform,
P:3D254::skip this part
P:3D256::transfer collision flag offset as offset to X
P:3D257::and position player appropriately
P:3D25A:ExPF:get enemy object buffer offset and leave
P:3D25D:YMovingPlatform:--------------------------------\nif platform moving up or down, skip ahead to
P:3D25F::check on other position
P:3D264::initialize dummy variable
P:3D269::if current vertical position => top position, branch
P:3D26C::ahead of all this
P:3D270::check for every eighth frame
P:3D274::increase vertical position every eighth frame
P:3D276:SkipIY:skip ahead to last part
P:3D279:ChkYCenterPos:if current vertical position < central position, branch
P:3D27B::to slow ascent/move downwards
P:3D27F::otherwise start slowing descent/moving upwards
P:3D285:YMDown:start slowing ascent/moving downwards
P:3D288:ChkYPCollision:if collision flag not set here, branch
P:3D28B::to leave
P:3D28D::otherwise position player appropriately
P:3D290:ExYPl:leave
P:3D291:XMovingPlatform:--------------------------------\n$00 - used as adder to position player horizontally\nload preset maximum value for secondary counter
P:3D293::do a sub to increment counters for movement
P:3D296::do a sub to move platform accordingly, and return value
P:3D299::if no collision with player,
P:3D29C::branch ahead to leave
P:3D29E:PositionPlayerOnHPlat
P:3D2AC::add saved value from second subroutine to
P:3D2AD::current player's position to position
P:3D2AF::player accordingly in horizontal position
P:3D2B1::get player's page location
P:3D2B3::check to see if saved value here is positive or negative
P:3D2B5::if negative, branch to subtract
P:3D2B7::otherwise add carry to page location
P:3D2B9::jump to skip subtraction
P:3D2BC:PPHSubt:subtract borrow from page location
P:3D2BE:SetPVar:save result to player's page location
P:3D2C0::put saved value from second sub here to be used later
P:3D2CF::position player vertically and appropriately
P:3D2D2:ExXMP:and we are done here
P:3D2D3:DropPlatform:--------------------------------\nif no collision between platform and player
P:3D2D6::occurred, just leave without moving anything
P:3D2D8::otherwise do a sub to move platform down very quickly
P:3D2DB::do a sub to position player appropriately
P:3D2DE:RightPlatform:--------------------------------\n$00 - residual value from sub\nincrement offset for enemy offset
P:3D2DF::position object horizontally according to
P:3D2E2::counters, return with saved value in A,
P:3D2E4::sta $00                       ;store saved value here (residual code)\ncheck collision flag, if no collision between player
P:3D2E7::and platform, branch ahead, leave speed unaltered
P:3D2EB::otherwise set new speed (gets moving if motionless)
P:3D2ED::use saved value from earlier sub to position player
P:3D2F0:MoveLargeLiftPlat:--------------------------------\nexecute common to all large and small lift platforms
P:3D2F3::branch to position player correctly
P:3D2F6:MoveSmallPlatform:execute common to all large and small lift platforms
P:3D2F9::branch to position player correctly
P:3D2FC:MoveLiftPlatforms:if master timer control set, skip all of this
P:3D2FF::and branch to leave
P:3D304::add contents of movement amount to whatever's here
P:3D30B::add whatever vertical speed is set to current
P:3D30D::vertical position plus carry to move up or down
P:3D30F::and then leave
P:3D312:ChkSmallPlatCollision:get bounding box counter saved in collision flag
P:3D315::if none found, leave player position alone
P:3D317::use to position player correctly
P:3D31A:ExLiftP:then leave
P:3D31B:OffscreenXoffset:-------------------------------------------------------------------------------------\n$00 - page location of extended left boundary\n$01 - extended left boundary position\n$02 - page location of extended right boundary\n$03 - extended right boundary position
P:3D31D:OffscreenBoundsCheck:check for cheep-cheep object
P:3D31F::branch to leave if found
P:3D32A::get horizontal coordinate for left side of screen
P:3D32E::subtract 72 pixels regardless of enemy object
P:3D331::store result here
P:3D336::subtract borrow from page location of left side
P:3D338::store result here
P:3D33A::add 72 pixels to the right side horizontal coordinate
P:3D341::store result here
P:3D346::then add the carry to the page location
P:3D348::and store result here
P:3D34A::compare horizontal coordinate of the enemy object
P:3D34C::to modified horizontal left edge coordinate to get carry
P:3D350::then subtract it from the page coordinate of the enemy object
P:3D352::if enemy object is too far left, branch to erase it
P:3D354::compare horizontal coordinate of the enemy object
P:3D356::to modified horizontal right edge coordinate to get carry
P:3D35A::then subtract it from the page coordinate of the enemy object
P:3D35C::if enemy object is on the screen, leave, do not erase enemy
P:3D35E:TooFar
P:3D36D::erase object if necessary
P:3D370:ExScrnBd:leave
P:3D371:ExitFBallEnemy2:get original fireball offset and leave
P:3D374:FireballEnemyCollision:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$01 - enemy buffer offset\ncheck to see if fireball state is set at all
P:3D376::branch to leave if not
P:3D378::branch to leave also if d7 in state is set
P:3D381::get LSB of frame counter
P:3D382::branch to leave if set (do routine every other frame)
P:3D385::multiply fireball offset by four
P:3D388::then add $1c or 28 bytes to it
P:3D38A::to use fireball's bounding box coordinates 
P:3D38D:FireballEnemyCDLoop:store enemy object offset here
P:3D390::push fireball offset to the stack
P:3D393::check to see if d5 is set in enemy state
P:3D395::if so, skip to next enemy slot
P:3D397::check to see if buffer flag is set
P:3D399::if not, skip to next enemy slot
P:3D39B::check enemy identifier
P:3D3AB::if < $24, branch to check further
P:3D3B3::if in range $24-$2a, skip to next enemy slot
P:3D3B5:GoombaDie:check for goomba identifier
P:3D3BB::if not found, continue with code
P:3D3BD::otherwise check for defeated state
P:3D3BF::if stomped or otherwise defeated,
P:3D3C1::skip to next enemy slot
P:3D3C3:NotGoomba:if any masked offscreen bits set,
P:3D3C6::skip to next enemy slot
P:3D3C9::otherwise multiply enemy offset by four
P:3D3CC::add 4 bytes to it
P:3D3CE::to use enemy's bounding box coordinates
P:3D3CF::do fireball-to-enemy collision detection
P:3D3D2::return fireball's original offset
P:3D3D4::if carry clear, no collision, thus do next enemy slot
P:3D3D8::set d7 in enemy state
P:3D3DA::get enemy offset
P:3D3DC::jump to handle fireball to enemy collision
P:3D3F8:NoFToECol
P:3D3FA::pull fireball offset from stack
P:3D3FB::put it in Y
P:3D3FC::get enemy object offset
P:3D3FE::decrement it
P:3D3FF::loop back until collision detection done on all enemies
P:3D401:ExitFBallEnemy:get original fireball offset and leave
P:3D403:testt
P:3D404:BowserIdentities
P:3D40C:ChkOtherEnemies1
P:3D40F:HandleEnemyFBallCol:get coordinates of enemy object 
P:3D412::store value to add to A here
P:3D415::add A to value stored
P:3D417::use as enemy offset
P:3D418::load vertical coordinate lo
P:3D41A::store here
P:3D41D::load horizontal coordinate
P:3D41F::subtract left edge coordinate
P:3D423::store result here
P:3D426::get current enemy object offset
P:3D428::check buffer flag for d7 set
P:3D42A::branch if not set to continue
P:3D42C::otherwise mask out high nybble and
P:3D42E::use low nybble as enemy offset
P:3D431::check enemy identifier for bowser
P:3D433::branch if found
P:3D435::otherwise retrieve current enemy offset
P:3D437:ChkBuzzyBeetle
P:3D439::check for buzzy beetle
P:3D43B::branch if found to leave (buzzy beetles fireproof)
P:3D43D::check for bowser one more time (necessary if d7 of flag was clear)
P:3D43F::if not found, branch to check other enemies
P:3D441:HurtBowser
P:3D47A::otherwise, check number of pts
P:3D47E::more than 9 pts?
P:3D482::if so, subtract 10 and add one to the 10s digit
P:3D485::instead of showing 100 pts, A0 will show, etc.
P:3D49F:testtt
P:3D4B5::if bowser still has hit points, branch to leave
P:3D4BC::initialize vertical speed
P:3D4BE::and movement force
P:3D4C3::initialize horizontal speed
P:3D4C5::init enemy frenzy buffer
P:3D4CA::set vertical speed to make defeated bowser jump a little
P:3D4CC::use world number as offset
P:3D4D2::get enemy identifier to replace bowser with
P:3D4D5::set as new enemy identifier
P:3D4D7::set A to use starting value for state
P:3D4D9::check to see if using offset of 3 or more
P:3D4DB::branch if so
P:3D4DD::otherwise add 3 to enemy state
P:3D4DF:SetDBSte:set defeated enemy state
P:3D4E3::load bowser defeat sound
P:3D4E5::       jsr SetupVictoryMode\n       lda #$03\n       sta OperMode_Task   ;secondary mode\n       lda #$02\n       sta OperMode        ;set primary mode to autoctrl mode\n        lda #$00\n        sta OperMode_Task   ;reset secondary mode\n        lda #$02\n        sta OperMode        ;set primary mode to autoctrl mode\n        lda #$18\n        sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile\nget enemy offset
P:3D4E7::award 5000 points to player for defeating bowser
P:3D4E9::unconditional branch to award points
P:3D4EB:ChkOtherEnemies
P:3D4ED::branch to leave if bullet bill (frenzy variant) 
P:3D4F1::branch to leave if podoboo
P:3D509::branch to leave if identifier => $15
P:3D50B:ShellOrBlockDefeat
P:3D516::check for piranha plant
P:3D52A::branch if not found
P:3D52F:StnE:do yet another sub
P:3D534::mask out 2 MSB of enemy object's state
P:3D536::set d5 to defeat enemy and save as new state
P:3D542::award 200 points by default
P:3D544::check for hammer bro
P:3D548::branch if not found
P:3D54A::award 1000 points for hammer bro
P:3D54C:GoombaPoints
P:3D550::check for goomba
P:3D556::branch if not found
P:3D558::award 100 points for goomba
P:3D55D:LakituPoints
P:3D564:EnemySmackScore
P:3D567::cpy #$00
P:3D56C:Her:set number of points control for floatey numbers
P:3D571::set timer for floatey numbers
P:3D576::set vertical coordinate
P:3D57C::set horizontal coordinate and leave
P:3D57F::play smack enemy sound
P:3D586:ExHCF:and now let's leave
P:3D587:StarCollisions:increment chain counter for additional enemies
P:3D58A::get chain counter for shell
P:3D597::set number of points control for floatey numbers
P:3D59C::set timer for floatey numbers
P:3D5A1::set vertical coordinate
P:3D5A7::set horizontal coordinate and leave
P:3D5AA::play smack enemy sound
P:3D5C7:PlayerHammerCollision:-------------------------------------------------------------------------------------\nget frame counter
P:3D5C9::shift d0 into carry
P:3D5CA::branch to leave if d0 not set to execute every other frame
P:3D5CC::if either master timer control
P:3D5CF::or any offscreen bits for hammer are set,
P:3D5D2::branch to leave
P:3D5D6::if not set to run player control routine
P:3D5D8::on next frame, branch to leave
P:3D5DB::multiply misc object offset by four
P:3D5DE::add 36 or $24 bytes to get proper offset
P:3D5E0::for misc object bounding box coordinates
P:3D5E1::do player-to-hammer collision detection
P:3D5E4::get misc object offset
P:3D5E6::if no collision, then branch
P:3D5E8::otherwise read collision flag
P:3D5EB::if collision flag already set, branch to leave
P:3D5EF::otherwise set collision flag now
P:3D5F4::get two's compliment of
P:3D5F6::hammer's horizontal speed
P:3D5F9::set to send hammer flying the opposite direction
P:3D5FB::if star mario invincibility timer set,
P:3D5FE::branch to leave
P:3D600::otherwise jump to hurt player, do not return
P:3D603:ClHCol:clear collision flag
P:3D608:ExPHC
P:3D609:HandlePowerUpCollision:-------------------------------------------------------------------------------------
P:3D60E::erase the power-up object
P:3D613::award 1000 points to player by default
P:3D618::if 1-up mushroom, do not play the power-up sound
P:3D61E::play the power-up sound
P:3D626::if mushroom or fire flower, branch
P:3D62A::if 1-up mushroom, branch               
P:3D639::into the area music queue, then leave
P:3D640::otherwise set star mario invincibility
P:3D643::timer, and load the star mario music
P:3D647:yee
P:3D649:Shroom_PUp
P:3D64C:Flower_PUp
P:3D653::set player status to fiery
P:3D65D::run sub to change colors of player
P:3D660::ldx ObjectOffset    ;get enemy offset again, and again not necessary\nset value to be used by subroutine tree (fiery)
P:3D662::jump to set values accordingly
P:3D665:SetFor1Up:change 1000 points into 1-up instead
P:3D667::and then leave
P:3D66A:NoPUp
P:3D66B:UpToSuper
P:3D670::set player status to super
P:3D675::set value to be used by subroutine tree (super)
P:3D677:UpToFiery:set value to be used as new player state
P:3D679::set values to stop certain things in motionrts
P:3D67C:KickedShellXSpdData:--------------------------------\n      .db $18, $e8
P:3D67C:ResidualXSpdData
P:3D67E:DemotedKoopaXSpdData
P:3D682:PlayerEnemyCollision:if player object is completely offscreen
P:3D685::vertically, leave this routine
P:3D689::if player high vertical byte is not
P:3D68E::if on the screen, check to see how far down
P:3D690::the player is vertically
P:3D692::if down past 224th pixel row, branch to leave
P:3D694::ldx ObjectOffset\nif current enemy is offscreen by any amount,
P:3D697::go ahead and branch to leave
P:3D69B::if not set to run player control routine
P:3D69D::on next frame, branch to leave
P:3D6A1::if enemy state has d5 set, branch to leave
P:3D6A5::get enemy object buffer offset
P:3D6A7::multiply A by four, then add four
P:3D6A8::to skip player's bounding box
P:3D6AC::send to Y
P:3D6AD::get offscreen bits for enemy object
P:3D6B0::save low nybble
P:3D6B2::check for all bits set
P:3D6B4::do collision detection on player vs. enemy
P:3D6B7::ldy $06                      ;otherwise return with carry clear and Y = $0006\nget enemy object buffer offset
P:3D6B9::if collision, branch past this part here
P:3D6BE::otherwise, clear d0 of current enemy object's
P:3D6C0::collision bit
P:3D6C3:NoPECol
P:3D6C4:CheckForPUpCollision
P:3D6C6::check for power-up object
P:3D6C8::if not found, branch to next part
P:3D6CA::otherwise, unconditional jump backwards
P:3D6CD:EColl:if star mario invincibility timer expired,
P:3D6D0::perform task here, otherwise kill enemy like
P:3D6E7::hit with a shell, or from beneath
P:3D701:KickedShellPtsData
P:3D704:ShellUp
P:3D709::sta GrabDown
P:3D716::set fireball cooldown to avoid killing it just after releasing it 
P:3D719::play smack enemy sound
P:3D71E:HandlePECollisions:branch to leave if either is true
P:3D73E::check enemy collision bits for d0 set
P:3D741::or for being offscreen at all
P:3D743::branch to leave if either is true
P:3D747::otherwise set d0 now
P:3D74D::branch if spiny
P:3D751::branch if invincible paratroopa
P:3D755::branch if piranha plant
P:3D769::branch if podoboo
P:3D76D::check if swimming or underwater level
P:3D772::branch if bloober
P:3D776::branch if grey cheep cheep
P:3D77A::branch if red cheep cheep
P:3D77E::branch if bullet bill
P:3D786::branch if object => $15
P:3D78A::branch if d7 of enemy state was set
P:3D78E::mask out all but 3 LSB of enemy state
P:3D792::branch if enemy is in normal or falling state
P:3D796::branch to leave if goomba or fast goomba in defeated state
P:3D7A8:Grab:check if B is pressed
P:3D7AC::branch if not
P:3D7B1::branch if grabflag is zero
P:3D7B6::compare current enemy offset with the grabbed enemy offset and branch if not equal
P:3D7B8::if grabflag zero and B pressed, set current enemy offset to grabbed offset
P:3D7C0:H
P:3D7C1:HandleSignInteraction
P:3D7C4:InjurePlayer2
P:3D7C7:ChkForPlayerInjury2
P:3D7D0::branch if grabflag is zero to kick it in the old way
P:3D7D2::lda Enemy_Y_Position,x\ncmp #$11\nbcc H\ndecrement to set grabflag to zero
P:3D7E1::check if DOWN is pressed
P:3D7E5::if so, put down shell gently
P:3D7EA::get player's facing direction
P:3D7F5:KickD:kick shell where player is facing
P:3D800::nullify enemy Y speed
P:3D804::set fireball cooldown to avoid killing the sell just after kicking it
P:3D807::load and set horizontal speed data with offset
P:3D80C::set d7 in enemy state, thus become moving shell
P:3D816::reset smack pitch
P:3D81F::play smack enemy sound
P:3D823::load and set horizontal speed data with offset
P:3D82D::add three to whatever the stomp counter contains
P:3D82F::to give points for kicking the shell
P:3D833::check shell enemy's timer
P:3D836::if above a certain point, branch using the points
P:3D838::data obtained from the stomp counter + 3
P:3D83A::otherwise, set points based on proximity to timer expiration
P:3D83D:KSPts:set values for floatey number now
P:3D840:ExPEC
P:3D841:GSLoop:load grab id
P:3D844::set enemy interval timer to avoid glitches
P:3D849::load player horizontal position
P:3D84B::load player facing dir
P:3D84E::branch if not zero
P:3D851::apparently this sometimes refuses to work correctly lmao
P:3D853::add $0b pixels if right
P:3D855::load player page loc
P:3D857::add 1 if horizontal position overflowed
P:3D859::store in enemy page loc
P:3D85E::subtract $0b pixels if left
P:3D863::load player page loc
P:3D865::subtract 1 if horizontal position underflowed
P:3D867::store in enemy page loc
P:3D86B::store player moving dir here
P:3D86F::nullify this so enemy can't hurt just after kicking it
P:3D872::load player vertical position
P:3D874::load crouching flag
P:3D877::branch if crouching
P:3D879::load player size
P:3D87C::branch if small
P:3D87F::subtract 7
P:3D88D::add 6
P:3D88F::set enemy vertical position
P:3D8A4:RShell
P:3D8A6::reset chain counter
P:3D8AA:ShellDown
P:3D8AC::set this
P:3D8AF::load player horizontal speed
P:3D8B1::store here
P:3D8B5::nullify enemy vertical speed
P:3D8B9::set fireball cooldown to avoid killing it just after releasing it 
P:3D8BD:KillPlayer:nullify grab flag, enemy pitch, was grabbed and old status
P:3D8D4::halt player's horizontal movement by initializing speed
P:3D8D7::set event music queue to death music
P:3D8DB::set new vertical speed
P:3D8DD::set subroutine to run on next frame
P:3D8DF::branch to set player's state and other things
P:3D8E1:InjurePlayer
P:3D8E8::check again to see if injured invincibility timer is
P:3D8EB::at zero, and branch to leave if so
P:3D8ED:ForceInjury:check player's status
P:3D8F0::branch if small
P:3D905::load player's status and store here
P:3D908::decrement player's status
P:3D90D::set injured invincibility timer
P:3D910::PAL version has lda #$10 here instead (either will work)
P:3D911::play pipedown/injury sound
P:3D913::change player's palette if necessary
P:3D916::set subroutine to run on next frame
P:3D918:SetKRout:set new player state
P:3D91A:SetPRout:load new value to run subroutine on next frame
P:3D91C::store new player state
P:3D920::set master timer control flag to halt timers
P:3D924::initialize scroll speed
P:3D927:ExInjColRoutines:get enemy offset and leave
P:3D92A:ChkForPlayerInjury:check player's vertical speed
P:3D92C::perform procedure below if player moving upwards
P:3D92E::or not at all, and branch elsewhere if moving downward
P:3D943:ChkInj:lda Player_State\nbne EnemyStomped\nPAL bugfix: Vertical difference deciding whether Mario stomped or got hit depends on the enemy\nbranch if enemy object < $07\nbranch if enemy object < $07
P:3D955::add 12 pixels to player's vertical position
P:3D95A::compare modified player's position to enemy's position
P:3D95C::branch if this player's position above (less than) enemy's
P:3D95E:ChkETmrs:check stomp timer
P:3D961::branch if set
P:3D963::check to see if injured invincibility timer still
P:3D966::counting down, and branch elsewhere to leave if so
P:3D96B::if player's relative position to the left of enemy's
P:3D96E::relative position, branch here
P:3D970::otherwise do a jump here
P:3D973:TInjE:if enemy moving towards the left,
P:3D975::branch, otherwise do a jump here
P:3D977::to turn the enemy around
P:3D97C:InjurePlayer3
P:3D97F:StompedEnemyPtsData
P:3D983:EnemyStomped:check for spiny, branch to hurt player
P:3D985::if found
P:3D996::otherwise play stomp/swim sound
P:3D99C::initialize points data offset for stomped enemies
P:3D99E::branch for cheep-cheep
P:3D9AA::branch for either bullet bill object
P:3D9B2::branch for podoboo (this branch is logically impossible
P:3D9B4::for cpu to take due to earlier checking of podoboo)
P:3D9B6::increment points data offset
P:3D9B7::branch for hammer bro
P:3D9BB::increment points data offset
P:3D9BC::branch for lakitu
P:3D9C0::increment points data offset
P:3D9C1::branch if NOT bloober
P:3D9C5:EnemyStompedPts:load points data using offset in Y
P:3D9C8::set number of points control for floatey numbers
P:3D9CD::set timer for floatey numbers
P:3D9D2::set vertical coordinate
P:3D9D8::set horizontal coordinate and leave
P:3D9DE:NormalPTS:increment the stomp counter
P:3D9E1::add whatever is in the stomp counter
P:3D9E5::apparently this sometimes refuses to work correctly lmao
P:3D9E8::set number of points control for floatey numbers
P:3D9ED::set timer for floatey numbers
P:3D9F2::set vertical coordinate
P:3D9F8::set horizontal coordinate and leave
P:3D9FB::increment stomp timer of some sort
P:3DA00::save enemy movement direction to stack
P:3DA01::run sub to kill enemy
P:3DA05::return enemy movement direction from stack
P:3DA09::set d5 in enemy state
P:3DA13::initialize vertical speed
P:3DA15::and movement force
P:3DA17::nullify vertical speed, physics-related thing,
P:3DA1A::and horizontal speed
P:3DA28:ChkForDemoteKoopa:branch elsewhere if enemy object < $0a
P:3DA3C::demote koopa paratroopas to ordinary troopas
P:3DA40::return enemy to normal state
P:3DA49::increment the stomp counter
P:3DA4C::add whatever is in the stomp counter
P:3DA50::apparently this sometimes refuses to work correctly lmao
P:3DA53::set number of points control for floatey numbers
P:3DA58::set timer for floatey numbers
P:3DA5D::set vertical coordinate
P:3DA63::set horizontal coordinate and leave
P:3DA66::increment stomp timer of some sort
P:3DA69::initialize vertical speed
P:3DA6B::and movement force
P:3DA70::turn enemy around if necessary
P:3DA7D::set appropriate moving speed based on direction
P:3DA7F::then move onto something else
P:3DA82:RevivalRateData
P:3DA84:HandleStompedShellE:set defeated state for enemy
P:3DA88::increment the stomp counter
P:3DA8B::add whatever is in the stomp counter
P:3DA8F::apparently this sometimes refuses to work correctly lmao
P:3DA92::set number of points control for floatey numbers
P:3DA97::set timer for floatey numbers
P:3DA9C::set vertical coordinate
P:3DAA2::set horizontal coordinate and leave
P:3DAA5::increment stomp timer of some sort
P:3DAA8::check primary hard mode flag
P:3DABC::load timer setting according to flag
P:3DABF::set as enemy timer to revive stomped enemy
P:3DAC2:SetBounce
P:3DAD2:SmallBonc:set player's vertical speed for bounce
P:3DADB:BnceM:and then leave!!!
P:3DADE:ChkEnemyFaceRight:check to see if enemy is moving to the right
P:3DAE2::if not, branch
P:3DAE4::otherwise go back to hurt player
P:3DAE7:LInj:turn the enemy around, if necessary
P:3DAEA::go back to hurt player
P:3DAED:EnemyFacePlayer:set to move right by default
P:3DAEF::get distance between enemy object's
P:3DAF1::horizontal coordinate and the player's
P:3DAF2::horizontal coordinate
P:3DAF4::and store here
P:3DAF8::subtract borrow, then leave
P:3DAFA::if enemy is to the right of player, do not increment
P:3DAFC::otherwise, increment to set to move to the left
P:3DAFD:SFcRt:set moving direction here
P:3DAFF::then decrement to use as a proper offset
P:3DB01:SetupFloateyNumber:set number of points control for floatey numbers
P:3DB06::set timer for floatey numbers
P:3DB0B::set vertical coordinate
P:3DB11::set horizontal coordinate and leave
P:3DB14:ExSFN
P:3DB15:SetBitsMask:-------------------------------------------------------------------------------------\n$01 - used to hold enemy offset for second enemy
P:3DB1C:ClearBitsMask
P:3DB23:ExSFN2:get enemy object buffer offset
P:3DB25::leave
P:3DB26:EnemiesCollision
P:3DB46::if enemy object => $15, branch to leave
P:3DB4A::if lakitu, branch to leave
P:3DB5A::then check enemy state
P:3DB5C::if not set to unique state for spiny's egg, go ahead
P:3DB6D::check saved enemy state for d5 set
P:3DB71::if masked offscreen bits nonzero, branch to leave
P:3DB76::get enemy object buffer offset
P:3DB78::multiply A by four, then add four
P:3DB79::to skip player's bounding box
P:3DB7D::send to Y
P:3DB7E::get offscreen bits for enemy object
P:3DB81::save low nybble
P:3DB83::check for all bits set
P:3DB85::first enemy we're going to compare, then decrement for second
P:3DB86::branch to leave if there are no other enemies
P:3DB88:ECLoop:save enemy object buffer offset for second enemy here
P:3DB8A::save first enemy's bounding box offset to stack
P:3DB8C::check enemy object enable flag
P:3DB8E::branch if flag not set
P:3DBA2::cmp #BulletBill_CannonVar\nbeq +\ncheck for enemy object => $15
P:3DBA4::branch if true
P:3DBA9:ReadyNextEnemy1
P:3DBB0::branch if enemy object is lakitu
P:3DBB5::branch if masked offscreen bits set
P:3DBB7::get second enemy object's bounding box offset
P:3DBB8::multiply by four, then add four
P:3DBBD::use as new contents of X
P:3DBBE::save contents of Y here
P:3DBC2::save value 1 here as counter, compare horizontal coordinates first
P:3DBC4:CollisionCoreLoop1:compare left/top coordinates
P:3DBC7::of first and second objects' bounding boxes
P:3DBCA::if first left/top => second, branch
P:3DBCC::otherwise compare to right/bottom of second
P:3DBCF::if first left/top < second right/bottom, branch elsewhere
P:3DBD1::if somehow equal, collision, thus branch
P:3DBD3::if somehow greater, check to see if bottom of
P:3DBD6::first object's bounding box is greater than its top
P:3DBD9::if somehow less, vertical wrap collision, thus branch
P:3DBDB::otherwise compare bottom of first bounding box to the top
P:3DBDE::of second box, and if equal or greater, collision, thus branch
P:3DBE0::ldy $06                      ;otherwise return with carry clear and Y = $0006\nnote horizontal wrapping never occurs
P:3DBE3:SecondBoxVerticalChk1:check to see if the vertical bottom of the box
P:3DBE6::is greater than the vertical top
P:3DBE9::if somehow less, vertical wrap collision, thus branch
P:3DBEB::otherwise compare horizontal right or vertical bottom
P:3DBEE::of first box with horizontal left or vertical top of second box
P:3DBF1::if equal or greater, collision, thus branch
P:3DBF3::ldy $06                      ;otherwise return with carry clear and Y = $0006
P:3DBF6:CollisionFound1:increment offsets on both objects to check
P:3DBF7::the vertical coordinates
P:3DBF8::decrement counter to reflect this
P:3DBFA::if counter not expired, branch to loop
P:3DBFC::otherwise we already did both sets, therefore collision, so set carry
P:3DC00:FirstBoxGreater1:compare first and second box horizontal left/vertical top again
P:3DC03::if first coordinate = second, collision, thus branch
P:3DC05::if not, compare with second object right or bottom edge
P:3DC08::if left/top of first less than or equal to right/bottom of second
P:3DC0A::then collision, thus branch
P:3DC0C::otherwise check to see if top of first box is greater than bottom
P:3DC0F::if less than or equal, no collision, branch to end
P:3DC13::otherwise compare bottom of first to top of second
P:3DC16::if bottom of first is greater than top of second, vertical wrap
P:3DC19::collision, and branch, otherwise, proceed onwards here
P:3DC1B:NoCollisionFound1:clear carry, then load value set earlier, then leave
P:3DC1C::like previous ones, if horizontal coordinates do not collide, we do
P:3DC1E::rts          ;not bother checking vertical ones, because what's the point?\nuse first enemy offset for X
P:3DC20::use second enemy offset for Y
P:3DC22::if carry clear, no collision, branch ahead of this
P:3DC3A::check both enemy states for d7 set
P:3DC3F::branch if at least one of them is set
P:3DC41::load first enemy's collision-related bits
P:3DC44::check to see if bit connected to second enemy is
P:3DC47::already set, and move onto next enemy slot if set
P:3DC4C::if the bit is not set, set it now
P:3DC52:YesEC:react according to the nature of collision
P:3DC55::move onto next enemy slot
P:3DC58:NoEnemyCollision:load first enemy's collision-related bits
P:3DC5B::clear bit connected to second enemy
P:3DC5E::then move onto next enemy slot
P:3DC61:ReadyNextEnemy:get first enemy's bounding box offset from the stack
P:3DC62::use as Y again
P:3DC63::get and decrement second enemy's object buffer offset
P:3DC66::loop until all enemy slots have been checked
P:3DC68:ExitECRoutine:get enemy object buffer offset
P:3DC6A::leave
P:3DC6B:ECLoop1
P:3DC6E:ProcSecondEnemyColl2
P:3DC71:ProcEnemyCollisions:check both enemy states for d5 set
P:3DC76::if d5 is set in either state, or both, branch
P:3DC78::to leave and do nothing else at this point
P:3DC84::lda Enemy_ID,x\ncmp #BulletBill_CannonVar\nbeq ++
P:3DC86::if second enemy state < $06, branch elsewhere
P:3DC8A::check second enemy identifier for hammer bro
P:3DC8C::if hammer bro found in alt state, branch to leave
P:3DC9E::check first enemy state for d7 set
P:3DCA1::branch if d7 is clear
P:3DCA5::set number of points control for floatey numbers
P:3DCAA::set timer for floatey numbers
P:3DCAF::set vertical coordinate
P:3DCB5::set horizontal coordinate and leave
P:3DCB8::then kill enemy, then load
P:3DCBD::original offset of second enemy
P:3DCBF:ShellCollisions:move Y to X
P:3DCCC::get chain counter for shell
P:3DCD0::add four to get appropriate point offset
P:3DCD9::set number of points control for floatey numbers
P:3DCDE::set timer for floatey numbers
P:3DCE3::set vertical coordinate
P:3DCE9::set horizontal coordinate and leave
P:3DCEC::load original offset of first enemy
P:3DCEE::increment chain counter for additional enemies
P:3DD0C:ExitProcessEColl
P:3DD0E::leave!!!
P:3DD0F:ProcSecondEnemyColl
P:3DD24::lda Enemy_ID,y\ncmp #BulletBill_CannonVar\nbeq ++\nif first enemy state < $06, branch elsewhere
P:3DD2F::check first enemy identifier for hammer bro
P:3DD32::if hammer bro found in alt state, branch to leave
P:3DD3A::otherwise, kill first enemy
P:3DD3F::get chain counter for shell
P:3DD43::add four to get appropriate point offset
P:3DD47::set number of points control for floatey numbers
P:3DD4C::set timer for floatey numbers
P:3DD51::set vertical coordinate
P:3DD57::set horizontal coordinate and leave
P:3DD70::load original offset of second enemy
P:3DD72::increment chain counter for additional enemies
P:3DD89::leave!!!
P:3DD8A:MoveEOfs:move Y ($01) to X
P:3DD8C::do the sub here using value from $01
P:3DD8F::then do it again using value from $08
P:3DD91:EnemyTurnAround:check for specific enemies
P:3DD95::if piranha plant, leave
P:3DD9D::if lakitu, leave
P:3DDA1::if hammer bro, leave
P:3DDA5::if spiny, turn it around
P:3DDA9::if green paratroopa, turn it around
P:3DDB9::if any OTHER enemy object => $07, leave
P:3DDBB:RXSpd:load horizontal speed
P:3DDBD::get two's compliment for horizontal speed
P:3DDC1::store as new horizontal speed
P:3DDC5::invert moving direction and store, then leave
P:3DDC7::thus effectively turning the enemy around
P:3DDDF:ExTA:leave!!!
P:3DDEE:LargePlatformCollision:-------------------------------------------------------------------------------------\n$00 - vertical position of platform\nsave value here
P:3DDF3::check master timer control
P:3DDF6::if set, branch to leave
P:3DDF8::if d7 set in object state,
P:3DDFA::branch to leave
P:3DDFE::check enemy object identifier for
P:3DE00::balance platform, branch if not found
P:3DE04::set state as enemy offset here
P:3DE05::perform code with state offset, then original offset, in X
P:3DE08:ChkForPlayerC_LargeP:figure out if player is below a certain point
P:3DE0B::or offscreen, branch to leave if true
P:3DE0E::multiply A by four, then add four
P:3DE0F::to skip player's bounding box
P:3DE13::send to Y
P:3DE14::get offscreen bits for enemy object
P:3DE17::save low nybble
P:3DE19::check for all bits set
P:3DE1B::store vertical coordinate in
P:3DE1D::temp variable for now
P:3DE1F::send offset we're on to the stack
P:3DE21::do player-to-platform collision detection
P:3DE24::retrieve offset from the stack
P:3DE26::if no collision, branch to leave
P:3DE28::otherwise collision, perform sub
P:3DE2B:ExLPC:get enemy object buffer offset and leave
P:3DE2E:ProcLPlatCollisions:--------------------------------\n$00 - counter for bounding boxes\n--------------------------------\nget difference by subtracting the top
P:3DE31::of the player's bounding box from the bottom
P:3DE32::of the platform's bounding box
P:3DE35::if difference too large or negative,
P:3DE37::branch, do not alter vertical speed of player
P:3DE39:ChkForTopCollision:lda Player_Y_Speed           ;check to see if player's vertical speed is moving down\nbpl ChkForTopCollision       ;if so, don't mess with it\nlda #$01                     ;otherwise, set vertical\nsta Player_Y_Speed           ;speed of player to kill jump\nget difference by subtracting the top
P:3DE3C::of the platform's bounding box from the bottom
P:3DE3D::of the player's bounding box
P:3DE42::if difference not close enough, skip all of this
P:3DE46::if player's vertical speed moving upwards, skip this
P:3DE48::get saved bounding box counter from earlier
P:3DE4C::if either of the two small platform objects are found,
P:3DE4E::regardless of which one, branch to use bounding box counter
P:3DE50::as contents of collision flag
P:3DE54::otherwise use enemy object buffer offset
P:3DE55:SetCollisionFlag:get enemy object buffer offset
P:3DE57::save either bounding box counter or enemy offset here
P:3DE5C::set player state to normal then leave
P:3DE5E:PlatformSideCollisions
P:3DE5F:PlayerPosSPlatData:-------------------------------------------------------------------------------------
P:3DE61:PositionPlayerOnS_Plat:use bounding box counter saved in collision flag
P:3DE62::for offset
P:3DE64::add positioning data using offset to the vertical
P:3DE65::coordinate
P:3DE68::BIT instruction opcode
P:3DE69:PositionPlayerOnVPlat:get vertical coordinate
P:3DE6D::if certain routine being executed on this frame,
P:3DE6F::skip all of this
P:3DE8B::if vertical high byte offscreen, skip this
P:3DE8F::subtract 32 pixels from vertical coordinate
P:3DE90::for the player object's height
P:3DE92::save as player's new vertical coordinate
P:3DE95::subtract borrow and store as player's
P:3DE97::new vertical high byte
P:3DE9B::initialize vertical speed and low byte of force
P:3DE9D::and then leave
P:3DEA3:ExPlPos
P:3DEA4:ExPlPos2
P:3DEB3:ExPlPos3
P:3DEC0:CheckPlayerVertical:-------------------------------------------------------------------------------------\nif player object is completely offscreen
P:3DEC3::vertically, leave this routine
P:3DEC7::if player high vertical byte is not
P:3DEC9::within the screen, leave this routine
P:3DECC::if on the screen, check to see how far down
P:3DECE::the player is vertically
P:3DED0:ExCPV
P:3DED1:PlayerBGUpperExtent:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00-$01 - used to hold many values, essentially temp variables\n$04 - holds lower nybble of vertical coordinate from block buffer routine\ntemp1 - used to hold block buffer adder
P:3DED3:PlayerBGCollision:if collision detection disabled flag set,
P:3DED6::branch to leave
P:3DEE3::if running routine #11 or $0b
P:3DEE5::branch to leave
P:3DEE9::if running routines $00-$03 branch to leave
P:3DEEF::load default player state for swimming
P:3DEF1::if swimming flag set,
P:3DEF4::branch ahead to set default state
P:3DEFB::if player in normal state,
P:3DEFD::branch to set default state for falling
P:3DF01::if in any other state besides climbing, skip to next part
P:3DF03:SetFallS:load default player state for falling
P:3DF05:SetPSte:set whatever player state is appropriate
P:3DF07:ChkOnScr
P:3DF09::check player's vertical high byte for still on the screen
P:3DF0B::branch to leave if not
P:3DF15::initialize player's collision flag
P:3DF1A::check player's vertical coordinate
P:3DF1C::if not too close to the bottom of screen, continue
P:3DF1E:ExPBGCol:otherwise leave
P:3DF1F:DoFootCheck1
P:3DF22:ChkCollSize:load default offset
P:3DF27::if player crouching, skip ahead
P:3DF2C::if player small, skip ahead
P:3DF2E::otherwise decrement offset for big player not crouching
P:3DF32::if swimming flag set, skip ahead
P:3DF34::otherwise decrement offset
P:3DF35:GBBAdr:get value using offset
P:3DF38::store value here
P:3DF3A::put value into Y, as offset for block buffer routine
P:3DF3B::get player's size as offset
P:3DF41::if player not crouching, branch ahead
P:3DF43::otherwise increment size as offset
P:3DF44:HeadChk
P:3DF4C::get player's vertical coordinate
P:3DF4E::compare with upper extent value based on offset
P:3DF51::if player is too high, skip this par
P:3DF60::beq ++
P:3DF65::lda Player_Y_Speed\nbeq ++\nbpl DoFootCheck1
P:3DF7F::cmp #$00\nplayer, and branch if nothing above player's head
P:3DF9F:NoPuta
P:3DFBB::jmp DoFootCheck
P:3DFD2:DoFoCHK
P:3DFD2:DoFoCHK1
P:3DFD5:CheckForUpPipe
P:3DFE7::do player-to-bg collision detection on top of
P:3DFEE::do player-to-bg collision detection on top of
P:3DFF8::check to see if player touched coin with their head
P:3DFFD::if so, branch to some other part of code
P:3E021::check player's vertical speed
P:3E025::if player not moving upwards, branch elsewhere
P:3E053::check lower nybble of vertical coordinate returned
P:3E055::from collision detection routine
P:3E057::if low nybble < 4, branch
P:3E059::jsr CheckForSolidMTiles
P:3E066:NoPuta2
P:3E08A::save metatile value into Y
P:3E08B::mask out all but 2 MSB
P:3E08E::shift and rotate d7-d6 to d1-d0
P:3E090::use as offset for metatile data
P:3E091::get original metatile value back
P:3E092::compare current metatile with solid metatiles
P:3E095::if player collided with solid metatile, branch
P:3E097:TryBump:if block bounce timer not expired,
P:3E09A::branch ahead, do not process collision
P:3E09C::otherwise do a sub to process collision
P:3E0A7::lda #$01
P:3E0A9::jump ahead to skip these other parts here
P:3E0AC:DoFoCHK8
P:3E0AF:DoPlayerSideCheck3
P:3E0B2:Burh1
P:3E0B5:Che
P:3E0B9:SolidOrClimb
P:3E0BB::branch ahead and do not play sound
P:3E0D0::otherwise load bump sound
P:3E0EB:NYSpd:set player's vertical speed to nullify\nPAL diff: Set vertical speed to 0 in water stages\n not water\njump or swim\nset player's vertical speed to nullify
P:3E0ED::jump or swim
P:3E0F2:PutOnSlope4
P:3E0F9:JmpTo4Mas
P:3E0FC:DoFootCheck
P:3E134:DoPlayerSideCheck5
P:3E137:DoFootCh
P:3E139:DFC
P:3E13C::lda #$00\nsta DetectedFoot\nlda SwimmingFlag\nora OldSwim\nbne +\nlda Player_Y_Speed\nbmi DoPlayerSideCheck5\nget block buffer adder offset
P:3E140::check to see how low player is
P:3E142::if player is too far down on screen, skip all of this
P:3E162::do player-to-bg collision detection on bottom left of player
P:3E165::cmp #$71\nbeq Burh2
P:3E169::check to see if player touched coin with their left foot
P:3E17A::do player-to-bg collision detection on bottom right of player
P:3E17D::save bottom right metatile here
P:3E182:micaracuando:save bottom left metatile to stack
P:3E183::do player-to-bg collision detection on bottom right of player
P:3E186::save bottom right metatile here
P:3E189::pull bottom left metatile and save here
P:3E18B::if anything here, skip this part
P:3E18D::check for hidden coin block
P:3E18F::branch to leave if found
P:3E195::check for hidden 1-up block
P:3E19D::do sub to check for hidden coin or 1-up blocks
P:3E19F::if either found, branch
P:3E1BC:Burh2:		 ldy OldSwim\n	  bne +\n	  ldy WaterCooldown\n	  bne +\nldy SwimmingFlag\nbne +\ninc OldSwim\ninc SwimmingFlag\n	  pha\n	  jsr e\n	  pla\n	  ldy #$10\n	  sty WaterCooldown\n+:	  \n	  ldy #$01\n	  sty SwimmingFlag\n		 jmp Burh2
P:3E1BC:Fuck
P:3E1BF:PutOnSlope1
P:3E1C2:Ostia
P:3E1C3:e
P:3E1E2::lda Player_Y_Speed\nbmi x2
P:3E1FC:x2
P:3E1FD:x1
P:3E20B:Brom
P:3E281:Gay2
P:3E282:DoPlayerSideCheck4
P:3E285:Ostia2
P:3E288:Burh:otherwise check for anything in bottom right metatile
P:3E28A::and skip ahead if not
P:3E2C5:DoPlayerSideCheckte
P:3E2C8:Gay
P:3E2CC::check for hidden coin block
P:3E2CE::branch to leave if found
P:3E2D8::check for hidden 1-up block
P:3E2DC::do sub to check for hidden coin or 1-up blocks
P:3E311::check to see if player touched coin with their right foot
P:3E314::if not, skip unconditional jump and continue code
P:3E31C:PutOnSlope2
P:3E324:DoTheSpike2
P:3E327:DoPlayerSideCheck2
P:3E32E:DoPlayerSideCheck1
P:3E331:ChkFootMTile2
P:3E33B:ChkFootMTile
P:3E340::save metatile value into Y
P:3E341::mask out all but 2 MSB
P:3E344::shift and rotate d7-d6 to d1-d0
P:3E346::use as offset for metatile data
P:3E347::get original metatile value back
P:3E364::compare current metatile with climbable metatiles
P:3E367::if so, branch
P:3E369:chorizo:check player's vertical speed
P:3E36B::if player moving upwards, branch
P:3E371::ldx WaterCooldown\nbne DoPlayerSideCheck1
P:3E379:MIERDA2
P:3E37F:ContChk2
P:3E399::jmp SmolJmp
P:3E39C::if player did not touch axe, skip ahead
P:3E39E::otherwise jump to set modes of operation
P:3E3A1:DoTheSpike
P:3E3B6:@g
P:3E3BA:@oda
P:3E3C7:DoPlayerSideCheck6
P:3E3CA:PutOnSlope3
P:3E3CD:CargarPTimer: +1 because this decrements before reaching the check for jumping
P:3E3E3::store in queue and leave
P:3E3EC::initialize vertical speed and fractional
P:3E3EE::movement force to stop player's vertical movement
P:3E3F1::initialize enemy stomp counter
P:3E3F9:MIERDA3
P:3E409:SmolJmp
P:3E40E:ContChk:ldy JumpspringAnimCtrl     ;if jumpspring animating right now,\nbeq +\njmp InitSteP               ;branch ahead\ncheck lower nybble of vertical coordinate returned
P:3E410::ldx FramesMissed\nbne +
P:3E412::from collision detection routine\nif lower nybble < 5, branch
P:3E420::ldy WaterCooldown\nbne DoPlayerSideCheck
P:3E428:MIERDA
P:3E449:: jmp PutOnSlope
P:3E453::jmp SmolJmp
P:3E456::use player's moving direction as temp variable
P:3E458::jump to impede player's movement in that direction
P:3E45B:LandPlyr:jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
P:3E45D::mask out lower nybble of player's vertical position
P:3E45F::and store as new vertical position to land player properly
P:3E466:eda
P:3E46B::do sub to process potential pipe entry
P:3E478::sta DetectedFoot\ninitialize vertical speed and fractional
P:3E47A::movement force to stop player's vertical movement
P:3E47D::initialize enemy stomp counter
P:3E480::lda #$00\nset player's state to normal
P:3E485:DoPlayerSideCheck
P:3E494::get block buffer adder offset
P:3E497::increment offset 2 bytes to use adders for side collisions
P:3E49F::set value here to be used as counter
P:3E4A5:BHalf1
P:3E4A8:SideChekEx
P:3E4A9:SideCheckLoop:move onto the next one
P:3E4AA::store it
P:3E4B1::check player's vertical position
P:3E4B3::if player is in status bar area, branch ahead to skip this part
P:3E4B7::branch to leave if player is too far down
P:3E4B9::do player-to-bg collision detection on one half of player
P:3E4BC::branch ahead if nothing found
P:3E4BE::check for hidden coin block
P:3E4C0::branch to leave if found
P:3E4C2::check for hidden 1-up block
P:3E4D8::do sub to check for hidden coin or 1-up blocks
P:3E4DA::branch to leave if either found
P:3E4E8::otherwise check for pipe metatiles
P:3E4EA::if collided with sideways pipe (top), branch ahead
P:3E4EE::if collided with water pipe (top), branch ahead
P:3E507::ldy WaterCooldown\nbne BHalf
P:3E50F:CheckSideMTiles1
P:3E52B::save metatile value into Y
P:3E52C::mask out all but 2 MSB
P:3E52F::shift and rotate d7-d6 to d1-d0
P:3E531::use as offset for metatile data
P:3E532::get original metatile value back
P:3E547::compare current metatile with climbable metatiles
P:3E54C:BHalf:load block adder offset
P:3E54E::increment it
P:3E54F::get player's vertical position
P:3E553::if too high, branch to leave
P:3E557::if too low, branch to leave
P:3E559::do player-to-bg collision detection on other half of player
P:3E55E::check for hidden coin block
P:3E560::      branch to leave if found
P:3E562::check for hidden 1-up block
P:3E56A::ldx #$00\nstx OnSlope
P:3E56E::do sub to check for hidden coin or 1-up blocks
P:3E570::branch to leave if either found
P:3E58F:: ldx WaterCooldown\nbne +
P:3E5AA:ExSCH2
P:3E5AB:Ultramas1
P:3E5C7::save metatile value into Y
P:3E5C8::mask out all but 2 MSB
P:3E5CB::shift and rotate d7-d6 to d1-d0
P:3E5CD::use as offset for metatile data
P:3E5CE::get original metatile value back
P:3E5E7::compare current metatile with climbable metatiles
P:3E5EC::if something found, branch
P:3E5EE:Ultramas:otherwise decrement counter
P:3E5F0::run code until both sides of player are checked
P:3E5F2:ExSCH:leave
P:3E5F3:SideCheckLoop1
P:3E5F6:CheckSideMTiles:check for hidden coin block
P:3E5F8::branch to leave if found
P:3E5FA::check for hidden 1-up block
P:3E616::branch to leave if either found
P:3E629:SiPuta
P:3E62D::lda OnSlope\nbne +\ndec Player_Y_Position \njmp PutOnSlope
P:3E637::lda Player_Y_Position\nand #$0f\ncmp #$02\nbcc +++
P:3E648::save metatile value into Y
P:3E649::mask out all but 2 MSB
P:3E64C::shift and rotate d7-d6 to d1-d0
P:3E64E::use as offset for metatile data
P:3E64F::get original metatile value back
P:3E650::compare current metatile with climbable metatiles
P:3E653::if not found, skip and continue with code
P:3E665::otherwise jump to handle climbing
P:3E668:ContSChk:check to see if player touched coin
P:3E66F::if not found, branch ahead to continue cude
P:3E671:: lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control\nbne ExCSM2                 ;branch to leave if set\notherwise jump to impede player's movement
P:3E674:ChkPBtm:get player's state
P:3E676::cpy #$00                   ;check for player's state set to normal\nif not, branch to impede player's movement
P:3E678::get player's facing direction
P:3E67B::if facing left, branch to impede movement
P:3E67D::otherwise check for pipe metatiles
P:3E67F::if collided with sideways pipe (bottom), branch
P:3E681::if collided with water pipe (bottom), continue
P:3E683::otherwise branch to impede player's movement
P:3E685:PipeDwnS:check player's attributes
P:3E688::if already set, branch, do not play sound again
P:3E68C::otherwise load pipedown/injury sound
P:3E68E:PlyrPipe
P:3E690::set background priority bit in player attributes
P:3E6A9::get lower nybble of player's horizontal coordinate
P:3E6AB::if at zero, branch ahead to skip this part
P:3E6B7:ChkGERtn:get number of game engine routine running
P:3E6BB::if running player entrance routine or
P:3E6BD::player control routine, go ahead and branch to leave
P:3E6C3::otherwise set sideways pipe entry routine to run
P:3E6C5:ExCSM2:and leavex
P:3E6C6:StopPlayerMove:--------------------------------\n$02 - high nybble of vertical coordinate from block buffer\n$04 - low nybble of horizontal coordinate from block buffer\n$06-$07 - block buffer address\nleave
P:3E6C9:HandleCoinMetatile
P:3E6D2::load coin grab sound and leave
P:3E6D4::do sub to erase coin metatile from block buffer
P:3E6D7::increment coin tally used for 1-up blocks
P:3E6DA::give coin
P:3E6DD:HandleAxeMetatile:       ldx BowserFront_Offset\n       lda Enemy_ID,x\n       cmp #Bowser\n       bne +\n       jmp ContChk\n+\n       lda #$00            ;load blank metatile\n       sta ($06),y         ;store to remove old contents from block buffer\n       jmp RemoveCoin_Axe  ;update the screen accordingly\n       jsr SetupVictoryMode\n       lda #$03\n       sta OperMode_Task   ;reset secondary mode\n       lda #$02\n       sta OperMode        ;set primary mode to autoctrl mode\n       rts
P:3E6DF::reset secondary mode
P:3E6E4::set primary mode to autoctrl mode
P:3E6E9::set horizontal speed and continue to erase axe metatile
P:3E6F3:ErACM:lda bocata2\nbne +\ninc bocata2\nload vertical high nybble offset for block buffer
P:3E6FB::store to remove old contents from block buffer
P:3E6FD::update the screen accordingly
P:3E701:ClimbXPosAdder:--------------------------------\n$02 - high nybble of vertical coordinate from block buffer\n$04 - low nybble of horizontal coordinate from block buffer\n$06-$07 - block buffer address
P:3E704:ClimbPLocAdder
P:3E707:FlagpoleYPosData
P:3E70C:HandleClimbing
P:3E710::check low nybble of horizontal coordinate returned from
P:3E712::collision detection routine against certain values, this
P:3E714::makes actual physical part of vine or flagpole thinner
P:3E716::than 16 pixels
P:3E71A:ExHC:leave if too far left or too far right
P:3E71B:ChkForFlagpole
P:3E71D::branch to alternate code if flagpole shaft not found
P:3E71F:FlagpoleCollision
P:3E721::check for end-of-level routine running
P:3E723::if running, branch to end of climbing code
P:3E727::set player's facing direction to right
P:3E729::set scroll lock flag
P:3E72E::check for flagpole slide routine running
P:3E730::if running, branch to end of flagpole code here
P:3E732::load identifier for bullet bills (cannon variant)
P:3E734::store identifier here
P:3E736::      lda #$00\n      ldx #$05          ;check for identifier in enemy object buffer\neie:  ldy Enemy_ID,x\n      ;cpy $00           ;if not found, branch\n      bne ++\n      sta Enemy_Flag,x  ;if found, deactivate enemy object flag\n++:   dex               ;do this until all slots are checked\n      bpl eie
P:3E742::silence music
P:3E745::load flagpole sound into flagpole sound queue
P:3E74B::start at end of vertical coordinate data
P:3E74F::store player's vertical coordinate here to be used later
P:3E752:ChkFlagpoleYPosLoop:compare with current vertical coordinate data
P:3E755::if player's => current, branch to use current offset
P:3E757::otherwise decrement offset to use 
P:3E758::do this until all data is checked (use last one if all checked)
P:3E75A:MtchF:store offset here to be used later
P:3E75D:RunFR
P:3E75F::set value to run flagpole slide routine
P:3E764::jump to end of climbing code
P:3E767:VineCollision:check for climbing metatile used on vines
P:3E777:PutPlayerOnVine:lda Player_Y_Position     ;check player's vertical coordinate\ncmp #$20                  ;for being in status bar area\nbcs PutPlayerOnVine       ;branch if not that far up\nlda #$01\nsta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
P:3E796::set player state to climbing
P:3E79D::nullify player's horizontal speed
P:3E79F::and fractional horizontal movement force
P:3E7AA::get player's horizontal coordinate
P:3E7AD::subtract from left side horizontal coordinate
P:3E7B2::if 16 or more pixels difference, do not alter facing direction
P:3E7B6::otherwise force player to face left
P:3E7B8:SetVXPl:get current facing direction, use as offset
P:3E7BA::get low byte of block buffer address
P:3E7BD::move low nybble to high
P:3E7C1::add pixels depending on facing direction
P:3E7C4::store as player's horizontal coordinate
P:3E7C6::get low byte of block buffer address again
P:3E7C8::if not zero, branch
P:3E7CA::load page location of right side of screen
P:3E7CE::add depending on facing location
P:3E7D1::store as player's page location
P:3E7D3:ExPVne:finally, we're done!
P:3E7D4:ClimbMTileUpperExt:--------------------------------\n--------------------------------\n$00-$01 - used to hold bottom right and bottom left metatiles (in that order)\n$00 - used as flag by ImpedePlayerMove to restrict specific movement\nChkForLandJumpSpring:\ncmp #$67				    ;do sub to check if player landed on jumpspring\nbne ExCJSp                  ;if carry not set, jumpspring not found, therefore leave\nlda DetectedFoot\nora OldDetectedFoot\nbne ExCJSp\nlda #$70\nsta VerticalForce           ;otherwise set vertical movement force for player\nlda #$f9\nsta JumpspringForce         ;set default jumpspring force\nlda Enemy_Flag,x\nbeq ++\nlda Enemy_ID,x\ncmp #JumpspringObject\nbeq +\ndex\nbpl -\njmp ExCJSp\nlda #$03\nsta JumpspringTimer         ;set jumpspring timer to be used later\nlsr\nsta JumpspringAnimCtrl      ;set jumpspring animation control to start animating\nrts                         ;and leave\n--------------------------------\n.db $24, $6d, $8a, $c6
P:3E7D4:ExCJSp
P:3E7D8:ExEBG:CheckForClimbMTiles:\n      tay            ;save metatile value into Y\n      and #%11000000 ;mask out all but 2 MSB\n      asl\n      rol            ;shift and rotate d7-d6 to d1-d0\n      rol\n      tax            ;use as offset for metatile data\n      tya            ;get original metatile value back\n      cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles\n      rts\nleave
P:3E7D9:DoEnemySideCheck44:-------------------------------------------------------------------------------------\n$06-$07 - address from block buffer routine
P:3E7DC:NoEToBGCollision1
P:3E7DF:EnemyBGCStateData
P:3E7E5:EnemyBGCXSpdData
P:3E7E9:EnemyToBGCollisionDet:check enemy state for d6 set
P:3E7ED::if set, branch to leave
P:3E7F3::add 62 pixels to enemy object's
P:3E7FB::if enemy vertical coord + 62 < 68, branch to leave
P:3E7FF:DoIDCheckBGColl:cpy #Spiny               ;if enemy object is not spiny, branch elsewhere\nbne DoIDCheckBGColl\nlda Enemy_Y_Position,x\ncmp #$25                 ;if enemy vertical coordinate < 36 branch to leave\nbcc NoEToBGCollision1
P:3E803::check for some other enemy object
P:3E805::branch if not found
P:3E807::otherwise jump elsewhere
P:3E80A:HBChk:check for hammer bro
P:3E80C::branch if not found
P:3E80E::otherwise jump elsewhere
P:3E811:CInvu:if enemy object is spiny, branch
P:3E815::if special power-up object, branch
P:3E821::if enemy object =>$07, branch to leave
P:3E825:YesIn
P:3E853::set flag in A for save vertical coordinate
P:3E858::set Y to check the bottom middle (8,18) of enemy object
P:3E85B::inc PlayerFoot,x\npha                         ;save contents of A to stack\nsave contents of Y here
P:3E85D::add horizontal coordinate
P:3E860::of object to value obtained using Y as offset
P:3E863::store here
P:3E865::of indirect here
P:3E870::store here and leave
P:3E872::get old contents of Y
P:3E874::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3E877::add it to value obtained using Y as offset
P:3E87A::mask out low nybble
P:3E87C::store result here
P:3E87E::use as offset for block buffer
P:3E87F::check current content of block buffer
P:3E881::and store here
P:3E883::get old contents of Y again
P:3E885::pla                         ;pull A from stack\nbne +                       ;if A = 1, branch\nif A = 0, load vertical coordinate
P:3E887::and mask out high nybble
P:3E889::store masked out result here
P:3E88B::get saved content of block buffer                       ;and leave
P:3E890::get object offset
P:3E892::check to see if object bumped into anything
P:3E894::jmp ++\nlda SprObject_X_Position,x  ;otherwise load horizontal coordinate\nand #%00001111              ;and mask out high nybble\nsta $04                     ;store masked out result here\nldx $03                     ;get saved content of block buffer                       ;and leave\nlda MetatileThingy,x\nldx ObjectOffset            ;get object offset\ncmp #$00                    ;check to see if object bumped into anything
P:3E899::okputa
P:3E8DC:hypermas
P:3E901::if block underneath enemy, branch
P:3E904:GetBlockCoin2
P:3E915::if enemy state d7 not set, branch
P:3E91D:NoEToBGCollision
P:3E91F::otherwise skip and do something else
P:3E922:LandEnemyInitState1
P:3E92B:PUPs2
P:3E92E:LandEnemyProperly1
P:3E931:NoEToBGCollisionAndSlowdown:	lda Enemy_State,x\n	asl\n	bcc +\n	dec Enemy_Y_Position,x\n	dec Enemy_Y_Position,x\n+:	dec Enemy_Y_Position,x\n	ldy #$26\n	inx\n	jsr BBChk_E\n	cmp #$71\n	beq +\n	inc Enemy_Y_Position,x\n	lda Enemy_State,x\n	asl\n	bcc +\n	inc Enemy_Y_Position,x\n	inc Enemy_Y_Position,x\n+:	rts
P:3E931:PutEnemyOnSlope2
P:3E934:Enemy_PSwitchJmp:	rts\njmp PutEnemyOnSlope\n--------------------------------\n$02 - vertical coordinate from block buffer routine
P:3E934:PutEnemyOnSlope1
P:3E937:HandleEToBGCollision:if blank $26, coins, or hidden blocks, jump, enemy falls through
P:3E939::blank metatile used for vines?
P:3E93D::regular coin?
P:3E94F::beq NoEToBGCollision\nhidden 1-up block?
P:3E97F:vale:pha\nldy #$24\njsr BlockBufferChk_Enemy\ncmp #$71\nbeq PutEnemyOnSlope2\npla
P:3E9A7::check for blank metatile $23 and branch if not found
P:3E9A9::get vertical coordinate used to find block
P:3E9AB::store default blank metatile in that spot so we won't
P:3E9AD::trigger this routine accidentally again
P:3E9B8:LandEnemyProperly2
P:3E9BB:NoEToBGCollision2
P:3E9BE:PUPs
P:3E9D0::if enemy object => $15, branch ahead
P:3E9D4::if enemy object not goomba, branch ahead of this routine
P:3E9DC::do this sub to kill enemy
P:3E9DF::alter vertical speed of enemy and leave
P:3E9E3:GiveOEPoints:award 100 points for hitting block beneath enemy
P:3E9E5::set number of points control for floatey numbers
P:3E9EA::set timer for floatey numbers
P:3E9EF::set vertical coordinate
P:3E9F5::set horizontal coordinate and leave
P:3E9F8:ChkToStunEnemies
P:3E9FC::load enemy state
P:3E9FE::save high nybble
P:3EA02::set d1 of enemy state
P:3EA07::perform many comparisons on enemy object identifier
P:3EA1B::if the enemy object identifier is equal to the values
P:3EA1D::$09, $0e, $0f or $10, it will be modified, and not
P:3EA1F::modified if not any of those values, note that piranha plant will
P:3EA21::always fail this test because A will still have vertical
P:3EA23::coordinate from previous addition, also these comparisons
P:3EA25::are only necessary if branching from $d7a1
P:3EA27:Demote:erase all but LSB, essentially turning enemy object
P:3EA29::into green or red koopa troopa to demote them
P:3EA2B:SetStun:load enemy state
P:3EA2D::save high nybble
P:3EA31::set d1 of enemy state
P:3EA35::subtract two pixels from enemy's vertical position
P:3EA39::check for bloober object
P:3EA3D::set default vertical speeds
P:3EA44:SetWYSpd:change the vertical speed
P:3EA46:SetNotW:set vertical speed now
P:3EA4A::get distance between enemy object's
P:3EA4C::horizontal coordinate and the player's
P:3EA4D::horizontal coordinate
P:3EA4F::and store here
P:3EA53::subtract borrow, then leave
P:3EA55::branch if enemy is to the right of player
P:3EA57::increment Y if not
P:3EA58:ChkBBill
P:3EA5A::check for bullet bill (cannon variant)
P:3EA5E::check for bullet bill (frenzy variant)
P:3EA60::branch if either found, direction does not change
P:3EA62::store as moving direction
P:3EA64:NoCDirF:decrement and use as offset
P:3EA65::get proper horizontal speed
P:3EA68::and store, then leave
P:3EA6A:ExEBGChk
P:3EA6B:LeComparation:--------------------------------\n$04 - low nybble of vertical coordinate from block buffer routine
P:3EA6D:LandEnemyProperly
P:3EA70::check lower nybble of vertical coordinate saved earlier
P:3EA73::subtract eight pixels
P:3EA78::branch if lower nybble in range of $0d-$0f before subtract
P:3EA7C::branch if d6 in enemy state is set
P:3EA87:SChkA:if lower nybble < $0d, d7 set but d6 not set, jump here
P:3EA8A:ChkForRedKoopa1
P:3EA8D:ProcEnemyDirection:check enemy identifier for goomba
P:3EA8F::branch if found
P:3EA93::check for spiny
P:3EA95::branch if not found
P:3EA99::send enemy moving to the right by default
P:3EA9D::set horizontal speed accordingly
P:3EAA1::if timed appropriately, spiny will skip over
P:3EAA3::trying to face the player
P:3EAA5:InvtD:load 1 for enemy to face the left (inverted here)
P:3EAA7::get distance between enemy object's
P:3EAA9::horizontal coordinate and the player's
P:3EAAA::horizontal coordinate
P:3EAAC::and store here
P:3EAB0::subtract borrow, then leave
P:3EAB2::if enemy to the right of player, branch
P:3EAB4::if to the left, increment by one for enemy to face right (inverted)
P:3EAB5:CNwCDir
P:3EAB6::compare direction in A with current direction in memory
P:3EAC0::if equal, not facing in correct dir, do sub to turn around
P:3EAC3:LandEnemyInitState:initialize vertical speed
P:3EAC5::and movement force
P:3EAC7::do something here to vertical speed and something else
P:3EACC::save high nybble of vertical coordinate, and
P:3EACE::set d3, then store, probably used to set enemy object
P:3EAD0::neatly on whatever it's landing on
P:3EAD4::if d7 of enemy state is set, branch
P:3EAD8::otherwise initialize enemy state and leave
P:3EADA::note this will also turn spiny's egg into spiny
P:3EAE0:NMovShellFallBit:nullify d6 of enemy state, save other bits
P:3EAE2::and store, then leave
P:3EAE7:ChkForRedKoopa:check for red koopa troopa $03
P:3EAF3::branch if not found
P:3EAF9::if enemy found and in normal state, branch
P:3EAFC:Chk2MSBSt:save enemy state into Y
P:3EAFF::branch if not set
P:3EB03::set d6
P:3EB05::jump ahead of this part
P:3EB08:GetSteFromD:load new enemy state with old as offset
P:3EB0B:SetD6Ste:set as new state
P:3EB0D:DoEnemySideCheck:--------------------------------\n$00 - used to store bitmask (not used but initialized here)\n$eb - used in DoEnemySideCheck as counter and to compare moving directions
P:3EB11::if enemy within status bar, branch to leave
P:3EB13::because there's nothing there that impedes movement
P:3EB17::start by finding block to the left of enemy ($00,$14)
P:3EB19::set value here in what is also used as
P:3EB1B::OAM data offset
P:3EB1D:SdeCLoop:check value
P:3EB1F::compare value against moving direction
P:3EB21::branch if different and do not seek block there
P:3EB23::set flag in A for save horizontal coordinate 
P:3EB31:NextSdeC:move to the next direction
P:3EB34::increment Y, loop only if Y < $18, thus we check
P:3EB36::enemy ($00, $14) and ($10, $14) pixel coordinates
P:3EB38:ExESdeC
P:3EB39:Half
P:3EB3D:nosesabe3Under
P:3EB71:nosesabe3
P:3EB74:GetBlockCoin1
P:3EB77:PutEnemyOnSlope3
P:3EB7A:nosesabe:blank metatile used for vines?
P:3EB7E::regular coin?
P:3EB82::hidden coin block?
P:3EB92::hidden 1-up block?
P:3EBAE:cantasmal
P:3EBE5::and if so, branch ahead and do not play sound
P:3EBF0::lda to skip this pla
P:3EBF5:ChkForBump_HammerBroJ
P:3EBF9::and if so, branch ahead and do not play sound
P:3EC05::if enemy state d7 not set, branch
P:3EC30::if not, check for others blocks
P:3EC33:NoBump:check for hammer bro
P:3EC37::branch if not found
P:3EC3B::initialize value here for bitmask  
P:3EC3D::load default vertical speed for jumping
P:3EC3F::jump to code that makes hammer bro jump
P:3EC42:GetBlockCoin3
P:3EC45:InvEnemyDir
P:3EC48:BreakBlock2
P:3EC4C:PaLante:if not, turn around
P:3EC4D:PaTras
P:3EC50:Webos3
P:3EC53:nosesabe2
P:3EC69::if enemy state d7 not set, branch
P:3ECA5:rtsp
P:3ECA6:rtsp2
P:3ECA8:rtsp3
P:3ECB3:MushEJmp
P:3ECB6:StarEJmp
P:3ECB9:GetBlockCoin
P:3ECC3::if enemy state d7 not set, branch
P:3ECD8:CoinE
P:3ECDD:MultiCoin
P:3ECE7::if enemy state d7 not set, branch
P:3ECF8::set offset for empty or last misc object buffer slot
P:3ECFB::get page location saved earlier
P:3ECFD::and save as page location for misc object
P:3ED00::get low byte of block buffer offset
P:3ED03::add five pixels
P:3ED05::save as horizontal coordinate for misc object
P:3ED08::get vertical high nybble offset from earlier
P:3ED0B::remove 16 pixels
P:3ED0D::store as vertical coordinate
P:3ED13:brickshatterex
P:3ED1A:BreakBlock
P:3ED27::get horizontal coordinate for left side of screen
P:3ED2B::subtract 72 pixels regardless of enemy object
P:3ED2D::store result here
P:3ED32::subtract borrow from page location of left side
P:3ED34::store result here
P:3ED36::add 72 pixels to the right side horizontal coordinate
P:3ED3C::store result here
P:3ED41::then add the carry to the page location
P:3ED43::and store result here
P:3ED45::compare horizontal coordinate of the enemy object
P:3ED47::to modified horizontal left edge coordinate to get carry
P:3ED4B::then subtract it from the page coordinate of the enemy object
P:3ED4D::if enemy object is too far left, branch to erase it
P:3ED4F::compare horizontal coordinate of the enemy object
P:3ED51::to modified horizontal right edge coordinate to get carry
P:3ED55::then subtract it from the page coordinate of the enemy object
P:3ED57::if enemy object is on the screen, leave, do not erase enemy
P:3ED97::save as horizontal coordinate for block object
P:3ED9C::add carry to page location of player
P:3ED9E::save as page location of block object
P:3EDA3::save vertical high byte of player into
P:3EDA6::get low byte of block buffer address used in same routine
P:3EDCF:ShellBumpTable:02 coin block
P:3EDD2::06 multicoins brick
P:3EDD6::0f power-up
P:3EDDF::16 star
P:3EDE6::1b 1up
P:3EDEB::1c vine
P:3EDED:ToBreak
P:3EDFC:GetBlockCoin4
P:3EDFF:BreakBlock1
P:3EE04:Webos2:coin?
P:3EE08::brick
P:3EE0C::brick with line
P:3EE10::brick
P:3EE14::brick with line
P:3EE18::if not, play bump sound
P:3EE25:ShellBumpLoop
P:3EE61:rp
P:3EE62:NothingBlock
P:3EE69:OnOffSetE
P:3EE77:CoinE2:initialize multi-coin timer flag
P:3EE7E::if not set, set brick coin timer
P:3EE84:MultiCoinE:check brick coin timer flag
P:3EE87::if set, timer expired or counting down, thus branch
P:3EE8B::if not set, set brick coin timer
P:3EE8E::and set flag linked to it
P:3EEA2:MushE
P:3EEAC::if enemy state d7 not set, branch
P:3EEB3:StarE
P:3EEB6:P1upE
P:3EEB8:BlockPower:fun fact: set block state to 1 to make it bump
P:3EEC9:VineE
P:3EED9::get control bit
P:3EEE0:GetBlockEnemy
P:3EF06::set block bounce timer
P:3EF33::apparently this sometimes refuses to work correctly lmao
P:3EF52::save as horizontal coordinate for block object
P:3EF5C::get low byte of block buffer address used in same routine
P:3EF73:FY2
P:3EF74:DoSide1:--------------------------------\n$00 - used to hold horizontal difference between player and enemy\n-------------------------------                     ;and leave with flags set for conditional branch
P:3EF77:Enemy_PSwitchJmp2
P:3EF7A:EnemyJump:add 62 pixels to enemy object's
P:3EF7C::compare against a certain range     ;do a sub here
P:3EF7E::if enemy vertical coord + 62 < 68, branch to leave
P:3EF8C::set flag in A for save vertical coordinate
P:3EF8E::set Y to check the bottom middle (8,18) of enemy object
P:3EF94::standing on anything, then branch to same place if not
P:3EFD0::blank metatile used for vines?
P:3EFD4::regular coin?
P:3EFD8::hidden coin block?
P:3EFDC::hidden 1-up block?
P:3EFDE::branch if found
P:3F001::hiweputa
P:3F011:bru
P:3F013:bruh
P:3F01C::initialize vertical speed
P:3F01E::and movement force
P:3F020::do something here to vertical speed and something else
P:3F025::save high nybble of vertical coordinate, and
P:3F027::set d3, then store, probably used to set enemy object
P:3F029::neatly on whatever it's landing on
P:3F02D::make the paratroopa jump again
P:3F02F:DoSid2
P:3F032:FY3
P:3F033:DoSide
P:3F07C:NoPe:blank metatile used for vines?
P:3F080::regular coin?
P:3F084::hidden coin block?
P:3F0BC:Oetu
P:3F0C0:Boi
P:3F0C0:XD2
P:3F0C7::check for horizontal blockage, then leave
P:3F0CA:FY4
P:3F0CB:NoUnderHammerBro2
P:3F0CE:HammerBroBGColl:--------------------------------\nset flag in A for save vertical coordinate
P:3F0D0::set Y to check the bottom middle (8,18) of enemy object
P:3F119::regular coin?
P:3F128::check for blank metatile $23 and branch if not found
P:3F12C:KillEnemyAboveBlock:tu puta madre
P:3F132::do this sub to kill enemy
P:3F135::alter vertical speed of enemy and leave
P:3F139:FY
P:3F13A:UnderHammerBro:check timer used by hammer bro
P:3F13D::branch if not expired
P:3F141::save d7 and d3 from enemy state, nullify other bits
P:3F143::and store
P:3F145::initialize vertical speed
P:3F147::and movement force
P:3F149::do something here to vertical speed and something else
P:3F14E::save high nybble of vertical coordinate, and
P:3F150::set d3, then store, probably used to set enemy object
P:3F152::neatly on whatever it's landing on
P:3F154::then check for horizontal blockage and leave
P:3F157:NoUnderHammerBro:if hammer bro is not standing on anything, set d0
P:3F159::in the enemy state to indicate jumping or falling, then leave
P:3F15E:ChkAboveEnemy
P:3F166:ClearBounceFlag2
P:3F168::clear bouncing flag by default
P:3F16B:FireballBGCollision:-------------------------------------------------------------------------------------\ncheck fireball's vertical coordinate
P:3F16F::if within the status bar area of the screen, branch ahead
P:3F171::set offset for block buffer adder data
P:3F175::add seven bytes to use
P:3F178::set A to return vertical coordinate
P:3F17A::save contents of A to stack
P:3F17B::save contents of Y here
P:3F17D::add horizontal coordinate
P:3F180::of object to value obtained using Y as offset
P:3F183::store here
P:3F185::of indirect here
P:3F190::store here and leave
P:3F192::get old contents of Y
P:3F194::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3F197::add it to value obtained using Y as offset
P:3F19A::mask out low nybble
P:3F19C::store result here
P:3F19E::use as offset for block buffer
P:3F19F::check current content of block buffer
P:3F1A1::and store here
P:3F1A3::get old contents of Y again
P:3F1A5::pull A from stack
P:3F1A6::if A = 1, branch
P:3F1A8::if A = 0, load vertical coordinate
P:3F1AA::and mask out high nybble
P:3F1AC::store masked out result here
P:3F1B3::get object offset
P:3F1B5::check to see if object bumped into anything
P:3F1BA:FY5
P:3F1BD:ClearBounceFlag3
P:3F1C0:xc1:otherwise load horizontal coordinate
P:3F1C2::and mask out high nybble
P:3F1C4::store masked out result here
P:3F1C8::and leave
P:3F1CB::get object offset
P:3F1CD::check to see if object bumped into anything
P:3F1CF::if nothing underneath fireball, branch
P:3F1D1::blank metatile used for vines?
P:3F1D5::hidden coin block?
P:3F20A::regular coin?
P:3F215::hidden 1-up block?
P:3F217::branch if any found
P:3F21B::branch if any found
P:3F23E::if fireball's vertical speed set to move upwards,
P:3F240::branch to set exploding bit in fireball's state
P:3F242::if bouncing flag already set,
P:3F244::branch to set exploding bit in fireball's state
P:3F251::otherwise set vertical speed to move upwards (give it bounce)
P:3F255::set bouncing flag
P:3F259::modify vertical coordinate to land it properly
P:3F25B::store as new vertical coordinate
P:3F25D:NSFn
P:3F25E:ClearBounceFlag:leave
P:3F260::clear bouncing flag by default
P:3F262::leave
P:3F263:InitFireballExplode
P:3F265::set exploding flag in fireball's state
P:3F269::load bump sound
P:3F26B::leave
P:3F26C:BlockBufferChk_Enemy:-------------------------------------------------------------------------------------\n$02 - modified y coordinate\n$03 - stores metatile involved in block buffer collisions\n$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate\n$05 - modified x coordinate\n$06-$07 - block buffer address
P:3F26D::inc PlayerFoot,x
P:3F270:BlockBufferChk_FBall:ResidualMiscObjectCode:\n      txa\n      clc           ;supposedly used once to set offset for\n      adc #$0d      ;miscellaneous objects\n      tax\n      ldy #$1b      ;supposedly used once to set offset for block buffer data\n      jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection\nset offset for block buffer adder data
P:3F274::add seven bytes to use
P:3F277:ResJmpM:set A to return vertical coordinate
P:3F279:BBChk_E:save contents of A to stack
P:3F27A::save contents of Y here
P:3F27C::add horizontal coordinate
P:3F27F::of object to value obtained using Y as offset
P:3F282::store here
P:3F284::of indirect here
P:3F28F::store here and leave
P:3F291::get old contents of Y
P:3F293::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3F296::add it to value obtained using Y as offset
P:3F299::mask out low nybble                  ;subtract 32 pixels for the status bar
P:3F29B::store result here
P:3F29D::use as offset for block buffer
P:3F29E::check current content of block buffer
P:3F2A0::and store here
P:3F2A2::get old contents of Y again
P:3F2A4::pull A from stack
P:3F2A5::if A = 1, branch
P:3F2A7::if A = 0, load vertical coordinate
P:3F2A9::and mask out high nybble
P:3F2AB::store masked out result here
P:3F2AD::get saved content of block buffer                       ;and leave
P:3F2B2::get object offset
P:3F2B7:xc:otherwise load horizontal coordinate
P:3F2B9::and mask out high nybble
P:3F2BB::store masked out result here
P:3F2BD::get saved content of block buffer                       ;and leave
P:3F2C2::get object offset
P:3F2C7:VineYPosAdder:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00 - offset to vine Y coordinate adder\n$02 - offset to sprite data
P:3F2C9:DrawVine:save offset here
P:3F2CB::get relative vertical coordinate
P:3F2CF::add value using offset in Y to get value
P:3F2D2::get offset to vine
P:3F2D5::get sprite data offset
P:3F2D8::store sprite data offset here
P:3F2DA::stack six sprites on top of each other vertically
P:3F2DD::get relative horizontal coordinate
P:3F2E0::store in first, third and fifth sprites
P:3F2EA::add six pixels to second, fourth and sixth sprites
P:3F2EC::to give characteristic staggered vine shape to
P:3F2EF::our vertical stack of sprites
P:3F2F5::set bg priority and palette attribute bits
P:3F2F7::set in first, third and fifth sprites
P:3F300::additionally, set horizontal flip bit
P:3F302::for second, fourth and sixth sprites
P:3F30B::set tiles for six sprites
P:3F30D:VineTL:set tile number for sprite
P:3F312::move offset to next sprite data
P:3F316::move onto next sprite
P:3F317::loop until all sprites are done
P:3F319::get original offset
P:3F31B::get offset to vine adding data
P:3F31D::if offset not zero, skip this part
P:3F321::set other tile number for top of vine
P:3F324:SkpVTop:start with the first sprite again
P:3F326:ChkFTop:get original starting vertical coordinate
P:3F32A::subtract top-most sprite's Y coordinate
P:3F32D::if two coordinates are less than 100/$64 pixels
P:3F32F::apart, skip this to leave sprite alone
P:3F333::otherwise move sprite offscreen
P:3F336:NextVSp:move offset to next OAM data
P:3F33A::move onto next sprite
P:3F33B::do this until all sprites are checked
P:3F33F::return offset set earlier
P:3F342:DrawHammer:-------------------------------------------------------------------------------------\nget misc object OAM data offset
P:3F348::if master timer control set, skip this part
P:3F34A::otherwise get hammer's state
P:3F34C::mask out d7
P:3F34E::check to see if set to 1 yet
P:3F350::if so, branch
P:3F352:ForceHPose:reset offset here
P:3F354::do unconditional branch to rendering part
P:3F356:GetHPose:get frame counter
P:3F358::move d3-d2 to d1-d0
P:3F35A::mask out all but d1-d0 (changes every four frames)
P:3F35C::use as timing offset
P:3F35D:RenderH:get relative vertical coordinate
P:3F361::add first sprite vertical adder based on offset
P:3F364::store as sprite Y coordinate for first sprite
P:3F368::add second sprite vertical adder based on offset
P:3F36B::store as sprite Y coordinate for second sprite
P:3F36E::get relative horizontal coordinate
P:3F372::add first sprite horizontal adder based on offset
P:3F375::store as sprite X coordinate for first sprite
P:3F379::add second sprite horizontal adder based on offset
P:3F37C::store as sprite X coordinate for second sprite
P:3F382::get and store tile number of first sprite
P:3F388::get and store tile number of second sprite
P:3F38E::get and store attribute bytes for both
P:3F391::note in this case they use the same data
P:3F394::get misc object offset
P:3F399::check offscreen bits
P:3F39B::if all bits clear, leave object alone
P:3F39F::otherwise nullify misc object state
P:3F3A3::and into first row sprites
P:3F3A9:NoHOffscr:leave
P:3F3AA:FlagpoleGfxHandler:-------------------------------------------------------------------------------------\n$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)\n$02 - used to hold Y coordinate for floatey number\n$03 - residual byte used for flip (but value set here affects nothing)\n$04 - attribute byte for floatey number\n$05 - used as X coordinate for floatey number\nget sprite data offset for flagpole flag
P:3F3AD::get relative horizontal coordinate
P:3F3B0::store as X coordinate for first sprite
P:3F3B4::add eight pixels and store
P:3F3B6::as X coordinate for second and third sprites
P:3F3BD::add twelve more pixels and
P:3F3BF::store here to be used later by floatey number
P:3F3C1::get vertical coordinate
P:3F3C3::and into first row sprites
P:3F3C6::and do sub to dump into first and second sprites
P:3F3C9::add eight pixels
P:3F3CB::and store into third sprite
P:3F3CE::get vertical coordinate for floatey number
P:3F3D1::store it here
P:3F3D5::set value for flip which will not be used, and
P:3F3D7::attribute byte for floatey number
P:3F3D9::set attribute bytes for all three sprites
P:3F3E4::put triangle shaped tile
P:3F3E7::into first and third sprites
P:3F3EC::put skull tile into second sprite
P:3F3EF::get vertical coordinate at time of collision
P:3F3F2::if zero, branch ahead
P:3F3F5::add 12 bytes to sprite data offset
P:3F3F8::put back in Y
P:3F3F9::get offset used to award points for touching flagpole
P:3F3FC::multiply by 2 to get proper offset here
P:3F3FE::get appropriate tile data
P:3F406::use it to render floatey number
P:3F409:ChkFlagOffscreen:get object offset for flag
P:3F40B::get OAM data offset
P:3F40E::get offscreen bits
P:3F411::mask out all but d3-d1
P:3F413::if none of these bits set, branch to leave
P:3F415:MoveSixSpritesOffscreen:-------------------------------------------------------------------------------------\nset offscreen coordinate if jumping here
P:3F417:DumpSixSpr:dump A contents
P:3F41A::into third row sprites
P:3F41D:DumpFourSpr:into second row sprites
P:3F420:DumpThreeSpr
P:3F423:DumpTwoSpr:and into first row sprites
P:3F429:ExitDumpSpr
P:3F42A:DrawLargePlatform:-------------------------------------------------------------------------------------\nget OAM data offset
P:3F42D::store here
P:3F42F::add 3 to it for offset
P:3F430::to X coordinate
P:3F432::get horizontal relative coordinate
P:3F435::store X coordinates using A as base, stack horizontally
P:3F43A::get vertical coordinate
P:3F43C::dump into first four sprites as Y coordinate
P:3F442::check for castle-type level
P:3F446::check for secondary hard mode flag set
P:3F449::branch if not set elsewhere
P:3F44B:ShrinkPlatform:load offscreen coordinate if flag set or castle-type level
P:3F44D:SetLast2Platform:get OAM data offset
P:3F450::store vertical coordinate or offscreen
P:3F453::coordinate into last two sprites as Y coordinate
P:3F456::load default tile for platform (girder)
P:3F45B::if cloud level override flag not set, use
P:3F45D::otherwise load other tile for platform (puff)
P:3F45F:SetPlatformTilenum:get enemy object buffer offset
P:3F461::increment Y for tile offset
P:3F462::dump tile number into all six sprites
P:3F465::set palette controls
P:3F467::increment Y for sprite attributes
P:3F468::dump attributes into all six sprites
P:3F46B::increment X for enemy objects
P:3F46C::get offscreen bits again
P:3F470::get OAM data offset
P:3F473::rotate d7 into carry, save remaining
P:3F474::bits to the stack
P:3F477::if d7 was set, move first sprite offscreen
P:3F47C:SChk2:get bits from stack
P:3F47D::rotate d6 into carry
P:3F47E::save to stack
P:3F481::if d6 was set, move second sprite offscreen
P:3F486:SChk3:get bits from stack
P:3F487::rotate d5 into carry
P:3F488::save to stack
P:3F48B::if d5 was set, move third sprite offscreen
P:3F490:SChk4:get bits from stack
P:3F491::rotate d4 into carry
P:3F492::save to stack
P:3F495::if d4 was set, move fourth sprite offscreen
P:3F49A:SChk5:get bits from stack
P:3F49B::rotate d3 into carry
P:3F49C::save to stack
P:3F49F::if d3 was set, move fifth sprite offscreen
P:3F4A4:SChk6:get bits from stack
P:3F4A5::rotate d2 into carry
P:3F4A6::save to stack
P:3F4AA::if d2 was set, move sixth sprite offscreen
P:3F4AD:SLChk:check d7 of offscreen bits
P:3F4B0::and if d7 is not set, skip sub
P:3F4B3::otherwise branch to move all sprites offscreen
P:3F4B6:ExDLPl
P:3F4B7:MovePlayerVertically:-------------------------------------------------------------------------------------\nleave\nset X for player offset
P:3F4BC::if master timer control set, branch ahead
P:3F4BE:NoJSChk:lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating\nbne +                   ;branch to leave if so\ndump vertical force 
P:3F4C3::set maximum vertical speed here
P:3F4C5::then jump to move player vertically
P:3F4C8:MoveEnemyHorizontally:increment offset for enemy offset
P:3F4C9::position object horizontally according to
P:3F4CC:SignDoStuff
P:3F4E9:InitBlock_XY_Pos:--------------------------------\nget player's horizontal coordinate
P:3F4EC::add eight pixels
P:3F4EE::mask out low nybble to give 16-pixel correspondence
P:3F4F0::save as horizontal coordinate for block object
P:3F4F4::add carry to page location of player
P:3F4F6::save as page location of block object
P:3F4F8::save elsewhere to be used later
P:3F4FD::save vertical high byte of player into
P:3F4FF::vertical high byte of block object and leave
P:3F500:DrawEnemyObjRow:load two tiles of enemy graphics
P:3F508:DrawOneSpriteRow
P:3F50A::draw them\n first sprite is not blank, branch\n second sprite is not blank, branch\n move the (blank) sprites offscreen\ndraw them
P:3F50E:DrawSpriteObject:get saved flip control bits
P:3F511::move d1 into carry
P:3F514::if d1 not set, branch
P:3F516::store first tile into second sprite
P:3F519::and second into first sprite
P:3F51E::activate horizontal flip OAM attribute
P:3F520::and unconditionally branch
P:3F522:NoHFlip:store first tile into first sprite
P:3F525::and second into second sprite
P:3F52A::clear bit for horizontal flip
P:3F52C:SetHFAt:add other OAM attributes if necessary
P:3F52E::store sprite attributes
P:3F534::now the y coordinates
P:3F536::note because they are
P:3F539::side by side, they are the same
P:3F53E::store x coordinate, then
P:3F541::add 8 pixels and store another to
P:3F542::put them side by side
P:3F547::add eight pixels to the next y
P:3F549::coordinate
P:3F54E::add eight to the offset in Y to
P:3F54F::move to the next two sprites
P:3F553::increment offset to return it to the
P:3F554::routine that called this subroutine
P:3F556:DefaultBlockObjTiles:-------------------------------------------------------------------------------------\n$00-$01 - tile numbers\n$02 - relative Y position\n$03 - horizontal flip flag (not used here)\n$04 - attributes\n$05 - relative X position\nbrick w/ line (these are sprite tiles, not BG!)
P:3F55B:DrawBlock:get relative vertical coordinate of block object
P:3F55E::store here
P:3F560::get relative horizontal coordinate of block object
P:3F563::store here
P:3F567::set attribute byte here
P:3F56A::set horizontal flip bit here (will not be used)
P:3F56C::get sprite data offset
P:3F56F::reset X for use as offset to tile data
P:3F571:DBlkLoop:get left tile number
P:3F574::set here
P:3F576::get right tile number
P:3F579::do sub to write tile numbers to first row of sprites
P:3F57C::check incremented offset
P:3F57E::and loop back until all four sprites are done
P:3F580::get block object offset
P:3F582::get sprite data offset
P:3F588::check for ground level type area
P:3F58A::if found, branch to next part
P:3F58E::otherwise remove brick tiles with lines
P:3F591::and replace then with lineless brick tiles
P:3F594:ChkRep:lda Cbolla,x\nbne +\ncheck replacement metatile
P:3F59B::if not used block metatile, then
P:3F59D::branch ahead to use current graphics
P:3F59F::set A for used block tile
P:3F5A1::increment Y to write to tile bytes
P:3F5A2::into second row sprites
P:3F5A8::and into first row sprites
P:3F5AE::return Y to original offset
P:3F5AF::set palette bits
P:3F5B4::check for ground level type area again
P:3F5B5::if found, use current palette bits
P:3F5B7::otherwise set to $01
P:3F5B8:SetBFlip:put block object offset back in X
P:3F5BA::store attribute byte as-is in first sprite
P:3F5BF::set horizontal flip bit for second sprite
P:3F5C4::set both flip bits for fourth sprite
P:3F5C9::set vertical flip bit for third sprite
P:3F5CC:BlkOffscr:get offscreen bits for block object
P:3F5CF::save to stack
P:3F5D0::check to see if d2 in offscreen bits are set
P:3F5D2::if not set, branch, otherwise move sprites offscreen
P:3F5D4::move offscreen two OAMs
P:3F5D6::on the right side
P:3F5DC:PullOfsB:pull offscreen bits from stack
P:3F5DD:ChkLeftCo:check to see if d3 in offscreen bits are set
P:3F5DF::if not set, branch, otherwise move sprites offscreen
P:3F5E1:MoveColOffscreen:move offscreen two OAMs
P:3F5E3::on the left side (or two rows of enemy on either side
P:3F5E6::if branched here from enemy graphics handler)
P:3F5E9:ExDBlk
P:3F5EA:Parallax:-------------------------------------------------------------------------------------\n$00 - used to hold palette bits for attribute byte or relative X position\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\nunderground
P:3F5F6::castle
P:3F602:ResetOffsetParallax
P:3F604::reset parallax and continue
P:3F607:MakeParallax
P:3F626::branch if AreaType not underground or castle
P:3F633::do parallax
P:3F64C::set no-parallax CHR
P:3F669:SprObjectOffscrChk:get enemy buffer offset
P:3F66B::check offscreen information
P:3F66F::shift three times to the right
P:3F670::which puts d2 into carry
P:3F671::save to stack
P:3F672::branch if not set
P:3F674::set for right column sprites
P:3F676::add A to enemy object OAM data offset
P:3F67A::use as offset
P:3F67B::move offscreen two OAMs
P:3F67D::on the left side (or two rows of enemy on either side
P:3F680::if branched here from enemy graphics handler)
P:3F683::move third row sprite in column offscreen
P:3F686:LcChk:get from stack
P:3F687::move d3 to carry
P:3F688::save to stack
P:3F689::branch if not set
P:3F68B::set for left column sprites,
P:3F68D::add A to enemy object OAM data offset
P:3F691::use as offset
P:3F692::move offscreen two OAMs
P:3F694::on the left side (or two rows of enemy on either side
P:3F697::if branched here from enemy graphics handler)
P:3F69A::move third row sprite in column offscreen
P:3F69D:Row3C:get from stack again
P:3F69E::move d5 to carry this time
P:3F6A0::save to stack again
P:3F6A1::branch if carry not set
P:3F6A3::set for third row of sprites
P:3F6A5::add A to enemy object OAM data offset
P:3F6A9::use as offset
P:3F6AC::and into first row sprites
P:3F6B2:Row23C:get from stack
P:3F6B3::move d6 into carry
P:3F6B4::save to stack
P:3F6B7::set for second and third rows
P:3F6B9::add A to enemy object OAM data offset
P:3F6BD::use as offset
P:3F6C0::and into first row sprites
P:3F6C6:AllRowC:get from stack once more
P:3F6C7::move d7 into carry
P:3F6CA::add A to enemy object OAM data offset
P:3F6CE::use as offset
P:3F6D1::and into first row sprites
P:3F6D9::check enemy identifier for podoboo
P:3F6DB::skip this part if found, we do not want to erase podoboo!
P:3F6E3::check high byte of vertical position
P:3F6E5::if not yet past the bottom of the screen, branch
P:3F6F8::what it says
P:3F6FB:ExEGHandler
P:3F6FC:AreaParallax
P:3F6FE:WorldPaletteLUT
P:3F707:CheckForCoinMTiles:-------------------------------------------------------------------------------------
P:3F70E::check for regular coin
P:3F710::branch if found
P:3F712::otherwise clear carry and leave
P:3F713:CoinSd
P:3F726:SmallPlatformCollision:------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00 - used to store player's vertical offscreen bits\ntiles arranged in order, 2 tiles per row, top to bottom\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames\n$02 - vertical position\n$03 - facing direction, used as horizontal flip control\n$04 - attributes\n$05 - horizontal position\n$07 - number of rows to draw\nthese also used in IntermediatePlayerData\nif master timer control set,
P:3F729::branch to leave
P:3F72B::otherwise initialize collision flag
P:3F72E::do a sub to see if player is below a certain point
P:3F731::or entirely offscreen, and branch to leave if true
P:3F735::load counter here for 2 bounding boxes
P:3F737:ChkSmallPlatLoop:get enemy object offset
P:3F739::get enemy object buffer offset
P:3F73B::multiply A by four, then add four
P:3F73C::to skip player's bounding box
P:3F740::send to Y
P:3F741::get offscreen bits for enemy object
P:3F744::save low nybble
P:3F746::check for all bits set
P:3F748::if d1 of offscreen lower nybble bits was set
P:3F74A::then branch to leave
P:3F74C::check top of platform's bounding box for being
P:3F74F::above a specific point
P:3F751::if so, branch, don't do collision detection
P:3F753::otherwise, perform player-to-platform collision detection
P:3F756::skip ahead if collision
P:3F758:MoveBoundBox:move bounding box vertical coordinates
P:3F75B::128 pixels downwards
P:3F76A::decrement counter we set earlier
P:3F76C::loop back until both bounding boxes are checked
P:3F76E:ExSPC:get enemy object buffer offset, then leave
P:3F771:ProcSPlatCollisions:return enemy object buffer offset to X, then continue
P:3F776:JumpEngineOthersTemp:-------------------------------------------------------------------------------------\n$00 - used as temp variable to hold offscreen bits\n--------------------------------\n(these apply to these three subsections)\n$04 - used to store proper offset\n$05 - used as adder in DividePDiff\n$06 - used to store preset value used to compare to pixel difference in $07\n$07 - used to store difference between coordinates of object and screen edges\n--------------------------------\n-------------------------------------------------------------------------------------\n$04 - address low to jump address\n$05 - address high to jump address\n$06 - jump address low\n$07 - jump address high
P:3F78A::shift bit from contents of A
P:3F78C::pull saved return address from stack
P:3F78D::save to indirect
P:3F793::load pointer from indirect
P:3F795::note that if an RTS is performed in next routine
P:3F797::it will return to the execution before the sub
P:3F798::that called this routine
P:3F79C::jump to the address we loaded
P:3F79F:JumpEngine:shift bit from contents of A
P:3F7A1::pull saved return address from stack
P:3F7A2::save to indirect
P:3F7A8::load pointer from indirect
P:3F7AA::note that if an RTS is performed in next routine
P:3F7AC::it will return to the execution before the sub
P:3F7AD::that called this routine
P:3F7B1::jump to the address we loaded
P:3F7B4:Reset: $FFFC-$FFFD reset vector new location, & bankswap to $4058 to load MMC3's setups
P:3F7C4:RunPauseMenu:InitEnemyRoutines1:\n		lda #$04\n		jsr BankSwap\n		ldx ObjectOffset\n		lda Enemy_ID,x\n		jsr InitEnemyRoutines\n		jmp RestoreBank
P:3F7CF:RunStuff
P:3F7DA:MoveSpritesOffscreen
P:3F7E5:_GetAreaMusic
P:3F7F0:LoadAreaPointer
P:3F7FB:InitPodoboo2
P:3F806:GetAreaDataAddrs
P:3F811:AreaParserTaskHandler1
P:3F81C:ProcLoopCommand1
P:3F827:InitEnemyRoutines1
P:3F836:SetupTextbox1
P:3F841:EnemyGfxHandler
P:3F84C:GameOverMenu1
P:3F857:RestoreBank: restores $10-$4000 rom, back to $8000-$BFFF ram (4CAAF2)
P:3F85C:RestoreBank1: restores $10-$4000 rom, back to $8000-$BFFF ram (4CAAF2)
P:3F861::get saved content of block buffer
P:3F867:BankSwapCore
P:3F869:BankSwap: continue to BankSwap\nbankswap routine (A9## 20B0F2)
P:3F86C:Ostia3
P:3F896:StatusBarData: top score display on title screen
P:3F898:: player score
P:3F89C:: coin tally
P:3F8A0:: game timer
P:3F8A4:StatusBarOffset
P:3F8AB:InitializeMemory: Below are some wrappers for core routines\n They have been moved to the "Core" bank, used for\n Self-contained routines that probably won't change\n much.
P:3F8AE:ReadJoypads
P:3F8B7:InitializeNameTables
P:3F8C0:CopyToAllPlayers:DemoEngine:\n       jsr BankSwapCore\n       jsr _DemoEngine\n       jmp RestoreBank\n Routines from handlePlayerData.asm\njsr BankSwapCore\njsr _LoadPlayerData\njmp RestoreBank\njsr BankSwapCore\njsr _SavePlayerData\njmp RestoreBank\njsr BankSwapCore\njsr _WipePlayerData\njmp RestoreBank
P:3F8C0:LoadPlayerData
P:3F8C0:SavePlayerData
P:3F8C0:WipePlayerData
P:3F8C1:handleSound:tay\njsr BankSwapCore\njsr _CopyToAllPlayers\njmp RestoreBank\n Having issue with this one.\nProcessWhirlpools:\njsr BankSwapCore\n       jmp _ProcessWhirlpools\nrts\njmp RestoreBank\njmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return\ninclude code\whirlpools.asm\n-------------------------------------------------------------------------------------
P:3F8CF:RNG:shitty rng
P:3F8D3::get first memory location of LSFR bytes
P:3F8D6::mask out all but d1
P:3F8D8::save here
P:3F8DA::get second memory location
P:3F8DD::mask out all but d1
P:3F8DF::perform exclusive-OR on d1 from first and second bytes
P:3F8E1::if neither or both are set, carry will be clear
P:3F8E4::if one or the other is set, carry will be set
P:3F8E5:RotPRandomBit:rotate carry into d7, and rotate last bit into carry
P:3F8F0::increment to next byte
P:3F8F1::decrement for loop
P:3F8F5:RNG_call: thx nesdev for the rng
P:3F8F8::store copy of high byte
P:3F8F9:: compute seed+1 ($39>>1 = %11100)\nshift to consume zeroes on left...
P:3F8FC::now recreate the remaining bits in reverse order... %111
P:3F907::recombine with original low byte
P:3F90D:: compute seed+0 ($39 = %111001)\noriginal high byte
P:3F923:FlagpoleScoreNumTiles
P:3F92D:ExplosionTiles
P:3F930:PlayerStarting_X_Pos
P:3F934:AltYPosOffset
P:3F936:PlayerStarting_Y_Pos
P:3F93F:PlayerBGPriorityData
P:3F947:GameTimerData:dummy byte, used as part of bg priority data
P:3F94B:GameTimerSec
P:3F94F:ForceThing
P:3F953:LevelSelectAreasOffsets
P:3F977:IRQ:_FamiToneMusicPlay:\n		pha\n		lda #BANK_SOUND\n		jsr Ostia3\n		pla\n		jsr FamiToneMusicPlay\n		lda currentBank\n		jmp BankSwap\n_FamitoneInit:\n		lda #BANK_SOUND\n		jsr Ostia3\n		jsr FamiToneInit\n		lda currentBank\n		jmp BankSwap\nif USEIRQ == 1\nendif\nsei
P:3F978::lda $00\npha
P:3F9B3:ThirdIRQ_
P:3F9E6:Exitante
P:3F9FF:SecondIRQ
P:3FA03::delay HBLANK
P:3FA06::7 cycles per loop
P:3FA0D::delay HBLANK
P:3FA2A::HBLANK starts here
P:3FA42::x doesnt matter
P:3FA7A::lda #%00001010\nsta PPU_CTRL_REG2\nsta Mirror_PPU_CTRL_REG2\nlda #%00001100\nsta PPU_ADDRESS\nlda #$01\nsta PPU_SCROLL_REG\nlda #$00\nsta PPU_SCROLL_REG\nsta PPU_ADDRESS
P:3FA96:ThirdIRQ
P:3FAD0:FourthIRQ
P:3FAF4:EndIRQ
P:3FAF8::pla\nsta $00
P:3FAF9::cli
P:3FAFA:WriteBufferToScreen:-------------------------------------------------------------------------------------\n$00 - vram buffer address table low\n$01 - vram buffer address table high\nWriteBufferToScreen1:\n               sta PPU_ADDRESS           ;store high byte of vram address\n               iny\n               lda ($00),y               ;load next byte (second)\n               sta PPU_ADDRESS           ;store low byte of vram address\n               iny\n               lda ($00),y               ;load next byte (third)\n               asl                       ;shift to left and save in stack\n               pha\n               lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,\n               ora #%00000100            ;set ppu to increment by 32 by default\n               bcs SetupWrites1           ;if d7 of third byte was clear, ppu will\n               and #%11101011            ;only increment by 1\nSetupWrites1:  sta PPU_CTRL_REG1         ;write contents of A to PPU register 1\n               sta Mirror_PPU_CTRL_REG1  ;and its mirror\n               pla                       ;pull from stack and shift to left again\n               asl\n               bcc GetLength1             ;if d6 of third byte was clear, do not repeat byte\n               ora #%00000010            ;otherwise set d1 and increment Y\n               iny\nGetLength1:    lsr                       ;shift back to the right to get proper length\n               lsr                       ;note that d1 will now be in carry\n               tax\nOutputToVRAM1: bcs RepeatByte1            ;if carry set, repeat loading the same byte\n               iny                       ;otherwise increment Y to load next byte\nRepeatByte1:   lda ($00),y               ;load more data from buffer and write to vram\n			   jmp WriteArea\nH23:		   sta PPU_DATA\n               dex                       ;done writing?\n               bne OutputToVRAM1\n			   jmp +\nWriteArea:\n		  php\n		  cpy #$06\n		  bne H24\n		  pha		  \n		  lda AreaType\n		  cmp #$02\n		  bcs Cont\n		  pla\nH24:	  plp\n		  jmp H23\nCont:\n		  pla\n		  lda AreaType\n		  cmp #$02\n		  beq +\n		  lda #$2d\n		  plp\n		  jmp H23\n+:		  lda #$0c\n		  plp\n		  jmp H23\nstore high byte of vram address
P:3FAFE::load next byte (second)
P:3FB00::store low byte of vram address
P:3FB04::load next byte (third)
P:3FB06::shift to left and save in stack
P:3FB08::load mirror of $2000,
P:3FB0B::set ppu to increment by 32 by default
P:3FB0D::if d7 of third byte was clear, ppu will
P:3FB0F::only increment by 1
P:3FB11:SetupWrites:write contents of A to PPU register 1
P:3FB14::and its mirror
P:3FB17::pull from stack and shift to left again
P:3FB19::if d6 of third byte was clear, do not repeat byte
P:3FB1B::otherwise set d1 and increment Y
P:3FB1E:GetLength:shift back to the right to get proper length
P:3FB1F::note that d1 will now be in carry
P:3FB21:OutputToVRAM:if carry set, repeat loading the same byte
P:3FB23::otherwise increment Y to load next byte
P:3FB24:RepeatByte:load more data from buffer and write to vram
P:3FB29::done writing?
P:3FB2E::add end length plus one to the indirect at $00
P:3FB30::to allow this routine to read another set of updates
P:3FB38::sets vram address to $3f00
P:3FB42::then reinitializes it for some reason
P:3FB45:UpdateScreen:reset flip-flop
P:3FB48::load first byte from indirect as a pointer
P:3FB4C::if byte is zero we have no further updates to make here
P:3FB4E::ldx VRAM_Buffer_AddrCtrl\ncpx #$09\nbeq WriteBufferToScreen2\ncpx #$0a\nbeq WriteBufferToScreen2\ncpx #$0b\nbeq WriteBufferToScreen2
P:3FB51:InitScroll:jmp WriteBufferToScreen1\nstore contents of A into scroll registers
P:3FB51:WriteBufferToScreen2
P:3FB54::and end whatever subroutine led us here
P:3FB6A:WritePPUReg1:-------------------------------------------------------------------------------------\nwrite contents of A to PPU register 1
P:3FB6D::and its mirror
P:3FB71:: This is just here to show how much free space is in this spot in the list file.
P:3FB73::-------------------------------------------------------------------------------------\nINTERRUPT VECTORS
P:3FFF9:Vectors
R:0000:BLANK_SPRITE_MOD
R:0000:BOUNDBOX_FIX
R:0000:CHEATS
R:0000:CHEAT_LEVEL_SKIP
R:0000:CHEAT_NO_INJURY
R:0000:CHEAT_REMOVE_TIMER
R:0000:CHEAT_START_FIERY
R:0000:CHEAT_WORLD_SELECT
R:0000:CHEEPCHEEP_FIX
R:0000:DPCM
R:0000:EXTRA_BOUNCE
R:0000:Enablew1l1PiranhaPlants
R:0000:GreenKoopa
R:0000:IMPORT_LEVELS
R:0000:INFINITE_LIVES
R:0000:JUMPSPRING_FIX2
R:0000:Koopa
R:0000:Level1
R:0000:LevelDataOffset
R:0000:MHD
R:0000:MINUS_WORLD_FIX
R:0000:MusicHeaderOffsetData
R:0000:PLAYER_COLLISION_FIX
R:0000:SKIP_INTERMEDIATE
R:0000:SKIP_TITLE
R:0000:START_WORLD
R:0000:SwimTileRepOffset
R:0000:TEST_LUIGI
R:0000:TEST_PLAYER
R:0000:TIM_GRUNT
R:0000:TitleScreenModeValue
R:0000:USEIRQ
R:0000:WATER_SPEED_FIX
R:0000:WORLD9_PIPE_FIX
R:0000:World1
R:0000:_temp
R:0000:shufflelevels
R:0001:BATTERY
R:0001:DEMO_FEATURES
R:0001:DeathMusic
R:0001:DemotedRPTroopa
R:0001:GAME_OVER_MENU
R:0001:GameModeValue
R:0001:GroundMusic
R:0001:JUMPSPRING_FIX
R:0001:LIVES_FIX
R:0001:LUIGI_PALETTE_DX
R:0001:LUIGI_PHYSICS
R:0001:Level2
R:0001:Right_Dir
R:0001:SKID_SFX
R:0001:SOUND
R:0001:SPINYFIX
R:0001:START_LEVEL
R:0001:Sfx_BigJump
R:0001:Sfx_BrickShatter
R:0001:Sfx_CoinGrab
R:0001:Unlock9Steps
R:0001:World2
R:0002:BANK_SOUND
R:0002:BuzzyBeetle
R:0002:GameOverMusic
R:0002:Left_Dir
R:0002:Level3
R:0002:NumberOfCharacters
R:0002:Sfx_BowserFlame
R:0002:Sfx_Bump
R:0002:Sfx_GrowPowerUp
R:0002:VictoryModeValue
R:0002:WaterMusic
R:0002:World3
R:0003:BANK_CORE
R:0003:GameOverModeValue
R:0003:Level4
R:0003:RedKoopa
R:0003:World4
R:0004:Down_Dir
R:0004:GrabState
R:0004:KoopaShell
R:0004:SecHardModeWorld
R:0004:Sfx_EnemyStomp
R:0004:Sfx_GrowVine
R:0004:UndergroundMusic
R:0004:VictoryMusic
R:0004:World5
R:0005:HammerBro
R:0005:World6
R:0006:Goomba
R:0006:World7
R:0007:Bloober
R:0007:FinalWorld
R:0007:World8
R:0008:BulletBill_FrenzyVar
R:0008:CastleMusic
R:0008:EndOfCastleMusic
R:0008:ObjectOffset
R:0008:Sfx_Blast
R:0008:Sfx_EnemySmack
R:0008:Up_Dir
R:0008:World9
R:0009:FastGoomba
R:0009:FrameCounter
R:000A:A_B_Buttons
R:000A:FirstLevelBank
R:000A:GreyCheepCheep
R:000B:RedCheepCheep
R:000B:Up_Down_Buttons
R:000C:Left_Right_Buttons
R:000C:Podoboo
R:000C:Sfx_PSwitchOut
R:000D:PiranhaPlant
R:000D:PreviousA_B_Buttons
R:000E:GameEngineSubroutine
R:000E:GreenParatroopaJump
R:000F:Enemy_Flag
R:000F:RedParatroopa
R:0010:AltGameOverMusic
R:0010:BLOOPER_DISTANCE
R:0010:CloudMusic
R:0010:GreenParatroopaFly
R:0010:Sfx_PipeDown_Injury
R:0010:Sfx_TimerTick
R:0010:Start_Button
R:0011:Lakitu
R:0012:Spiny
R:0013:BlackParatroopa
R:0014:FlyCheepCheepFrenzy
R:0014:FlyingCheepCheep
R:0015:BowserFlame
R:0015:Enemy_ID
R:0016:Fireworks
R:0017:BBill_CCheep_Frenzy
R:0018:Sfx_EnemySmackOr
R:0018:Stop_Frenzy
R:0019:RedKoopaShell
R:001B:Player_State
R:001B:SprObject_State
R:001C:Enemy_State
R:0020:EndOfLevelMusic
R:0020:PipeIntroMusic
R:0020:RedPiranhaPlant
R:0020:Select_Button
R:0020:Sfx_Fireball
R:0020:Sfx_PowerUpGrab
R:0021:UDPiranhaPlant
R:0022:Fireball_State
R:0022:RUDPiranhaPlant
R:0024:Block_State
R:0028:Misc_State
R:002D:Bowser
R:002E:PowerUpObject
R:002F:VineObject
R:0030:FlagpoleFlagObject
R:0031:PlayerFacingDir
R:0031:StarFlagObject
R:0032:FirebarSpinDirection
R:0032:JumpspringObject
R:0033:BulletBill_CannonVar
R:0035:RetainerObject
R:0037:DestinationPageLoc
R:0038:VictoryWalkControl
R:0039:PowerUpType
R:003A:FireballBouncingFlag
R:003C:HammerBroJumpTimer
R:0040:B_Button
R:0040:Sfx_ExtraLife
R:0040:Sfx_Flagpole
R:0040:Sign
R:0040:StarPowerMusic
R:0040:TimeRunningOutMusic
R:0041:ScrollLockEnemy
R:0042:BBillSpawner
R:0042:Player_MovingDir
R:0043:Enemy_MovingDir
R:0043:LastEnemyID
R:0043:PltRem
R:0049:Player_X_Speed
R:0049:SprObject_X_Speed
R:004A:BlooperMoveSpeed
R:004A:CheepCheepMoveMFlag
R:004A:Enemy_X_Speed
R:004A:ExplosionGfxCounter
R:004A:FirebarSpinState_Low
R:004A:Jumpspring_FixedYPos
R:004A:LakituMoveSpeed
R:004A:PiranhaPlant_Y_Speed
R:004A:RedPTroopaCenterYPos
R:004A:XMoveSecondaryCounter
R:004A:YPlatformCenterYPos
R:0050:Fireball_X_Speed
R:0052:Block_X_Speed
R:0056:Misc_X_Speed
R:005F:PSwitchMusic
R:005F:Player_PageLoc
R:005F:SprObject_PageLoc
R:0060:Enemy_PageLoc
R:0066:Fireball_PageLoc
R:0068:Block_PageLoc
R:006C:Misc_PageLoc
R:0075:Bubble_PageLoc
R:0078:Player_X_Position
R:0078:SprObject_X_Position
R:0079:Enemy_X_Position
R:007F:Fireball_X_Position
R:007F:UP
R:0080:A_Button
R:0080:LEFT
R:0080:Sfx_BowserFall
R:0080:Sfx_SmallJump
R:0080:Silence
R:0081:Block_X_Position
R:0081:DOWN
R:0082:RIGHT
R:0083:Abutton
R:0084:Bbutton
R:0085:Misc_X_Position
R:008E:Bubble_X_Position
R:0091:Player_Y_Speed
R:0091:SprObject_Y_Speed
R:0092:BlooperMoveCounter
R:0092:Enemy_Y_Speed
R:0092:FirebarSpinState_High
R:0092:LakituMoveDirection
R:0092:PiranhaPlant_MoveFlag
R:0092:XMovePrimaryCounter
R:0098:Fireball_Y_Speed
R:009A:Block_Y_Speed
R:009E:Misc_Y_Speed
R:00A7:Player_Y_HighPos
R:00A7:SprObject_Y_HighPos
R:00A8:Enemy_Y_HighPos
R:00AE:Fireball_Y_HighPos
R:00B0:Block_Y_HighPos
R:00B4:Misc_Y_HighPos
R:00BD:Bubble_Y_HighPos
R:00C0:ContinueMenuSelect
R:00C0:Player_Y_Position
R:00C0:SprObject_Y_Position
R:00C1:Enemy_Y_Position
R:00C7:Fireball_Y_Position
R:00C9:Block_Y_Position
R:00CD:Misc_Y_Position
R:00D6:Bubble_Y_Position
R:00D6:WarmBootOffset
R:00D9:AreaData
R:00D9:AreaDataLow
R:00DA:AreaDataHigh
R:00DB:EnemyData
R:00DB:EnemyDataLow
R:00DC:EnemyDataHigh
R:00DD:temp1
R:00DE:temp2
R:00DF:temp3
R:00E0:temp4
R:00E1:NoteLenLookupTblOfs
R:00E2:Square1SoundBuffer
R:00E3:Square2SoundBuffer
R:00E4:NoiseSoundBuffer
R:00E5:AreaMusicBuffer
R:00E6:MusicData
R:00E6:MusicDataLow
R:00E7:MusicDataHigh
R:00E8:MusicOffset_Square2
R:00E9:MusicOffset_Square1
R:00EA:MusicOffset_Triangle
R:00EB:PauseSoundQueue
R:00EC:AreaMusicQueue
R:00ED:EventMusicQueue
R:00EE:NoiseSoundQueue
R:00EF:Square2SoundQueue
R:00F0:Square1SoundQueue
R:00F1:skipNMI
R:00FE:ColdBootOffset
R:0109:VerticalFlipFlag
R:010D:FlagpoleFNum_Y_Pos
R:010E:FlagpoleFNum_YMFDummy
R:010F:FlagpoleScore
R:0110:FloateyNum_Control
R:0117:FloateyNum_X_Pos
R:011E:FloateyNum_Y_Pos
R:0125:ShellChainCounter
R:012C:FloateyNum_Timer
R:0134:DigitModifier
R:0200:Sprite_Data
R:0200:Sprite_Y_Position
R:0201:Sprite_Tilenumber
R:0202:Sprite_Attributes
R:0203:Sprite_X_Position
R:0388:FirebarSpinSpeed
R:0398:VineFlagOffset
R:0399:VineHeight
R:039A:VineObjOffset
R:039D:VineStart_Y_Position
R:03A0:BalPlatformAlignment
R:03A1:Platform_X_Scroll
R:03A2:HammerThrowingTimer
R:03A2:PlatformCollisionFlag
R:03AD:Player_Rel_XPos
R:03AD:SprObject_Rel_XPos
R:03AE:Enemy_Rel_XPos
R:03AF:Fireball_Rel_XPos
R:03B0:Bubble_Rel_XPos
R:03B1:Block_Rel_XPos
R:03B3:Misc_Rel_XPos
R:03B8:Player_Rel_YPos
R:03B8:SprObject_Rel_YPos
R:03B9:Enemy_Rel_YPos
R:03BA:Fireball_Rel_YPos
R:03BB:Bubble_Rel_YPos
R:03BC:Block_Rel_YPos
R:03BE:Misc_Rel_YPos
R:03C4:Player_SprAttrib
R:03C4:SprObject_SprAttrib
R:03C5:Enemy_SprAttrib
R:03D0:Player_OffscreenBits
R:03D0:SprObject_OffscrBits
R:03D1:Enemy_OffscreenBits
R:03D2:FBall_OffscreenBits
R:03D3:Bubble_OffscreenBits
R:03D4:Block_OffscreenBits
R:03D6:Misc_OffscreenBits
R:03D8:EnemyOffscrBitsMasked
R:03E4:Block_Orig_YPos
R:03E6:Block_BBuf_Low
R:03E8:Block_Metatile
R:03EA:Block_PageLoc2
R:03EC:Block_RepFlag
R:03EE:SprDataOffset_Ctrl
R:03F0:Block_ResidualCounter
R:03F1:Block_Orig_XPos
R:03F9:AttributeBuffer
R:0400:SprObject_X_MoveForce
R:0401:Enemy_X_MoveForce
R:0401:RedPTroopaOrigXPos
R:0401:YPlatformTopYPos
R:0416:Player_YMF_Dummy
R:0416:SprObject_YMF_Dummy
R:0417:BowserFlamePRandomOfs
R:0417:Enemy_YMF_Dummy
R:0417:PiranhaPlantUpYPos
R:042C:Bubble_YMF_Dummy
R:0433:Player_Y_MoveForce
R:0433:SprObject_Y_MoveForce
R:0434:CheepCheepOrigYPos
R:0434:Enemy_Y_MoveForce
R:0434:PiranhaPlantDownYPos
R:043C:Block_Y_MoveForce
R:0450:MaximumLeftSpeed
R:0456:MaximumRightSpeed
R:046A:Cannon_Offset
R:046A:Whirlpool_Offset
R:046B:Cannon_PageLoc
R:046B:Whirlpool_PageLoc
R:0471:Cannon_X_Position
R:0471:Whirlpool_LeftExtent
R:0477:Cannon_Y_Position
R:0477:Whirlpool_Length
R:047D:Cannon_Timer
R:047D:Whirlpool_Flag
R:0483:BowserHitPoints
R:0484:StompChainCounter
R:0490:Player_CollisionBits
R:0491:Enemy_CollisionBits
R:0499:Player_BoundBoxCtrl
R:0499:SprObj_BoundBoxCtrl
R:049A:Enemy_BoundBoxCtrl
R:04A0:Fireball_BoundBoxCtrl
R:04A2:Misc_BoundBoxCtrl
R:04AC:BoundingBox_UL_Corner
R:04AC:BoundingBox_UL_XPos
R:04AD:BoundingBox_UL_YPos
R:04AE:BoundingBox_DR_XPos
R:04AE:BoundingBox_LR_Corner
R:04AF:BoundingBox_DR_YPos
R:04B0:EnemyBoundingBoxCoord
R:0500:AreaObjOffsetBuffer
R:0501:ExtraShit
R:0510:AreaObjectLength
R:0520:MushroomLedgeHalfLen
R:0530:ExtendedLength
R:0540:ExtendedMetatile
R:0541:ExtraShit2
R:0550:ExtendedHeight
R:0563:BowserBodyControls
R:0564:BowserFeetCounter
R:0565:BowserMovementSpeed
R:0566:BowserOrigXPos
R:0567:BowserFlameTimerCtrl
R:0568:BowserFront_Offset
R:0569:BridgeCollapseOffset
R:056A:BowserGfxFlag
R:0581:ExtraShit3
R:05A1:ExtraShit4
R:05C1:TextboxID
R:05C2:CurrentChar
R:05C3:IncrementedTxtHAdd
R:05C4:IRQnum
R:05C5:Old8000
R:05C6:StartedTextBox
R:05C7:SomeOffset
R:05C8:TextBoxYScroll
R:05C9:ScrollText
R:05CA:songPlaying
R:05CB:EndTimer
R:05CC:LastCHR3
R:05CD:TimesScrolled
R:05CE:PlayerOnVine
R:05CF:OldSavedJoypadBits
R:05D0:LevelParserOffset
R:05D1:LevelSelectNumber
R:05D2:EnemyOffsetPage
R:05F0:EnemyOnSlope
R:0600:ClearRemainings
R:0601:TextBoxYScroll1
R:0602:OldTextboxID
R:0603:wea32
R:0604:clearVRAM
R:069E:Cbolla
R:06A0:BlockBufferColumnPos
R:06A1:MetatileBuffer
R:06AE:HammerEnemyOffset
R:06B7:JumpCoinMiscOffset
R:06BC:BrickCoinTimerFlag
R:06BE:Misc_Collision_Flag
R:06CB:EnemyFrenzyBuffer
R:06CC:SecondaryHardMode
R:06CD:EnemyFrenzyQueue
R:06CE:FireballCounter
R:06CF:DuplicateObj_Offset
R:06D1:LakituReappearTimer
R:06D3:NumberofGroupEnemies
R:06D4:ColorRotateOffset
R:06D5:PlayerGfxOffset
R:06D6:WarpZoneControl
R:06D7:FireworksCounter
R:06D9:MultiLoopCorrectCntr
R:06DA:MultiLoopPassCntr
R:06DB:JumpspringForce
R:06DC:MaxRangeFromOrigin
R:06DD:BitMFilter
R:06DE:ChangeAreaTimer
R:06E0:SprShuffleAmtOffset
R:06E1:SprShuffleAmt
R:06E4:Player_SprDataOffset
R:06E4:SprDataOffset
R:06E5:Enemy_SprDataOffset
R:06EC:Alt_SprDataOffset
R:06EC:Block_SprDataOffset
R:06EE:Bubble_SprDataOffset
R:06F1:FBall_SprDataOffset
R:06F3:Misc_SprDataOffset
R:06FC:SavedJoypad1Bits
R:06FC:SavedJoypadBits
R:06FD:SavedJoypad2Bits
R:06FF:Player_X_Scroll
R:0700:Player_XSpeedAbsolute
R:0701:FrictionAdderHigh
R:0702:FrictionAdderLow
R:0703:RunningSpeed
R:0704:SwimmingFlag
R:0705:Player_X_MoveForce
R:0706:DiffToHaltJump
R:0707:JumpOrigin_Y_HighPos
R:0708:JumpOrigin_Y_Position
R:0709:VerticalForce
R:070A:VerticalForceDown
R:070B:PlayerChangeSizeFlag
R:070C:PlayerAnimTimerSet
R:070D:PlayerAnimCtrl
R:070E:JumpspringAnimCtrl
R:070F:FlagpoleCollisionYPos
R:0710:PlayerEntranceCtrl
R:0711:FireballThrowingTimer
R:0712:DeathMusicLoaded
R:0713:FlagpoleSoundQueue
R:0714:CrouchingFlag
R:0715:GameTimerSetting
R:0716:DisableCollisionDet
R:0717:DemoAction
R:0718:DemoActionTimer
R:0719:PrimaryMsgCounter
R:071A:ScreenEdge_PageLoc
R:071A:ScreenLeft_PageLoc
R:071B:ScreenRight_PageLoc
R:071C:ScreenEdge_X_Pos
R:071C:ScreenLeft_X_Pos
R:071D:ScreenRight_X_Pos
R:071E:ColumnSets
R:071F:AreaParserTaskNum
R:0720:CurrentNTAddr_High
R:0721:CurrentNTAddr_Low
R:0722:IRQDisable
R:0723:ScrollLock
R:0725:CurrentPageLoc
R:0726:CurrentColumnPos
R:0727:TerrainControl
R:0728:BackloadingFlag
R:0729:BehindAreaParserFlag
R:072A:AreaObjectPageLoc
R:072B:AreaObjectPageSel
R:072C:AreaDataOffset
R:0733:AreaStyle
R:0734:StaircaseControl
R:0735:AreaObjectHeight
R:0739:EnemyDataOffset
R:073A:EnemyObjectPageLoc
R:073B:EnemyObjectPageSel
R:073C:ScreenRoutineTask
R:073D:ScrollThirtyTwo
R:073F:HorizontalScroll
R:0740:VerticalScroll
R:0741:ForegroundScenery
R:0742:BackgroundScenery
R:0743:CloudTypeOverride
R:0744:BackgroundColorCtrl
R:0745:LoopCommand
R:0746:StarFlagTaskControl
R:0747:TimerControl
R:0748:CoinTallyFor1Ups
R:0749:SecondaryMsgCounter
R:074A:JoypadBitMask
R:074E:AreaType
R:074F:AreaAddrsLOffset
R:0750:AreaPointer
R:0751:EntrancePage
R:0752:AltEntranceControl
R:0753:CurrentPlayer
R:0754:PlayerSize
R:0755:Player_Pos_ForScroll
R:0756:PlayerStatus
R:0757:FetchNewGameTimerFlag
R:0758:JoypadOverride
R:0759:GameTimerExpiredFlag
R:075A:NumberofLives
R:075A:OnscreenPlayerInfo
R:075B:HalfwayPage
R:075C:LevelNumber
R:075D:Hidden1UpFlag
R:075E:CoinTally
R:075F:WorldNumber
R:0760:AreaNumber
R:0765:Player_OldCollisionBits
R:0766:OffScr_WorldNumber
R:0767:OffScr_AreaNumber
R:0768:ScrollFractional
R:0769:DisableIntermediate
R:076A:PrimaryHardMode
R:076B:WorldSelectNumber
R:0770:OperMode
R:0772:OperMode_Task
R:0773:VRAM_Buffer_AddrCtrl
R:0774:DisableScreenFlag
R:0775:ScrollAmount
R:0776:GamePauseStatus
R:0777:GamePauseTimer
R:0778:Mirror_PPU_CTRL_REG1
R:0779:Mirror_PPU_CTRL_REG2
R:077A:NumberOfPlayers
R:077B:NameTableSelect
R:077C:IRQAckFlag
R:077F:IntervalTimerControl
R:0780:SelectTimer
R:0780:Timers
R:0781:PlayerAnimTimer
R:0782:JumpSwimTimer
R:0783:RunningTimer
R:0784:BlockBounceTimer
R:0785:SideCollisionTimer
R:0786:JumpspringTimer
R:0787:GameTimerCtrlTimer
R:0789:ClimbSideTimer
R:078A:EnemyFrameTimer
R:0790:BowserFireBreathTimer
R:0791:StompTimer
R:0792:AirBubbleTimer
R:0792:FrenzyEnemyTimer
R:0795:ScrollIntervalTimer
R:0796:EnemyIntervalTimer
R:079D:UnusedTimer
R:079E:InjuryTimer
R:079F:StarInvincibleTimer
R:07A0:ScreenTimer
R:07A1:WorldEndTimer
R:07A2:DemoTimer
R:07A7:PseudoRandomBitReg
R:07B0:MusicOffset_Noise
R:07B0:SoundMemory
R:07B1:EventMusicBuffer
R:07B2:PauseSoundBuffer
R:07B3:Squ2_NoteLenBuffer
R:07B4:Squ2_NoteLenCounter
R:07B5:Squ2_EnvelopeDataCtrl
R:07B6:Squ1_NoteLenCounter
R:07B7:Squ1_EnvelopeDataCtrl
R:07B8:Tri_NoteLenBuffer
R:07B9:Tri_NoteLenCounter
R:07BA:Noise_BeatLenCounter
R:07BB:Squ1_SfxLenCounter
R:07BD:Squ2_SfxLenCounter
R:07BE:Sfx_SecondaryCounter
R:07BF:Noise_SfxLenCounter
R:07C0:DAC_Counter
R:07C1:NoiseDataLoopbackOfs
R:07C4:NoteLengthTblAdder
R:07C5:AreaMusicBuffer_Alt
R:07C6:PauseModeFlag
R:07C7:GroundMusicHeaderOfs
R:07CA:AltRegContentFlag
R:07D7:DisplayDigits
R:07D7:TopScoreDisplay
R:07DD:PlayerScoreDisplay
R:07DD:ScoreAndCoinDisplay
R:07EB:PlayerCoinDisplay
R:07F8:GameTimerDisplay
R:07FF:WarmBootValidation
G:2000:PPU_CTRL_REG1
G:2001:PPU_CTRL_REG2
G:2002:PPU_STATUS
G:2003:PPU_SPR_ADDR
G:2004:PPU_SPR_DATA
G:2005:PPU_SCROLL_REG
G:2006:PPU_ADDRESS
G:2007:PPU_DATA
G:4000:SND_REGISTER
G:4000:SND_SQUARE1_REG
G:4004:SND_SQUARE2_REG
G:4008:SND_TRIANGLE_REG
G:400C:SND_NOISE_REG
G:4010:SND_DELTA_REG
G:4014:SPR_DMA
G:4015:SND_MASTERCTRL_REG
G:4016:JOYPAD_PORT
G:4016:JOYPAD_PORT1
G:4017:JOYPAD_PORT2
W:0000:ChangeBankR
W:0001:ChangeBankRDelay
W:0002:SuppressJumpNoise
W:0003:UnlockWorld9
W:0004:GrabFlag
W:0005:temp5
W:0006:HurryUp
W:0007:UnknownHurryUp
W:0008:GrabID
W:001D:GrabDown
W:001E:eastereggflag
W:001F:StarChainCounter
W:0020:debug
W:0021:FlipGFX
W:0022:FlipTimer
W:0023:dontinc
W:0024:RemoveChain
W:0025:EnemyDefeatPitch
W:0026:DoNotChangeSize
W:0027:PFlag
W:0028:PTimer
W:0029:WaterReplace
W:002A:temp6
W:002B:temp7
W:002C:temp8
W:002D:peo
W:002E:FballCooldown
W:0030:OldStatus
W:0031:ExplosionTimerCounter
W:0032:BlockUsed
W:0034:temp9
W:0035:BowserKilled
W:0036:ParallaxOffset
W:0037:World9Debug
W:0038:StartTimer
W:0039:Flag1kCoins
W:0050:WaitForReset
W:0051:tempA
W:0052:HardModeFlag
W:0053:OnOffBits
W:0054:OnOffFlag
W:0056:tempB
W:0057:tempC
W:0058:tempD
W:0059:LakituRespawning
W:005A:WaterCooldown
W:005B:Tortilla
W:005C:lag
W:005D:LagFrameYes
W:005E:OldSwim
W:005F:bocata
W:0060:bocata2
W:0061:bocata3
W:0062:FrameCaunter
W:0065:DebugSwim
W:0065:PlayerFoot
W:006B:OnSlope
W:0071:TwoFoot
W:0077:OneSecTimer
W:0078:GrabUp
W:0079:CrouchingFlag2
W:007A:Webito
W:007B:EntranceCoolDown
W:007C:DontDecPT
W:007D:sleeping
W:007E:EvenFrame
W:007F:DetectedFoot
W:0080:OldDetectedFoot
W:0081:TimerWa
W:0082:currentBank
W:0084:ContinueWriting
W:0085:CurrentText
W:0086:OldWriting
W:0087:test
W:0088:dontchecklag
W:0089:dou
W:008A:Wea
W:008B:ClimbingSlope
W:008C:temp2a
W:008D:temp3a
W:008E:temp4a
W:008F:temp5a
W:0090:temp6a
W:0091:pspeed
W:0092:pspeeddelay
W:0093:pspeedsound
W:0094:tickid
W:0095:oldpspeed
W:0096:framesfour
W:0097:dontdecrementagain
W:0098:ScrollThirtyTwoOG
W:0099:olddirscroll
W:009A:stopload
W:009B:Player_X_ColumnLoc
W:009C:bbl2
W:009F:Block_BBuf_High
W:00A1:dont
W:00A2:scrolldir
W:00A3:tempXD
W:00A4:dontscroll
W:00A5:iwantdie
W:00A6:ScrollLockPageLoc
W:00A7:ScrollLockColumnPos
W:00A8:WarpZoneCheck
W:00A9:ScrollLeftLock
W:00AA:Player_X_Column
W:00AB:GlobalSaveOffset
W:00AC:Saved_X_Position
W:014C:Saved_Y_Position
W:01AC:Saved_PageLoc
W:024C:Saved_State
W:02AC:Saved_isDefeated
W:034C:Saved_ID
W:03AC:OldPageLoc
W:03AD:OldHorizontalScroll
W:03AE:OldNameTableSelect
W:03AF:TouchingFloor
W:03B0:TouchingCeiling
W:03B1:PlatformTimer
W:03B2:timerupthing
W:03B3:ChangeBankRDelay2
W:03B4:BrickCoinTimer
W:03B5:DisableScreenFlag2
W:03B6:waitforit
W:03B7:SetupPause
W:03B8:PreviousUp_Down_Buttons
W:03B9:SettingSelec
W:03BA:OldSettingSelec
W:03BB:DoFin
W:03BC:BackgroundColorCtrlFP
W:03BD:FlagpoleEnemyPage
W:03BE:FlagpoleEnemyCol
W:03BF:OnPlatform
W:03C0:OnWater
W:03C1:OrigMetatile
W:03C4:SavedOffset
W:03CA:FlagpoleOnScreen
W:03CC:tempE
W:03CD:AreaPages
W:03DD:Averveamos
W:03DE:WasLocked
W:03DF:ScrollLeftFlag
W:03E0:AutoScrollFlag
W:03E1:AutoScrollFlag2
W:03E2:OldScrollLeftFlag
W:03E3:OldSquare1SoundBuffer
W:03E4:OldMirror_PPU_CTRLREG1
W:03E5:OldVerticalScroll
W:03E6:tempF
W:03E7:tempG
W:03E8:SideCollisionAdder
W:03E9:FramesMissed
W:03EA:GroundedTimer
W:03EB:lagframedetect
W:03EC:DecodingLevel
W:03ED:FloateyNum_PageLoc
W:03ED:PagesPages
W:0400:VRAM_Buffer1_Offset
W:0401:VRAM_Buffer1
W:04E0:VRAM_Buffer2_Offset
W:04E1:VRAM_Buffer2
W:0600:Block_Buffer_1
W:0700:Block_Buffer_2
W:1E00:CHR0
W:1E00:save_playerData
W:1E01:CHR1
W:1E02:CHR2
W:1E03:CHR3
W:1E04:CHR4
W:1E05:CHR5
W:1E06:LevelBank
W:1E07:seed
W:1E09:VineGrabCooldown
W:1E0A:TitleScreenSelect
W:1E0B:FirstFrame
W:1E0C:FirstBootFlag
W:1E0D:DontRepeat
W:1E0E:Cannon_Creator
W:1E13:WorldPalette
W:1E14:TheresPal3
W:1E15:OldPal3
W:1E19:dumbflag
W:1E1A:FloateyShit
W:1E1F:DontJump
W:1E20:BowserGotHit
W:1E21:PCooldown
W:1F00:SavedScore
W:1F06:SettingsBits
W:1F0A:WorldSelectEnableFlag
W:1F10:TopMaxedOut
W:1F11:ContinueWorld
W:1F12:ContinueLevel
W:1F13:ContinueScore
W:1F1A:ContinueCoins
W:1F1E:ContinuePwrup
W:1F1F:ContinueCoinTally
W:1FBC:SavedWord
G:9CB4:OriginalLevelDataStart
R:0006:AnteFinalText
R:0007:FinalText
R:0042:save_Validate_value
W:1F00:save_TopScore
W:1FBF:save_Validate
R:0100:I
R:0000:powerup
R:0001:ExLVLID
R:0001:coin
R:0002:hcoin
R:0003:h1up
R:0004:bpowerup
R:0005:bvine
R:0006:bstar
R:0007:bcoins
R:0008:WarpFlag
R:0008:b1up
R:000B:custom
R:000C:Objects2Flag
R:000C:hpowerup
R:000D:Objects3Flag
R:000D:hstar
R:000E:star
R:000F:Objects4Flag
R:000F:PageSkip
R:000F:oneup
R:0010:Objects1Flag
R:0037:TwoGoombas
R:0038:ThreeGoombas
R:0080:PageFlag
R:008D:ONOFFS
R:0000:Y_Scroll
G:D933:addr
G:EF33:adrr
