P:0000:: RAM variables\n We start at a weird address here because\n we're adding on to all this defined stuff.\n Needs cleanup.\n.base $07cb\n Zero page variables\n.base $0000\n Include constants, macros\n default settings\n Do not modify this default settings file.\n Instead, create a settings.asm with the \n settings you want to change.\n Set starting world and level\n set START_WORLD to 0 to disable.\n Skip the intermediate screen\n Skip title screen\n Enable sound\n Enable dpcm sample support\n NOTE: needs work\n Add a battery\n High score is saved\n To erase save data, hold select+a+up while loading the game\n NOTE: Turning this off may cause issues.\n Enable cheats.\n\n Settings starting with CHEAT require\n cheats to be enabled.\n Infinite lives\n Can't be hurt\n Skip level by pressing select in game\n World select always enabled\n NOTE: Currently not working\n Remove game timer\n Enable some things that showcase features\n * Goomba graphics change when player is small\n * Display text message on intermediate screen\n Use IRQ, new scanline counter based hud, \n other major changes.\n Import level from a nes file.  It must be a\n non-expanded rom with data in the same place as the original game.\n File to use with IMPORT_LEVELS option.\nLEVEL_FILE equ "Super Mario Bros. (World).nes"\nLEVEL_FILE equ "Luigis_Turn.nes"\nLEVEL_FILE equ "SMB Annoyance.nes"\nLEVEL_FILE equ "Super_Drew_Bros_Nintendrew.nes"\nLEVEL_FILE equ "smbGreatEd2.nes"\nLEVEL_FILE equ "Super Mario Bros - Hi Episode 4.nes"\nLEVEL_FILE equ "SMB_but_with_10_worlds_GE.nes"\n File to use when IMPORT_LEVELS is off\nLEVEL_DATA equ code\levelDataBowser.asm\nLEVEL_DATA equ code\levelDataj.asm\nLEVEL_DATA equ code\blah.asm\nLEVEL_DATA equ tools\output.txt\n Adds code to make the minus world work again.\n Fix bug to enable unused spiny behaviour\n jumpspring bug fixes from PAL version\n * Define vertical acceleration on springs (was undefined on NTSC)\n * Check whether there's a free enemy slot before placing spring. Avoids placing it in the special item slot.\n NOTE: Causes a crash.  Can't figure out why.\n Blooper vertical distance from player.  Default is #$10 (NTSC) or #$0c (PAL).\nBLOOPER_DISTANCE = #$10\n reworked movement function for Cheep Cheeps from PAL version\n NOTE: Not working.  Cheep Cheeps fly lower for some reason\n Collision fix taken from PAL version.\n Vertical difference deciding whether Mario stomped or got hit depends on the enemy\n Set vertical speed to 0 in water stages.  Taken from PAL version.\n This makes you bounce less (or more consistant speed) when you hit \n your head in water.  With turbofire it is a bit too easy to clip\n up through blocks though.\n Some enemies (Piranha, Bullet Bill, Goomba, Spiny, Blooper, Cheep Cheep) has larger hitbox\n Taken from PAL version.\n Allow display of up to 99 lives\n Luigi has smb2j physics\n Give Luigi his DX color palette\n Bounce higher off enemies as in SMB2J.\n Turn Mario into Luigi (mostly) for testing.\n Note: currently breaks time up message.\n Same as above but for other players.\n Use 0 to turn off.\n Add a game over menu (continue, retry)\n Fix pipe pointer issue for world 9\n Enable "More Power" mode.  Needs DPCM enabled.\n NOTE: needs work\n Enable skid sound effect as in SMB2J\n Prevent blank tiles from being displayed.\n :\n local settings\n macros\n (x,y) row of w bricks\n (x,y) row of w blocks\n levelHeader $00,$02,$01,$01,$02,$00\n scenery_bgcolor\n entrance, timer\n terrain_control\n background_scenery_type\n background_scenery\n Header (first byte): scenery/bg color + player entrance control * $08 + timer setting * $40\n Header (second byte): terrain control + background scenery type * $10 + background scenery * $40\n16 bits branches (removed because worst bug in the world)\ncreates a advanced custom object\n(x,y) custom metatile (mt), lenght (w) and height (h)\n(x,y) custom metatile (mt), lenght (w) and height (h)\n(x,y) upside down pipe (not enterable) (h blocks height)\n(x,y) Vertical pipe (h blocks height)\n(x,y) custom metatile (mt), lenght (w) and height (h)\nadds to a\napparently this sometimes refuses to work correctly lmao\nsubtracts from a\narithmetic shift right\nmove high nybble to low (for comparation)\nmove low nybble to high\ninclude code\residual.asm                       ; dummy assignments to remove unreferenced label warnings\n Items that don't have .dsb are aliases for the definition below it.\n used for temporary stuff including indirect pointers\nzp_unknown1             .dsb 3\nzp_unknown2             .dsb 3\nzp_unknown3             .dsb 10\n originally used as $eb directly\n originally used as $ec directly\n originally used as $ed directly\nzp_unknown4             .dsb 1\n originally used as $ef directly\n other constants\n-------------------------------------------------------------------------------------\nDEFINES\nNES specific hardware defines\n GAME SPECIFIC DEFINES\nused by current player\nthe actual dash number\ninternal number used to find areas\nOffscreenPlayerInfo   = $0761\nOffScr_NumberofLives  = $0761 ;used by offscreen player\nOffScr_HalfwayPage    = $0762\n-------------------------------------------------------------------------------------\nCONSTANTS\nsound effects constants\nmusic constants\n----------------------\nenemy object constants \n----------------------\n$1a, $1b used by springboard frames\nfrom $1c to $2c are firebars and lifts (23 is null sprite)\n$34 is warp zone\n$36 potentially free slot\nother constants\nTitleScreenDataOffset = $1ec0\nNew Defines\ni forgor why i made this?\n$602d is ununused\ni dont fucking now why i have this\nthis goes to $6064\n $6083 is free\n Save game\n start of level data in a normal SMB \n Final world\n Secondary hard mode starts on this world\ninclude code\sound\soundConstants.asm           ; sound constants\n Bank asignments\n bank 00 -- first half of original SMB code\n bank identifier
P:0001:convertNumber:-------------------------------------------------------------------------------------\n Convert the value in the A register to decimal digits\n $00 hundreds digit\n $01 tens digit\n $02 ones digit
P:0026:: replace digit with space if 0, starting from leftmost digit
P:0029:: exit routine if not 0
P:0036:decimalPlaceValues
P:0039:OperModeExecutionTree:hexTable:\n    .db $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0a, $0b, $0c, $0d, $0e, $0f\ninclude code\lagmaker.asm                  \n-------------------------------------------------------------------------------------\n$00 - vram buffer address table low, also used for pseudorandom bit\n$01 - vram buffer address table high\n-------------------------------------------------------------------------------------\nNoPlease1: jmp NoPlease
P:0056::this is the heart of the entire program,
P:0059::most of what goes on starts here
P:0064:TitleScreenMode:-------------------------------------------------------------------------------------
P:0074:ContinueWord:-------------------------------------------------------------------------------------
P:0081:WSelectBufferTemplate
P:008A:NullJoypadJMP
P:008D:MenuContinue
P:0097::write template for world select in vram buffer
P:009A::do this until all bytes are written
P:00A6:GameMenuRoutine
P:00AB::check to see if either player pressed
P:00B2:StartGame
P:00BC::if either start or A + start, execute here
P:00C2:ChkSelect
P:00C6::check select/B button timer
P:00C9::if not expired, branch
P:00CB::otherwise reset select button timer
P:0129::check to see if the select button was pressed
P:012B::if so, branch reset demo timer
P:0135:ChkWorldSel:ldx DemoTimer               ;otherwise check demo timer\nbne ChkWorldSel             ;if demo timer not expired, branch to check world selection\nsta SelectTimer             ;set controller bits here if running demo\njsr DemoEngine              ;run through the demo actions\nbcs ResetTitle              ;if carry flag set, demo over, thus branch\njmp Rundemo                 ;otherwise, run game engine for demo\ncheck to see if world selection has been enabled
P:013A::if so, check to see if the B button was pressed
P:013E::if so, increment Y and execute same code as select
P:013F:SelectLogic:lda DemoTimer               ;if select or B pressed, check demo timer one last time\nbeq ResetTitle              ;if demo timer expired, branch to reset title screen mode\nlda #$18                    ;otherwise reset demo timer\nsta DemoTimer\ncheck select/B button timer
P:0145::if not expired, branch
P:0147::otherwise reset select button timer
P:014C::was the B button pressed earlier?  if so, branch
P:014E::note this will not be run if world selection is disabled
P:0150::inc CurrentPlayer\nif no, must have been the select button, therefore
P:015E:IncWorldSel
P:0174::increment world select number
P:018D:UpdateShroom:write template for world select in vram buffer
P:0190::do this until all bytes are written
P:0198::get world number from variable and increment for
P:019B::proper display, and put in blank byte before
P:019C::null terminator
P:01AF:NullJoypad
P:01B5::clear joypad bits for player 1
P:01BA:RunDemo:run game engine
P:01BD::check to see if we're running lose life routine
P:01C1::if not, do not do all the resetting below
P:01C3:ResetTitle:reset game modes, disable
P:01C5::sprite 0 check and disable
P:01C8::screen output
P:01D1:ExitMenu1
P:01D2:SizeTable
P:01D5:OldStatusTable
P:01D8:ChkContinue
P:0206::load previously saved world number for secret
P:0219:StartWorld1
P:0221::set 1-up box flag for both players
P:0224::set fetch new game timer flag
P:0227::set next game mode
P:022F::set game mode here, and clear demo timer
P:023E:InitScores:clear player scores and coin displays
P:0244:ExitMenu
P:0245:GoContinue:start both players at the first area
P:0248::of the previously saved world number
P:0258::will make no difference
P:025F:MushroomIconData:sta OffScr_WorldNumber\nsta OffScr_AreaNumber\n-------------------------------------------------------------------------------------
P:0267:DrawMushroomIcon:read eight bytes to be read by transfer routine
P:0269:IconDataRead:note that the default position is set for a
P:026C::1-player game
P:0277::check number of players
P:027A::if set to 1-player game, we're done
P:027C::otherwise, load blank tile in 1-player position
P:0281::then load shroom icon tile in 2-player position
P:0286:ExitIcon
P:0287:VictoryMode:-------------------------------------------------------------------------------------\nrun victory mode subroutines
P:028A::get current task of victory mode
P:028D::if on bridge collapse, skip enemy processing
P:0291::otherwise reset enemy object offset 
P:0293::and run enemy code
P:0296:AutoPlayer:get player's relative coordinates
P:0299::draw the player, then leave
P:029C:VictoryModeSubroutines
P:02B8:Okso:-------------------------------------------------------------------------------------\n.dw "CREDITS TO"-55\n.dw "TEST - TEST"-55
P:02B8:WipeTheFuckingScreen
P:02C9:SetupVictoryMode:get page location of right side of screen
P:02CC::increment to next page
P:02CD::store here
P:02D1::play win castle music
P:02F2::lda #$19\nsta VRAM_Buffer1+3,y
P:02FF::apparently this sometimes refuses to work correctly lmao
P:0304::jump to set next major task in victory mode
P:0307:DisplayCredits
P:0319:WriteCredits
P:032A:Nothing
P:032E:CheckForThing
P:0363::exit, write routine is in another part and bank
P:0370:PlayerVictoryWalk:-------------------------------------------------------------------------------------\nset value here to not walk player by default
P:037B::get player's page location
P:037D::compare with destination page location
P:037F::if page locations don't match, branch
P:0381::otherwise get player's horizontal position
P:0383::compare with preset horizontal position
P:0385::if still on other page, branch ahead
P:0387:PerformWalk:otherwise increment value and Y
P:0389::note Y will be used to walk the player
P:038A:DontWalk:put contents of Y in A and
P:038B::use A to move player to the right or not
P:038E::check page location of left side of screen
P:0391::against set value here
P:0393::branch if equal to change modes if necessary
P:0398::do fixed point math on fractional part of scroll
P:039B::save fractional movement amount
P:039E::set 1 pixel per frame
P:03A0::add carry from previous addition
P:03A2::use as scroll amount
P:03A3::do sub to scroll the screen
P:03A6::do another sub to update screen and scroll variables
P:03A9::increment value to stay in this routine
P:03AB:ExitVWalk:load value set here
P:03AD::if zero, branch to change modes
P:03AF::otherwise leave
P:03B0:IncModeTask_A1
P:03B4:PrintVictoryMessages:-------------------------------------------------------------------------------------\nload secondary message counter
P:03B7::if set, branch to increment message counters
P:03B9::otherwise load primary message counter
P:03BC::if set to zero, branch to print first message
P:03C5::check world number
P:03CA::if not at world 8, skip to next part
P:03D6::check primary message counter again
P:03D8::if not at 3 yet (world 8 only), branch to increment
P:03DA::otherwise subtract one
P:03DC::and skip to next part
P:03DF:MRetainerMsg:check primary message counter
P:03E1::if not at 2 yet (world 1-7 only), branch
P:03E3:ThankPlayer:put primary message counter into Y
P:03E4::if counter nonzero, skip this part, do not print first message
P:03E6::otherwise get player currently on the screen
P:03EC:SecondPartMsg:increment Y to do world 8's message
P:03F7::check world number
P:03F9::if at world 8, branch to next part
P:0405::otherwise decrement Y for world 1-7's message
P:0406::if counter at 4 (world 1-7 only)
P:0408::branch to set victory end timer
P:040A::if counter at 3 (world 1-7 only)
P:040C::branch to keep counting
P:040E:EvalForMusic:if counter not yet at 3 (world 8 only), branch
P:0410::to print message only (note world 1-7 will only
P:0412::reach this code if counter = 0, and will always branch)
P:0414::otherwise load victory music first (world 8 only)
P:0416:PrintMsg:put primary message counter in A
P:0417::add $0c or 12 to counter thus giving an appropriate value,
P:0418::($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
P:041A::write message counter to vram address controller
P:041D:IncMsgCounter
P:0421::add four to secondary message counter
P:0429::add carry to primary message counter
P:042E::check primary counter one more time
P:0430:SetEndTimer:if not reached value yet, branch to leave
P:0443:Salir:lda WorldEndTimer\ncmp #$06\nbcs ExitMsgs\nldy WorldNumber\ncpy #FinalWorld\nbeq Salir\njsr AwardGameTimerPoints\nbeq ExitMsgs
P:0445::otherwise set world end timer
P:0448:IncModeTask_A:move onto next task in mode
P:044B:ExitMsgs:leave
P:044C:EndCastleAward:-------------------------------------------------------------------------------------\nif world end timer has not yet reached a certain point
P:044F::then go ahead and skip all of this
P:0456:ExEWA
P:0457:PlayerEndWorld:branch to leave if not\ncheck to see if world end timer expired
P:045C::check world number
P:045F::if on world 8, player is done with game, 
P:0461::thus branch to read controller
P:0463:Tumama
P:0465::otherwise initialize area number used as offset
P:0468::and level number control to start at area 1
P:046B::initialize secondary mode of operation
P:046E::increment world number to move onto the next world
P:0471::get area address offset for the next area
P:0474::set flag to load game timer from header
P:047C::set mode of operation to game mode
P:047F:EndExitOne:and leave
P:0480:EndChkBButton
P:0489:PressButtonB
P:048C::check to see if B button was pressed on
P:048F::either controller
P:0491::branch to leave if not
P:0496::remove onscreen player's lives
P:04A3::do sub to continue other player or end game
P:04A6:EndExitTwo:leave
P:04A7:FloateyNumTileData:-------------------------------------------------------------------------------------\ndata is used as tiles for numbers\nthat appear when you defeat enemies\ndummy
P:04A9:: "100"
P:04AB:: "200"
P:04AD:: "400"
P:04AF::.db $f9, $fb ; "500"\n "800"
P:04B1:: "1000"
P:04B3:: "2000"
P:04B5:: "4000"
P:04B7::.db $f9, $50 ; "5000"\n "8000"
P:04B9:: "1-UP"
P:04BB:ScoreUpdateData:high nybble is digit number, low nybble is number to\nadd to the digit of the player's score\ndummy
P:04C5:FloateyNumbersRoutine:if less than $0b, branch
P:04C9::otherwise set to $0b, thus keeping
P:04CB::it in range
P:04CE:ChkNumTimer:use as Y
P:04CF::check value here
P:04D2::if nonzero, branch ahead
P:04D7::initialize floatey number control and leave
P:04DB:DecNumTimer:decrement value here
P:04DE::if not reached a certain point, branch  
P:04E6::check offset for $0b
P:04E8::branch ahead if not founs
P:04EC::and play the 1-up sound
P:0504::give player one extra life (1-up)
P:050C::otherwise, check number of lives
P:050F::clc                          ;and increment by one for display   //uncommented as having 00 lifes is like having 1\nadc #$01\nmore than 9 lives?
P:0513::if so, subtract 10 and add one to the 10s digit
P:0515::instead of showing 100 lives, A0 will show, etc.
P:051E::if so, subtract 10 and add to the digit
P:0520::next to the difference
P:0529:PutLives3
P:0534::check highest digit of score
P:0537::bne +	                    ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-6,y
P:0539:LoadNumTiles:load point value here
P:053C::move high nybble to low
P:0540::use as X offset, essentially the digit
P:0541::load again and this time
P:0544::mask out the high nybble
P:0546::store as amount to add to the digit
P:054C:ChkTallEnemy:get OAM data offset for enemy object
P:055A::get enemy object identifier
P:055E::branch if spiny
P:0562::branch if piranha plant
P:0566::branch elsewhere if hammer bro
P:056A::branch if cheep-cheep of either color
P:057E::branch elsewhere if enemy object => $09
P:0582::if enemy state defeated or otherwise
P:0584::$02 or greater, branch beyond this part
P:0586:GetAltOffset:load some kind of control bit
P:0589::get alternate OAM data offset
P:058C::get enemy object offset again
P:058E:FloateyPart:get vertical coordinate for
P:0591::floatey number, if coordinate in the
P:0593::status bar, branch
P:0597::otherwise subtract one and store as new
P:059A:SetupNumSpr:get vertical coordinate
P:059D::subtract eight and dump into the
P:059F::and into first row sprites
P:05A2::and do sub to dump into first and second sprites
P:05AA::get horizontal coordinate
P:05B4::store into X coordinate of left sprite
P:05D6::get horizontal coordinate
P:05E0::store into X coordinate of left sprite
P:0603::load X coordinate of left sprite
P:0607::add eight pixels and store into X
P:0609::coordinate of right sprite
P:060E::set palette control in attribute bytes
P:0611::of left and right sprites
P:0617::multiply our floatey number control by 2
P:0618::and use as offset for look-up table
P:061C::display first half of number of points
P:0622::display the second half
P:0625::get enemy object offset and leave
P:0628:ScreenRoutines:-------------------------------------------------------------------------------------\nrun one of the following subroutines
P:064C:GetBackgroundColor1:-------------------------------------------------------------------------------------
P:0655:InitScreen:initialize all sprites including sprite #0
P:0658::and erase both name and attribute tables
P:065E::if mode still 0, do not load
P:0660::into buffer pointer
P:0665:SetupIntermediate:-------------------------------------------------------------------------------------\nsave current background color control
P:0668::and player status to stack
P:066D::set background color to black
P:066F::and player status to not fiery
P:0672::this is the ONLY time background color control
P:0674::is set to less than 4
P:067A::we only execute this routine for
P:067B::the intermediate lives display
P:067E::and once we're done, we return bg
P:067F::color ctrl and player status from stack
P:0682::then move onto the next task
P:0685:AreaPalette:-------------------------------------------------------------------------------------
P:0689:GetAreaPalette:select appropriate palette to load
P:068C::based on area type
P:068F:SetVRAMAddr_A:store offset into buffer control
P:0692:NextSubtask:move onto next task
P:0695:BGColorCtrl_Addr:-------------------------------------------------------------------------------------\n$00 - used as temp counter in GetPlayerColors
P:0699:BackgroundColors:used by area type if bg color ctrl not set
P:069D::used by background color control if set
P:06A5:PlayerColorsOffset:PlayerColors:\n      .db $22, $16, $27, $18 ;Mario's colors\n      .db $22, $30, $27, $19 ;Luigi's colors\n      .db $22, $37, $27, $16 ;Fiery (used by both)
P:06A7:MarioColors:Small
P:06A7:PlayerColors
P:06AB::Big
P:06AF::Fiery
P:06B3:LuigiColors:Small
P:06B7::Big
P:06BB::Fiery
P:06BF:GetBackgroundColor:check background color control
P:06C2::if not set, increment task and fetch palette
P:06C4::put appropriate palette into vram
P:06C7::note that if set to 5-7, $0301 will not be read
P:06CA:NoBGColor:increment to next subtask and plod on through
P:06CD:GetPlayerColors:get current buffer offset
P:06E1:StartClrGet:do four colors
P:06E5:ClrGetLoop:fetch player colors and store them
P:06E8::in the buffer
P:06F1::load original offset from before
P:06F4::if this value is four or greater, it will be set
P:06F7::therefore use it as offset to background color
P:0703::otherwise use area type bits from area offset as offset
P:0706:SetBGColor:to background color instead
P:070C::set for sprite palette address
P:070E::save to buffer
P:0716::write length byte to buffer
P:071B::now the null terminator
P:0720::move the buffer pointer ahead 7 bytes
P:0721::in case we want to write anything else later
P:0724:SetVRAMOffset:store as new vram buffer offset
P:0728:GetAlternatePalette1:-------------------------------------------------------------------------------------
P:072F::otherwise check world number
P:073D::check for mushroom level style
P:0744::if found, load appropriate palette
P:0746:SetVRAMAddr_B
P:0749:NoAltPal:now onto the next task
P:074C:WriteTopStatusLine:-------------------------------------------------------------------------------------\nselect main status barrel
P:074E::output it
P:0751::onto the next task
P:0754:WriteBottomStatusLine:-------------------------------------------------------------------------------------
P:077D::write player's score and coin tally to screen
P:078B::write address for world-area number on screen
P:0795::write length for it
P:07AC::first the world number
P:07B4::next the dash
P:07CB::next the level number
P:07CE::increment for proper number display
P:07DC::put null terminator on
P:07E1::move the buffer offset up by 6 bytes
P:07EB:DisplayTimeUp:-------------------------------------------------------------------------------------\nif game timer not expired, increment task
P:07EE::control 2 tasks forward, otherwise, stay here
P:07F2::reset timer expiration flag
P:07F5::output time-up screen to buffer
P:07FA:NoTimeUp:increment control task 2 tasks forward
P:0800:DisplayIntermediate:-------------------------------------------------------------------------------------\ncheck primary mode of operation
P:0803::if in title screen mode, skip this
P:0805::are we in game over mode?
P:0807::if so, proceed to display game over screen
P:0809::otherwise check for mode of alternate entry
P:080C::and branch if found
P:080E::if this flag is set, skip intermediate lives display
P:0811::and jump to specific task, otherwise
P:0813:PlayerInter:put player in appropriate place for
P:0816::lives display, then output lives display to buffer
P:0818:OutputInter
P:0820::reenable screen output
P:0827:GameOverInter:set screen timer
P:082C::output game over screen to buffer
P:0834:NoInter:set for specific task and leave
P:083A:AreaParserTaskControl:-------------------------------------------------------------------------------------
P:0842::render column set of current area
P:084D:TaskLoop:render column set of current area
P:0850::check number of tasks
P:0853::if tasks still not all done, do another one
P:0855::do we need to render more column sets?
P:085D::if not, move on to the next task
P:0860::if not, move on to the next task
P:0866:OutputCol:set vram buffer to output rendered column set
P:0868::on next NMI
P:086C:ClearBuffersDrawIcon:-------------------------------------------------------------------------------------
P:086F::if not title screen mode, leave
P:0871::otherwise, clear buffer space
P:0873:TScrClear
P:087C::draw player select icon
P:087F:IncSubtask:move onto next task
P:0883:WriteTopScore:-------------------------------------------------------------------------------------
P:0886::run display routine to display top score on title
P:08A4::change the last 0 to a 9
P:08B3:IncModeTask_B:move onto next mode
P:08B7:GameText:-------------------------------------------------------------------------------------\n.db $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
P:08B7:TopStatusBarLine
P:08C8:: "WORLD"\n "WORLD  TIME"
P:08D6:: score trailing digit and coin display
P:08DE:: attribute table data, clears name table 0 to palette 2
P:08E2:: attribute table data, used for coin icon in status bar
P:08E6:: end of data block
P:08E7:WorldLivesDisplay: cross with spaces used on
P:08EC:: lives display
P:08F1:: "WORLD  - " used on lives display
P:08FE:: possibly used to clear time up
P:0902:: attribute table data for crown if more than 9 lives
P:0903:TwoPlayerTimeUp: "MARIO"
P:090B:OnePlayerTimeUp: "TIME UP"
P:0916:TwoPlayerGameOver: "MARIO"
P:091E:GameOver:"GAME OVER"
P:091E:OnePlayerGameOver
P:092A::"CONTINUE"
P:0939::"END"
P:0940:WarpZoneNumbers: "MARIO"\n "GAME OVER"\n  .db $25, $84, $15, $20, $0e, $15, $0c, $18, $16 ; "WELCOME TO WARP ZONE!"\n  .db $0e, $24, $1d, $18, $24, $20, $0a, $1b, $19\n  .db $24, $23, $18, $17, $0e, $2b\n  .db $26, $25, $01, $24         ; placeholder for left pipe\n  .db $26, $2d, $01, $24         ; placeholder for middle pipe\n  .db $26, $35, $01, $24         ; placeholder for right pipe\n  .db $27, $d9, $46, $aa         ; attribute data\n  .db $27, $e1, $45, $aa\n  .db $ff\nLuigiName:\n  .db $15, $1e, $12, $10, $12    ; "LUIGI", no address or length\n world 1-2
P:0940:WarpZoneWelcome
P:0944:: warp zone responsible for minus world
P:0948:: world 4-2
P:094C:: world 4-2 to world 5
P:0950:GameTextOffsets
P:095A:PrintWarpZoneNumbers1
P:095D:WriteGameText:save text number to stack
P:095F::multiply by 2 and use as offset
P:0960::if set to do top status bar or world/lives display,
P:0962::branch to use current offset as-is
P:0964::if set to do time-up or game over,
P:0966::branch to check players
P:0968::otherwise warp zone, therefore set offset
P:096A:Chk2Players:lda NumberOfPlayers     ;check for number of players\nbne LdGameText          ;if there are two, use current offset to also print name\notherwise increment offset by one to not print name
P:096B:LdGameText:get offset to message we want to print
P:0970:GameTextLoop:load message data
P:0973::check for terminator
P:0975::branch to end text if found
P:0977::otherwise write data to buffer
P:097A::and increment increment
P:097C::do this for 256 bytes if no terminator found
P:097E:EndGameText:put null terminator at end
P:0983::pull original text number from stack
P:0985::are we printing warp zone?
P:098D::are we printing the world/lives display?
P:098E::if not, branch to check player's name
P:0995::otherwise, check number of lives
P:0998::clc                       ;and increment by one for display //$01 = $00 lifes\nadc #$01\nmore than 9 lives?
P:099C::if so, subtract 10 and add one to the 10s digit
P:099E::instead of showing 100 lives, A0 will show, etc.
P:09A7::if so, subtract 10 and add to the digit
P:09A9::next to the difference
P:09B2:PutLives:more than 9 lives?\nif so, subtract 10 and put a crown tile\nnext to the difference...strange things happen if\nthe number of lives exceeds 19
P:09B5::write world and level numbers (incremented for display)
P:09B8::to the buffer in the spaces surrounding the dash
P:09C0::we're done here
P:09D7:ExitWPrint
P:09D8:HardModeDisplay
P:09DA:CheckPlayerName
P:09F1:NameLoop: replace "MARIO" (Including for Mario)
P:09F7::do this until each letter is replaced
P:0A06:FillB
P:0A14:ExitChkName
P:0A15:PrintWarpZoneNumbers:subtract 4 and then shift to the left
P:0A17::twice to get proper warp zone number
P:0A18::offset
P:0A1C:WarpNumLoop:print warp zone numbers into the
P:0A1F::placeholders from earlier
P:0A23::put a number in every fourth space
P:0A2B::load new buffer pointer at end of message
P:0A30:PlayerIData
P:0A35:PlayerNamesCharLenght:-------------------------------------------------------------------------------------
P:0A3A:ResetSpritesAndScreenTimer:check if screen timer has expired
P:0A3D::if not, branch to leave
P:0A3F::otherwise reset sprites now
P:0A42:ResetScreenTimer:reset timer again
P:0A47::move onto next task
P:0A4A:NoReset
P:0A4B:BlockGfxData:-------------------------------------------------------------------------------------\n$00 - temp vram buffer offset\n$01 - temp metatile buffer offset\n$02 - temp metatile graphics table offset\n$03 - used to store attribute bits\n$04 - used to determine attribute table row\n$05 - used to determine attribute table column\n$06 - metatile graphics table address low\n$07 - metatile graphics table address high\n-------------------------------------------------------------------------------------\n$00 - used as temporary counter in ColorRotation\n-------------------------------------------------------------------------------------\n$00 - temp store for offset control bit\n$01 - temp vram buffer offset\n$02 - temp store for vertical high nybble in block buffer routine\n$03 - temp adder for high byte of name table address\n$04, $05 - name table address low/high\n$06, $07 - block buffer address low/high
P:0A68:RemoveCoin_Axe:ldy #$e1                 ;set low byte so offset points to $0341\nload offset for default blank metatile
P:0A6A::check area type
P:0A6D::if not water type, use offset
P:0A6F::otherwise load offset for blank metatile used in water
P:0A71:WriteBlankMT:do a sub to write blank metatile to vram buffer
P:0A74:blank
P:0A78:IntermediatePlayerData
P:0A7E:DrawPlayer_Intermediate:store data into zero page memory
P:0A80:PIntLoop:load data to display player as he always
P:0A83::appears on world/lives display
P:0A86::do this until all data is loaded
P:0A88::load offset for small standing
P:0A8A::load sprite data offset
P:0A8C::draw player accordingly
P:0A8F::get empty sprite attributes
P:0A92::set horizontal flip bit for bottom-right sprite
P:0A94::store and leave
P:0A98:ReplaceBlockMetatile2
P:0AAB:ReplaceBlockMetatile
P:0AAE::write metatile to vram buffer to replace block object
P:0AB1:VineYes
P:0AB6:DestroyBlockMetatile
P:0AC0::force blank metatile if branched/jumped to this point
P:0AC2:WriteBlockMetatile:load offset for blank metatile
P:0AC4::check contents of A for blank metatile
P:0AC6::branch if found (unconditional if branched from 8a6b)
P:0AD4::load offset for brick metatile w/ line
P:0ADC::use offset if metatile is brick with coins (w/ line)
P:0AE0::use offset if metatile is breakable brick w/ line
P:0AE6::increment offset for brick metatile w/o line
P:0AE9::use offset if metatile is brick with coins (w/o line)
P:0AED::use offset if metatile is breakable brick w/o line
P:0B12:UseBOffset:put Y in A
P:0B13:Hmm:get vram buffer offset
P:0B16::move onto next byte
P:0B17::get appropriate block data and write to vram buffer
P:0B1A:MoveVOffset:decrement vram buffer offset
P:0B1B::add 10 bytes to it
P:0B1F::branch to store as new vram buffer offset
P:0B22:PutBlockMetatile:store control bit from SprDataOffset_Ctrl
P:0B24::store vram buffer offset for next byte
P:0B27::multiply A by four and use as X
P:0B29::load high byte for name table 0
P:0B2B::get low byte of block buffer pointer
P:0B31::if not, use current high byte
P:0B33::otherwise load high byte for name table 1
P:0B35:SaveHAdder:save high byte here
P:0B39::mask out high nybble of block buffer pointer
P:0B3B::multiply by 2 to get appropriate name table low byte
P:0B3C::and then store it here
P:0B40::initialize temp high byte
P:0B42::get vertical high nybble offset used in block buffer routine
P:0B45::add 32 pixels for the status bar
P:0B48::shift and rotate d7 onto d0 and d6 into carry
P:0B4B::shift and rotate d6 onto d0 and d5 into carry
P:0B4D::add low byte of name table and carry to vertical high nybble
P:0B4F::and store here
P:0B51::get whatever was in d7 and d6 of vertical high nybble
P:0B53::add carry
P:0B56::then add high byte of name table
P:0B58::store here
P:0B5A::get vram buffer offset to be used
P:0B5C:RemBridge:write top left and top right
P:0B5F::tile numbers into first spot
P:0B68::write bottom left and bottom
P:0B6B::right tiles numbers into
P:0B6E::second spot
P:0B76::write low byte of name table
P:0B79::into first slot as read
P:0B7A::add 32 bytes to value
P:0B7C::write low byte of name table
P:0B7F::plus 32 bytes into second slot
P:0B81::write high byte of name
P:0B84::table address to both slots
P:0B89::put length of 2 in
P:0B8C::both slots
P:0B91::put null terminator at end
P:0B94::get offset control bit here
P:0B96::and leave
P:0B97:WaterPaletteData:-------------------------------------------------------------------------------------\nMETATILE GRAPHICS TABLE
P:0BBB:GroundPaletteData
P:0BDF:UndergroundPaletteData
P:0C03:CastlePaletteData
P:0C27:DaySnowPaletteData
P:0C2F:NightSnowPaletteData
P:0C37:MushroomPaletteData
P:0C5B:BowserPaletteData
P:0C63:MarioThanksMessage:"THANK YOU MARIO!"
P:0C77:LuigiThanksMessage:"THANK YOU LUIGI!"
P:0C8B:MushroomRetainerSaved:"BUT OUR PRINCESS IS IN"
P:0CA4::"ANOTHER CASTLE!"
P:0CB7:MushRoomRetainerGlitchWorld
P:0CE5:PrincessSaved1
P:0CFB:PrincessSaved2
P:0D11:WorldSelectMessage1
P:0D25:WorldSelectMessage2
P:0D36:PSBN:-------------------------------------------------------------------------------------\n$00 - used to store status bar nybbles\n$02 - used as temp vram offset\n$03 - used to store length of status bar number\nstatus bar name table offset and length data
P:0D3A:PrintStatusBarNumbers:store player-specific offset
P:0D3C::use first nybble to print the coin display
P:0D3F::move high nybble to low
P:0D45:OutputNumbers:add 1 to low nybble
P:0D48::mask out high nybble
P:0D4E::save incremented value to stack for now and
P:0D4F::shift to left and use as offset
P:0D51::get current buffer pointer
P:0D58::put at top of screen by default
P:0D5A::are we writing top score on title screen?
P:0D5E::if so, put further down on the screen
P:0D60:SetupNums
P:0D63::write low vram address and length of thing
P:0D66::we're printing to the buffer
P:0D6F::save length byte in counter
P:0D73::pull original incremented value from stack
P:0D75::load offset to value we want to write
P:0D79::subtract from length byte we read before
P:0D7C::use value as offset to display digits
P:0D7F:DigitPLoop:write digits to the buffer
P:0D87::do this until all the digits are written
P:0D8B::put null terminator at end
P:0D90::increment buffer pointer by 3
P:0D93::store it in case we want to use it again
P:0D96:ExitOutputN
P:0D9C:DigitsMathRoutine:-------------------------------------------------------------------------------------\ncheck mode of operation
P:0DA1::if in title screen mode, branch to lock score
P:0DA5:AddModLoop:load digit amount to increment
P:0DA9::add to current digit
P:0DAC::if result is a negative number, branch to subtract
P:0DB0::if digit greater than $09, branch to add
P:0DB2:StoreNewD:store as new score or game timer digit
P:0DB5::move onto next digits in score or game timer
P:0DB6::and digit amounts to increment
P:0DB7::loop back if we're not done yet
P:0DB9:EraseDMods:store zero here
P:0DBB::start with the last digit
P:0DBD:EraseMLoop:initialize the digit amounts to increment
P:0DC1::do this until they're all reset, then leave
P:0DC4:BorrowOne:decrement the previous digit, then put $09 in
P:0DC7::the game timer digit we're currently on to "borrow
P:0DC9::the one", then do an unconditional branch back
P:0DCB:CarryOne
P:0DD9::subtract ten from our digit to make it a
P:0DDA::proper BCD number, then increment the digit
P:0DDC::preceding current digit to "carry the one" properly
P:0DDF::go back to just after we branched here
P:0DE2:UpdateTopScore:-------------------------------------------------------------------------------------\n        ldx BowserFront_Offset\n        lda Enemy_ID,x\n        cmp #Bowser\n        bne +\n         lda Enemy_State,x\n        lda OperMode\n        cmp #$02\n        beq +\n        lda BowserHitPoints\n        beq CODE\n        cmp #$ff\n        beq CODE\n+\n        rts\n        CODE:\n        JMP HandleAxeMetatile\nrts
P:0DE3:DefaultSprOffsets:-------------------------------------------------------------------------------------
P:0DF2:InitializeGame:-------------------------------------------------------------------------------------\nclear all memory as in initialization procedure,
P:0DF4::but this time, clear only as far as $076f
P:0DF9:ClrSndLoop:clear out memory used
P:0DFC::by the sound engines
P:0E02::set demo timer
P:0E0F:InitializeArea
P:0E2C::sty HurryUp
P:0E32::clear all memory again, only as far as $074b
P:0E34::this is only necessary if branching from
P:0E45:ClrTimersLoop:clear out memory between
P:0E48::$0780 and $07a1
P:0E4E::if AltEntranceControl not set, use halfway page, if any found
P:0E53::otherwise use saved entry page number here
P:0E56:StartPage:set as value here
P:0E5C::set flag here if halfway page or saved entry page number found
P:0E61::also set as current page
P:0E64::get coordinate of screen's left boundary
P:0E68::add 255 pixels
P:0E6A::store as coordinate of screen's right boundary
P:0E6D::get page number where left boundary is
P:0E70::add carry from before
P:0E72::store as page number where right boundary is
P:0E75::lda EntrancePage\nbne +
P:0E80::if on odd numbered page, use $2480 as start of rendering
P:0E82::otherwise use $2080, this address used later as name table
P:0E84::address for rendering of game area
P:0E88:SetInitNTHigh:store name table address
P:0E8D::ldx EntrancePage\nbeq +\nldy #$94
P:0E90::store LSB of page number in high nybble
P:0E91::of block buffer column position
P:0EA1::set value for renderer to update 12 column sets
P:0EA3::12 column sets = 24 metatile columns = 1 1/2 screens
P:0EA6::get enemy and level addresses and load header
P:0EA9::check to see if primary hard mode has been activated
P:0EAC::if so, activate the secondary no matter where we're at
P:0EB1::if less than 5, do not activate secondary
P:0EB5::if not equal to, then world > 5, thus activate
P:0EB7::otherwise, world 5, so check level number
P:0EBA::if 1 or 2, do not set secondary hard mode flag
P:0EBE:SetSecHard:set secondary hard mode flag for areas 5-3 and beyond
P:0EC1:CheckHalfway
P:0ECB::if halfway page set, overwrite start position from header
P:0ED0:DoneInitArea:silence music
P:0EE3::disable screen output
P:0EF4::increment one of the modes
P:0F18::add #$01
P:0F34::			   ldy #$00\n			   lda #$00\n-:			   sta Saved_ID,y\n			   sta Saved_X_Position,y\n			   sta Saved_Y_Position,y\n			   sta Saved_PageLoc,y\n			   ;sta Saved_isDefeated,y\n			   iny\n			   cpy #$80\n			   bne -\n			   lda #$02\n			   sta Saved_isDefeated\n			   sta Saved_isDefeated+1\n			   sta Saved_isDefeated+2\n			   sta Saved_isDefeated+3\n			   sta Saved_isDefeated+4\n			   sta Saved_isDefeated+5\n			   lda #$00\n-:			   tya\n			   sta SavedOffset,y\n			   tay\n			   iny\n			   cpy #$06\n			   bne -
P:0F4D:PrimaryGameSetup:rts\n-------------------------------------------------------------------------------------
P:0F55::set flag to load game timer from header
P:0F58::set player's size to small
P:0F5D::give each player five lives
P:0F60:SecondaryGameSetup:lda NumberofLives-OnscreenPlayerInfo\nsta OffScr_NumberofLives
P:0F62::enable screen output
P:0F66:ClearVRLoop:clear buffer at $0300-$03ff
P:0F6C:ClearVRLoo2:clear buffer at $0300-$03ff
P:0F72::clear game timer exp flag
P:0F75::clear skip lives display flag
P:0F78::clear value here
P:0F7D::initialize balance platform assignment flag
P:0F80::get left side page location
P:0F83::mask out all but LSB of page location
P:0F85::this is to set the proper PPU name table
P:0F88::load proper music into queue
P:0F8B::load sprite shuffle amounts to be used later
P:0F9A::load default OAM offsets into $06e4-$06f2
P:0F9C:ShufAmtLoop
P:0FA2::do this until they're all set
P:0FA8::increment to next task
P:0FC1::get player colors
P:0FC4:MusicSelectData
P:0FCB:GetAreaMusic:if in title screen mode, leave
P:0FD0::check for specific alternate mode of entry
P:0FD3::if found, branch without checking starting position
P:0FD5::from area object data header
P:0FD7::select music for pipe intro scene by default
P:0FD9::check value from level header for certain values
P:0FDE::load music for pipe intro scene if header
P:0FE0::start position either value $06 or $07
P:0FE4:ChkAreaType
P:0FF2::load area type as offset for music bit
P:0FF8::check for cloud type override
P:0FFA::select music for cloud type level if found
P:0FFC:StoreMusic:otherwise select appropriate music for level type
P:1008::store in queue and leave
P:100A:ExitGetM
P:100B:WorldNumberOffsetY:-------------------------------------------------------------------------------------
P:1014:Wo1
P:1014:YposLevelOffset
P:1019:Wo2
P:101E:Wo3
P:1022:Wo4
P:1026:Wo5
P:102A:Wo6
P:102E:Wo7
P:1033:Wo8
P:1037:Wo9
P:103C:Entrance_GameTimerSetup
P:103F::ldy EntrancePage\nbeq +\nlda ScreenLeft_PageLoc      ;set current page for area objects\nclc\nadc #$01\nas page location for player
P:1044::store value here
P:1047::for fractional movement downwards if necessary
P:104A::set high byte of player position and
P:104C::set facing direction so that player faces right
P:1050::set player state to on the ground by default
P:1053::initialize player's collision bits
P:1056::initialize halfway page
P:105A::check area type
P:105D::if water type, set swimming flag, otherwise do not set
P:1060:ChkStPos
P:1063::get starting position loaded from header
P:1066::check alternate mode of entry flag for 0 or 1
P:106F::if not 0 or 1, override $0710 with new offset in X
P:1072:SetStPos:load appropriate horizontal position
P:1075::and vertical positions for the player, using
P:1077::lda EntrancePage
P:1083::lda ScreenRight_PageLoc\nadc #$00\nsta ScreenRight_PageLoc
P:1096::set player sprite attributes using offset in X
P:1099::lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
P:10B4::or value that overwrote $0710 as offset for vertical
P:10B6::get appropriate player palette
P:10B9::get timer control value from header
P:10BC::if set to zero, branch (do not use dummy byte for this)
P:10BE::do we need to set the game timer? if not, use 
P:10C1::old game timer setting
P:10C3::if game timer is set and game timer flag is also set,
P:10C6::use value of game timer control for first digit of game timer
P:10D9::set last digit of game timer to 1
P:10DF::set second digit of game timer
P:10E4::clear flag for game timer reset
P:10EA::clear star mario timer
P:10ED:ChkOverR:if controller bits not set, branch to skip this part
P:10F2::set player state to climbing
P:10F6::set offset for first slot, for block object
P:10FB::set vertical coordinate for block object
P:10FF::set offset in X for last enemy object buffer slot
P:1101::set offset in Y for object coordinates used earlier
P:1103::do a sub to grow vine
P:1106:ChkSwimE:set to run player entrance subroutine
P:1106:SetPESub
P:1108::on the next frame of game engine
P:1112:putpspeeddisplay
P:1121::lda #$28\nsta VRAM_Buffer1+3,y
P:1134:FirstSprXPos
P:1138:FirstSprYPos
P:113C:SecondSprXPos
P:1140:SecondSprYPos
P:1144:FirstSprTilenum
P:1148:SecondSprTilenum
P:114C:HammerSprAttrib
P:1150:JumpingCoinTiles
P:1154:PlayerLoseLife:-------------------------------------------------------------------------------------\npage numbers are in order from -1 to -4\nHalfwayPageNybbles:\n      .db $56, $40\n      .db $65, $70\n      .db $66, $40\n      .db $66, $40\n      .db $66, $40\n      .db $66, $60\n      .db $65, $70\n      .db $00, $00\ndisable screen and sprite 0 check
P:115C::silence music
P:1160::take one life from player
P:1168::if player still has lives, branch
P:116C::initialize mode task,
P:116F::switch to game over mode
P:1171::and leave
P:1175:StillInGame:beginning of the level
P:1177::store as halfway page for player
P:117A::jsr TransposePlayers     ;switch players around if 2-player game\ncontinue the game
P:117D:GameOverMode:-------------------------------------------------------------------------------------
P:1189:SetupGameOver:-------------------------------------------------------------------------------------\nreset screen routine task control for title screen, game,
P:118B::and game over modes
P:118E::disable sprite 0 check
P:1191::set continue as default choice
P:1195::put game over music in secondary queue
P:1197::disable screen output
P:119A::set secondary mode to 1
P:119E:RunGameOver:-------------------------------------------------------------------------------------\nreenable screen
P:11A3::lda WorldNumber       ;if on world 8, branch on to end the game\ncmp #FinalWorld\nbeq W8End\notherwise run game over menu
P:11AE:W8End
P:11B3:TerminateGame:check controller for start pressed\nif not pressed, wait for\nscreen timer to expire\nsilence music
P:11B7::otherwise put world number of current
P:11BA::player into secret continue function variable
P:11BF::reset all modes to title screen and
P:11C2::leave
P:11D1:ExRGO
P:11D2:ContinueGame:update level pointer with
P:11D5::actual world and area numbers, then
P:11D7::reset player's size, status, and
P:11DA::set game timer flag to reload
P:11DD::game timer from header
P:11DF::also set flag for timers to count again
P:11E5::reset task for game core
P:11E7::set modes and leave
P:11EA::if in game over mode, switch back to
P:11EF::game mode, because game is still on
P:11F5:GameIsOn
P:11F6:ExTrans:           ldx #$06\nTransLoop: lda OnscreenPlayerInfo,x    ;transpose the information\n           pha                         ;of the onscreen player\n           lda OffscreenPlayerInfo,x   ;with that of the offscreen player\n           sta OnscreenPlayerInfo,x\n           pla\n           sta OffscreenPlayerInfo,x\n           dex\n           bpl TransLoop\nsec\nlda NumberOfPlayers       ;if only a 1 player game, leave\nbeq ExTrans\nclear carry flag to get game going\nrts\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n These two includes aren't quite as self-contained as They could be\n 0x1cc4, 0x1226\ninclude tools\output.txt\ninclude code\levelData.asm\ninclude code\levelData_great.asm
P:11F6:LevelDataStart
P:11F6:TransposePlayers
P:11F7:GameMode:-------------------------------------------------------------------------------------\nindirect jump routine called when\nOperMode is set to 1
P:120D:GameCoreRoutine:-------------------------------------------------------------------------------------\nlda CurrentPlayer\nand #%00000001\ntax\nldx CurrentPlayer          ;get which player is on the screen\nlda SavedJoypadBits;,x      ;use appropriate player's controller bits\nsta SavedJoypadBits        ;as the master controller bits\nexecute one of many possible subs
P:1210::check major task of operating mode
P:1213::if we are supposed to be here,
P:1215::branch to the game engine itself
P:1218:GameEngine:check player's status
P:121D::if not fiery, branch
P:121F::process fireballs and air bubbles
P:1224::put incremented offset in X as enemy object offset
P:1226::process enemy objects
P:1229::load control for floatey number
P:122E::process floatey numbers
P:1231::
P:1232::do these two subroutines until the whole buffer is done
P:1236::set offsets for player-specific variables
P:1238::save offscreen bits offset to stack for now
P:123A::do subroutine here
P:1241::store here
P:124A::mask together with previously saved low nybble
P:124C::store both here
P:124E::get offscreen bits offset from stack
P:1250::get value here and store elsewhere
P:1255::ldx ObjectOffset\nset offsets for relative cooordinates
P:1257::routine to correspond to player object
P:1259::load vertical coordinate low
P:125B::store here
P:125E::load horizontal coordinate
P:1260::subtract left edge coordinate
P:1264::store result here
P:1269::draw the player
P:126C::replace block objects with metatiles if necessary
P:1271::set offset for second
P:1273::process second block object
P:1277::set offset for first
P:1279::process first block object
P:127C::process misc objects (hammer, jumping coins)
P:127F::process bullet bill cannons
P:1282::lda FramesMissed\n beq +\n dec FramesMissed\nlda AreaType\nbne +\njsr ProcessWhirlpools      ;process whirlpools
P:12A2::if flagpole flag not found,
P:12A4::branch to leave
P:12AE::process the flagpole
P:12B1::count down the game timer
P:12B6::if player is below the screen, don't bother with the music
P:12C1::to re-attain appropriate level music
P:12CC::if star mario invincibility timer at zero,
P:12CF::skip this part
P:12EA::if not yet at a certain point, continue
P:12EC::if interval timer not yet expired,
P:12EF::branch ahead, don't bother with the music
P:12F1::to re-attain appropriate level music
P:12F4:NoChgMus:get invincibility timer
P:12F7::get frame counter
P:12F9::if timer still above certain point,
P:12FB::branch to cycle player's palette quickly
P:12FD::otherwise, divide by 8 to cycle every eighth frame
P:12FF:CycleTwo:if branched here, divide by 2 to cycle every other frame
P:1300::do sub to cycle the palette (note: shares fire flower code)
P:1303::then skip this sub to finish up the game engine
P:1306:ClrPlrPal:do sub to clear player's palette bits in attributes
P:1309:SaveAB:save current A and B button
P:130B::into temp variable to be used on next frame
P:130F::nullify left and right buttons temp variable
P:1311:UpdScrollVar
P:1314::if vram address controller set to 6 (one of two $0341s)
P:1316::then branch to leave
P:1318::otherwise check number of tasks
P:1322::get horizontal scroll in 0-31 or $00-$20 range
P:1325::check to see if exceeded $21
P:1327::branch to leave if not
P:132C::otherwise subtract $20 to set appropriately
P:132E::and store
P:1342::reset vram buffer offset used in conjunction with
P:1344::level graphics buffer at $0341-$035f
P:1347:RunParser:update the name table with more level graphics
P:134A:ExitEng:and after all that, we're finally done!
P:134B:ScrollHandler:-------------------------------------------------------------------------------------\nload value saved here
P:134F::add value used by left/right platforms
P:1355::save as new value here to impose force on scroll
P:135D::check scroll lock flag
P:1363::skip a bunch of code here if set
P:138A:InitScrlAmt1
P:139C::check player's horizontal screen position
P:139E::if less than 80 pixels to the right, branch
P:13A7::if timer related to player's side collision
P:13AA::not expired, branch
P:13AC::get value and decrement by one
P:13AF::if value originally set to zero or otherwise
P:1452::get value and decrement by one
P:1455::if value originally set to zero or otherwise
P:1456::negative for left movement, branch
P:145B:oooooooooooooo
P:145E:ohnoeswillyrex1
P:1467::if value $01, branch and do not decrement
P:146B::otherwise decrement by one
P:146C:ChkNearMid:otherwise get original value undecremented
P:146F:ScrollScreen:lda IRQAckFlag\nbne ScrollScreen
P:147E::save value here
P:1482::add to value already set here
P:1485::save as new value here
P:148A::add to left side coordinate
P:148D::save as new left side coordinate
P:1490::save here also
P:1496::add carry to page location for left
P:1498::side of the screen
P:149B::get LSB of page location
P:149D::save as temp variable for PPU register 1 mirror
P:14E7::ldy FramesMissed\nbeq ++\nlda ParallaxOffset\nbeq ++\nlda ScrollAmount\nbeq ++\ndec ParallaxOffset
P:14EA:ohnoeswillyrex
P:14EB::save value here
P:14EF::add to value already set here
P:14F2::save as new value here
P:14F7::add to left side coordinate
P:14FA::save as new left side coordinate
P:1500::ldy FramesMissed\nbeq +\ninc ParallaxOffset\nsave here also
P:1506::add carry to page location for left
P:1508::side of the screen
P:150B::get LSB of page location
P:150D::save as temp variable for PPU register 1 mirror
P:1510:llorica
P:152A::get coordinate of screen's left boundary
P:152E::add 255 pixels
P:1530::store as coordinate of screen's right boundary
P:1533::get page number where left boundary is
P:1536::add carry from before
P:1538::store as page number where right boundary is
P:153B::skip this part
P:153E:InitScrlAmt
P:1540::initialize value here
P:1543:ChkPOffscr:set X for player offset
P:1545::get horizontal offscreen bits for player
P:1548::save them here
P:154A::load default offset (left side)
P:154C::if d7 of offscreen bits are set,
P:154D::branch with default offset
P:154F::otherwise use different offset (right side)
P:1552::check offscreen bits for d5 set
P:1554::if not set, branch ahead of this part
P:1556:KeepOnscr:get left or right side coordinate based on offset
P:155A::subtract amount based on offset
P:155D::store as player position to prevent movement further
P:155F::get left or right page location based on offset
P:1562::subtract borrow
P:1564::save as player's page location
P:1566::check saved controller bits
P:1568::against bits based on offset
P:156B::if not equal, branch
P:156F::otherwise nullify horizontal speed of player
P:1571:InitPlatScrl:nullify platform force imposed on scroll
P:1577:X_SubtracterData
P:1579:OffscrJoypadBitsData
P:157B:GameRoutines:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\nrun routine based on number (a few of these routines are   
P:157D::merely placeholders as conditions for other routines)
P:1580::00
P:1582::01
P:1584::02
P:1586::03
P:1588::04
P:158A::05
P:158C::06
P:158E::07
P:1590::08
P:1592::09
P:1594::0a
P:1596::0b
P:1598::0c
P:159A::0d
P:159C:PlayerEntrance:.dw DoorEntry				;0e\n-------------------------------------------------------------------------------------\ncheck for mode of alternate entry
P:15A1::if found, branch to enter from pipe or with vine
P:15A5::if vertical position above a certain
P:15A7::point, nullify controller bits and continue
P:15A9::with player movement code, do not return
P:15AB::check player entry bits from header
P:15B0::if set to 6 or 7, execute pipe intro code
P:15B2::otherwise branch to normal entry
P:15B6:ChkBehPipe:check for sprite attributes
P:15B9::branch if found
P:15BD:AutoControlPlayer1
P:15CD::force player to walk to the right
P:15D0:IntroEntr:execute sub to move player to the right
P:15D3::decrement timer for change of area
P:15D6::branch to exit if not yet expired
P:15D8::set flag to skip world and lives display
P:15DB::jump to increment to next area and set modes
P:15DE:EntrMode2:if controller override bits set here,
P:15E1::branch to enter with vine
P:15E3::otherwise, set value here then execute sub
P:15E5::to move player upwards (note $ff = -1)
P:15E8::check to see if player is at a specific coordinate
P:15EA::if player risen to a certain point (this requires pipes
P:15EC::to be at specific height to look/function right) branch
P:15EE::to the last part, otherwise leave
P:15EF:VineEntr
P:15F2::check vine height
P:15F4::if vine not yet reached maximum height, branch to leave
P:15F6::get player's vertical coordinate
P:15F8::check player's vertical coordinate against preset value
P:15FA::load default values to be written to 
P:15FC::this value moves player to the right off the vine
P:15FE::if vertical coordinate < preset value, use defaults
P:1602::otherwise set player state to climbing
P:1604::increment value in Y
P:1605::set block in block buffer to cover hole, then 
P:1607::use same value to force player to climb
P:160A:OffVine:set collision detection disable flag
P:160D::use contents of A to move player up or right, execute sub
P:1612::check player's horizontal position
P:1614::if not far enough to the right, branch to leave
P:1616:PlayerRdy:set routine to be executed by game engine next frame
P:161A::set to face player to the right
P:161E::init A
P:161F::init mode of entry
P:1622::init collision detection disable flag
P:1625::nullify controller override bits
P:1638:ExitEntr:leave!
P:1639:AutoControlPlayer:-------------------------------------------------------------------------------------\n$07 - used to hold upper limit of high byte when player falls down hole\noverride controller bits with contents of A if executing here
P:163C:PlayerCtrlRoutine:check task here
P:163E::if certain value is set, branch to skip controller bit loading
P:164C::if not in vertical area between
P:164D::status bar and bottom, branch	
P:1651::if nearing the bottom of the screen or
P:1653::not in the vertical area between status bar or bottom,
P:1655:DisJoyp:disable controller bits
P:165A:SaveJoyp:otherwise store A and B buttons in $0a
P:1661::store left and right buttons in $0c
P:166D::store up and down buttons in $0b
P:1674::check for pressing down
P:1676::if not, branch
P:1678::check player's state
P:167A::if not on the ground, branch
P:167C::check left and right
P:167E::if neither pressed, branch
P:1682::if pressing down while on the ground,
P:1684::nullify directional bits
P:1686:SizeChk:run movement subroutines
P:1689::is player small?
P:169A::check for if crouching
P:169F::if not, branch ahead
P:16A1::if big and crouching, load y with 2
P:16A3:ChkMoveDir:set contents of Y as player's bounding box size control
P:16A6::set moving direction to right by default
P:16A8::check player's horizontal speed
P:16AA::if not moving at all horizontally, skip this part
P:16AC::if moving to the right, use default moving direction
P:16AE::otherwise change to move to the left
P:16AF:SetMoveDir:set moving direction
P:16B1:PlayerSubs:move the screen if necessary
P:16B4::set offsets for player-specific variables
P:16B6::and get offscreen information about player
P:16B8::save offscreen bits offset to stack for now
P:16BA::do subroutine here
P:16C1::store here
P:16CA::mask together with previously saved low nybble
P:16CC::store both here
P:16CE::get offscreen bits offset from stack
P:16D0::get value here and store elsewhere
P:16D7::get coordinates relative to the screen
P:16DA::set offset for player object
P:16DC::get player's bounding box coordinates
P:16DF::do collision detection and process
P:16F1::check to see if player is higher than 64th pixel
P:16F3::if so, branch ahead
P:16F7::if running end-of-level routine, branch ahead
P:16FB::if running player entrance routine, branch ahead
P:16FF::if running routines $00-$03, branch ahead
P:170A::otherwise nullify player's
P:170C::background priority flag
P:170F:PlayerHole:check player's vertical high byte
P:1711::for below the screen
P:1713::branch to leave if not that far down
P:173A::set scroll lock
P:1742::set value here
P:1744::use X as flag, and clear for cloud level
P:1746::check game timer expiration flag
P:1749::if set, branch
P:174B::check for cloud type override
P:174E::skip to last part if found
P:1750:HoleDie:set flag in X for player death
P:1753::check for some other routine running
P:1755::if so, branch ahead
P:175C::check value here
P:175F::if already set, branch to next part
P:1762::otherwise play death music
P:1764::and set value here
P:1767:HoleBottom
P:1769::change value here
P:176B:ChkHoleX:compare vertical high byte with value set here
P:176D::if less, branch to leave
P:176F::otherwise decrement flag in X
P:1770::if flag was clear, branch to set modes and other values
P:1772::check to see if music is still playing
P:1775::branch to leave if so
P:1777::otherwise set to run lose life routine
P:1779::on next frame
P:177B:ExitCtrl:leave
P:177C:CloudExit
P:177E::clear controller override bits if any are set
P:1781::do sub to set secondary mode
P:1784::set mode of entry to 3
P:1788:Vine_AutoClimb:-------------------------------------------------------------------------------------\ncheck to see whether player reached position
P:178A::above the status bar yet and if so, set modes
P:1792:AutoClimb:set controller bits override to up
P:1797::set player state to climbing
P:179E:SetEntr:set starting position to override
P:17A3::set modes
P:17A6:VerticalPipeEntry:-------------------------------------------------------------------------------------
P:17B4::set 1 as movement amount
P:17B6::do sub to move player downwards
P:17B9::do sub to scroll screen with saved force if necessary
P:17BC::load default mode of entry
P:17BE::check warp zone control variable/flag
P:17C1::if set, branch to use mode 0
P:17C4::check for castle level type
P:17C9::if not castle type level, use mode 1
P:17CC::otherwise use mode 2
P:17CF:MovePlayerYAxis
P:17D0::add contents of A to player position
P:17D5:UpsideDownPipeEntry
P:17E6::do sub to move player downwards
P:17E9::do sub to scroll screen with saved force if necessary
P:17EC::load default mode of entry
P:17EE::check warp zone control variable/flag
P:17F1::if set, branch to use mode 0
P:17F4::check for castle level type
P:17F9::if not castle type level, use mode 1
P:17FC::otherwise use mode 2
P:17FF:DoorEntry
P:180A::load default mode of entry
P:180C::check warp zone control variable/flag
P:180F::if set, branch to use mode 0
P:1812::check for castle level type
P:1817::if not castle type level, use mode 1
P:181A::otherwise use mode 2
P:181D:MovePlayerYAxisUp:add contents of A to player position
P:1825:SideExitPipeEntry:-------------------------------------------------------------------------------------\nexecute sub to move player to the right
P:182A:ChgAreaPipe:decrement timer for change of area
P:182F::when timer expires set mode of alternate entry
P:1832:ChgAreaMode:set flag to disable screen output
P:1837::set secondary mode of operation
P:183A::disable sprite 0 check
P:183D:ExitCAPipe:leave
P:183E:EnterSidePipe:set player's horizontal speed
P:1842::set controller right button by default
P:1844::mask out higher nybble of player's
P:1846::horizontal position
P:184A::if lower nybble = 0, set as horizontal speed
P:184C::and nullify controller bit override here
P:184D:RightPipe:use contents of Y to
P:184E::execute player control routine with ctrl bits nulled
P:1851:PlayerChangeSize:-------------------------------------------------------------------------------------\ncheck master timer control
P:1854::for specific moment in time
P:1856::branch if before or after that point
P:1858::otherwise run code to get growing/shrinking going
P:185B:EndChgSize:check again for another specific moment
P:185D::and branch to leave if before or after that point
P:185F::otherwise do sub to init timer control and set routine
P:1862:ExitChgSize:and then leave
P:1863:PlayerInjuryBlink:-------------------------------------------------------------------------------------\ncheck master timer control
P:1866::for specific moment in time
P:1868::branch if before that point
P:186A::check again for another specific point
P:186C::branch if at that point, and not before or after
P:186E::otherwise run player control routine
P:1871:ChangeSiz
P:1873:InitChangeSize:if growing/shrinking flag already set
P:1876::then branch to leave
P:1878::otherwise initialize player's animation frame control
P:1892:ExitBoth:leave
P:1893:PlayerDeath:-------------------------------------------------------------------------------------\n$00 - used in CyclePlayerPalette to store current palette to cycle\ncheck master timer control
P:1896::for specific moment in time
P:1898::branch to leave if before that point
P:18A7::otherwise run player control routine
P:18AA:DonePlayerTask
P:18AC::initialize master timer control to continue timers
P:18B1::set player control routine to run next frame
P:18B3::leave
P:18B4:PlayerFireFlower:check master timer control
P:18B7::for specific moment in time
P:18B9::branch if at moment, not before or after
P:18BB::get frame counter
P:18BE::divide by four to change every four frames
P:18BF:CyclePlayerPalette:mask out all but d1-d0 (previously d3-d2)
P:18C1::store result here to use as palette bits
P:18C3::get player attributes
P:18C6::save any other bits but palette bits
P:18C8::add palette bits
P:18CA::store as new player attributes
P:18CD::and leave
P:18CE:ResetPalFireFlower:do sub to init timer control and run player control routine
P:18D1:ResetPalStar:get player attributes
P:18D4::mask out palette bits to force palette 0
P:18D6::store as new player attributes
P:18D9:ExitDeath:leave from death routine
P:18DA:FlagpoleSlide:-------------------------------------------------------------------------------------
P:18DD::check special use enemy slot
P:18DF::for flagpole flag object
P:18E1::if not found, branch to something residual
P:18EB::load flagpole sound
P:18EE::into square 1's sfx queue
P:18F0::sta OldSquare1SoundBuffer
P:18F2::init flagpole sound queue
P:18F7::check to see if player has slid down
P:18F9::far enough, and if so, branch with no controller bits set
P:1900::otherwise force player to climb down (to slide)
P:1902:SlidePlayer:jump to player control routine
P:1905:NoFPObj:increment to next routine (this may
P:1907::be residual code)
P:1908:Hidden1UpCoinAmts:-------------------------------------------------------------------------------------
P:1910:PlayerEndLevel
P:191B::force player to walk to the right
P:1920::check player's vertical position
P:1922::if player is not yet off the flagpole, skip this part
P:1924::if scroll lock not set, branch ahead to next part
P:1927::because we only need to do this part once
P:192B::load win level music in event music queue
P:192F::turn off scroll lock to skip this part later
P:1932:ChkStop:get player collision bits
P:1935::check for d0 set
P:1936::if d0 set, skip to next part
P:1938::if star flag task control already set,
P:193B::go ahead with the rest of the code
P:193D::otherwise set task control now (this gets ball rolling!)
P:1940:InCastle:set player's background priority bit to
P:1942::give illusion of being inside the castle
P:1948:RdyNextA
P:194E::if star flag task control not yet set
P:1950::beyond last valid task number, branch to leave
P:1952::increment level number used for game logic
P:1958::check to see if we have yet reached level -4
P:195A::and skip this last part here if not
P:195C:NextArea:inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
P:195F::increment area number used for address loader
P:1962::get new level pointer
P:1965::set flag to load new game timer
P:1968::do sub to set secondary mode, disable screen and sprite 0
P:196B::reset halfway page to 0 (beginning)
P:1970::silence music and leave
P:1972:ExitNA
P:1973:Testi:-------------------------------------------------------------------------------------
P:198B:PlayerMovementSubs:set A to init crouch flag by default
P:198D::is player small?
P:1990::if so, branch
P:1997::check state of player
P:1999::if not on the ground, branch
P:199B::load controller bits for up and down
P:199D::single out bit for down button
P:199F:SetCrouch:store value in crouch flag
P:19A5:ProcMove:run sub related to jumping and swimming
P:19A8::if growing/shrinking flag set,
P:19AB::branch to leave
P:19AF::get player state
P:19B1::if climbing, branch ahead, leave timer unset
P:19B5::otherwise reset timer now
P:19B8:MoveSubs
P:19C3:NoMoveSub
P:19C4:OnGroundStateSub:-------------------------------------------------------------------------------------\n$00 - used by ClimbingSub to store high vertical adder\ndo a sub to set animation frame timing
P:19C9::if left/right controller bits not set, skip instruction
P:19CB::otherwise set new facing direction
P:19CD:GndMove:do a sub to impose friction on player's walk/run
P:19D0::do another sub to move player horizontally
P:19D8::set returned value as player's movement speed for scroll
P:19DC:FallingSub:--------------------------------
P:19DF::dump vertical movement force for falling into main one
P:19E2::movement force, then skip ahead to process left/right movement
P:19E5:ChkWhat:--------------------------------
P:1A0B:JumpSwimSub:if player's vertical speed zero
P:1A0D::or moving downwards, branch to falling
P:1A11::check to see if A button is being pressed
P:1A13::and was pressed in previous frame
P:1A15::if so, branch elsewhere
P:1A24::get vertical position player jumped from
P:1A28::subtract current from original vertical coordinate
P:1A2A::compare to value set here to see if player is in mid-jump
P:1A2D::or just starting to jump, if just starting, skip ahead
P:1A2F:DumpFall:otherwise dump falling into main fractional
P:1A35:ProcSwim:if swimming flag not set,
P:1A38::branch ahead to last part
P:1A3E:ExitMS:do a sub to get animation frame timing
P:1A41:LRWater:check left/right controller bits (check for swimming)
P:1A43::if not pressing any, skip
P:1A45::otherwise set facing direction accordingly
P:1A47:LRAir:check left/right controller bits (check for jumping/falling)
P:1A49::if not pressing any, skip
P:1A4B::otherwise process horizontal movement
P:1A4E:JSMove:do a sub to move player horizontally
P:1A51::set player's speed here, to be used for scroll later
P:1A56::check for specific routine selected
P:1A58::branch if not set to run
P:1A5C::otherwise set fractional
P:1A5F:ExitMov1
P:1A64::jump to move player vertically, then grab shell and leave
P:1A6A::jump to move player vertically, then leave
P:1A6D:ClimbAdderLow:--------------------------------
P:1A71:ClimbAdderHigh
P:1A75:ClimbingSub
P:1A78::add movement force to dummy variable
P:1A79::save with carry
P:1A7F::set default adder here
P:1A81::get player's vertical speed
P:1A83::if not moving upwards, branch
P:1A85::otherwise set adder to $ff
P:1A86:MoveOnVine:store adder here
P:1A88::add carry to player's vertical position
P:1A8A::and store to move player up or down
P:1A8E::add carry to player's page location
P:1A90::and store
P:1A96::prevent l+r
P:1A9E::compare left/right controller bits
P:1AA0::to collision flag
P:1AA3::if not set, skip to end
P:1AA5::otherwise check timer 
P:1AA8::if timer not expired, branch to leave
P:1AAC::otherwise set timer now
P:1AAF::set default offset here
P:1AB1::get facing direction
P:1AB3::move right button controller bit to carry
P:1AB4::if controller right pressed, branch ahead
P:1AB6::otherwise increment offset by 2 bytes
P:1AB8:ClimbFD:check to see if facing right
P:1AB9::if so, branch, do not increment
P:1ABB::otherwise increment by 1 byte
P:1ABC:CSetFDir
P:1ABE::add or subtract from player's horizontal position
P:1ABF::using value here as adder and X as offset
P:1AC4::add or subtract carry or borrow using value here
P:1AC6::from the player's page location
P:1ACB::get left/right controller bits again
P:1ACD::invert them and store them while player
P:1ACF::is on vine to face player in opposite direction
P:1AD1:ExitCSub:then leave
P:1AD2:InitCSTimer:initialize timer here
P:1AD6:Luigi_JumpMForceData:-------------------------------------------------------------------------------------\n$00 - used to store offset to friction data\n Luigi
P:1ADD:Luigi_FallMForceData
P:1AE4:Luigi_FrictionData
P:1AE7:Enemy_PSwitch:.db $b4, $68, $a0
P:1B03::store in queue and leave
P:1B0C::initialize vertical speed and fractional
P:1B11:JumpMForceData
P:1B18:FallMForceData
P:1B1F:PlayerYSpdData
P:1B26:InitMForceData
P:1B2D:MaxLeftXSpdData
P:1B34:MaxRightXSpdData
P:1B3B::used for pipe intros
P:1B3C:FrictionData
P:1B3F:Climb_Y_SpeedData
P:1B42:Climb_Y_MForceData
P:1B45:PlayerPhysicsSub:check player state
P:1B49::if not climbing, branch
P:1B4D::get controller bits for up/down
P:1B4F::check against player's collision detection bits
P:1B52::if not pressing up or down, branch
P:1B55::check for pressing up
P:1B5A:ProcClimb:load value here
P:1B5D::store as vertical movement force
P:1B60::load default animation timing
P:1B62::load some other value here
P:1B65::store as vertical speed
P:1B67::if climbing down, use default animation timing value
P:1B69::otherwise divide timer setting by 2
P:1B6A:SetCAnim:store animation timer setting and leave
P:1B86:CheckForJumping
P:1B90::if jumpspring animating, 
P:1B93::skip ahead to something else
P:1B95::check for A button press
P:1B99::if not, branch to something else
P:1B9B::if button not pressed in previous frame, branch
P:1B9F:NoJump
P:1BA4::otherwise, jump to something else
P:1BA7:ProcJumping
P:1BAC::check player state
P:1BAE::if on the ground, branch
P:1BB0::if swimming flag not set, jump to do something else
P:1BB3::to prevent midair jumping, otherwise continue
P:1BBA::if jump/swim timer nonzero, branch
P:1BBF::check player's vertical speed
P:1BC1::if player's vertical speed motionless or down, branch
P:1BC3::if timer at zero and player still rising, do not swim
P:1BC6:InitJS:set jump/swim timer
P:1BCB::initialize vertical force and dummy variable
P:1BD3::get vertical high and low bytes of jump origin
P:1BD5::and store them next to each other here
P:1BDD::set player state to jumping/swimming
P:1BE1::check value related to walking/running speed
P:1BE6::branch if below certain values, increment Y
P:1BE8::for each amount equal or exceeded
P:1BF5::note that for jumping, range is 0-4 for Y
P:1BF8:ChkWtr:set value here (apparently always set to 1)
P:1BFD::if swimming flag disabled, branch
P:1C02::otherwise set Y to 5, range is 5-6
P:1C04::if whirlpool flag not set, branch
P:1C09::otherwise increment to 6
P:1C0A:GetYPhy:check which player is on the screen
P:1C0F::store appropriate jump/swim
P:1C12::data here
P:1C1E::store appropriate jump/swim
P:1C21::data here
P:1C2A::store appropriate jump/swim\ndata here
P:1C3A::if swimming flag disabled, branch
P:1C3F::load swim/goomba stomp sound into
P:1C41::square 1's sfx queue
P:1C43::from swimming above water level
P:1C46:PJumpSnd:load big mario's jump sound by default
P:1C48::is mario big?
P:1C4D::if not, load small mario's jump sound
P:1C4F:SJumpSnd:store appropriate jump sound in square 1 sfx queue
P:1C51:JumpSubEnd
P:1C57:GetXPhy1
P:1C5A:aercono
P:1C6B:X_Physics
P:1C6D::init value here
P:1C71::if not set to run player control routine
P:1C73::on next frame, branch to leave
P:1C93::lda Left_Right_Buttons\nand #Left_Dir\nbne ++
P:1CA4:joe
P:1CCB:vaercono:lda SwimmingFlag\nbeq ProcPRun
P:1CCF::check something that seems to be related
P:1CD2::to mario's speed
P:1CD4::if =>$19 branch here
P:1CDB::if not branch elsewhere
P:1CDD:ProcPRun:if mario on the ground, increment Y
P:1CE8::decrement Y by default for non-water type area
P:1CE9::get left/right controller bits
P:1CEB::check against moving direction
P:1CED::if controller bits <> moving direction, skip this part
P:1CF8::check for b button pressed
P:1CFC::if pressed, skip ahead to set timer
P:1CFE::check for running timer set
P:1D01::if set, branch
P:1D03:ChkRFast:if running timer not set or level type is water, 
P:1D04::increment Y again and temp variable in memory
P:1D09::if running speed set here, branch
P:1D0E::otherwise check player's walking/running speed
P:1D10::if less than a certain amount, branch ahead
P:1D12:FastXSp:if running speed set or speed => $21 increment $00
P:1D14::and jump ahead
P:1D17:SetRTmr:lda PreviousA_B_Buttons\nand #B_Button\nbeq +
P:1D55::if b button pressed, set running timer
P:1D5A:GetXPhy:get maximum speed to the left
P:1D60::check for specific routine running
P:1D62::(player entrance)
P:1D64::if not running, skip and use old value of Y
P:1D66::otherwise set Y to 3
P:1D68:GetXPhy2
P:1DA8::if not set to run player control routine
P:1DDE::if not set to run player control routine
P:1DF0:setstoopid
P:1DF6::get maximum speed to the right
P:1DFC::get other value in memory
P:1E05::check which player is on the screen
P:1E0A::get value using value in memory as offset
P:1E10::get value using value in memory as offset
P:1E13::get value using value in memory as offset
P:1E18::init something here
P:1E1D::check facing direction against moving direction
P:1E1F::if the same, branch to leave
P:1E21::otherwise shift d7 of friction adder low into carry
P:1E24::then rotate carry onto d0 of friction adder high
P:1E27:ExitPhy:and then leave
P:1E28:PlayerAnimTmrData:-------------------------------------------------------------------------------------
P:1E2B:GetPlayerAnimSpeed:initialize offset in Y
P:1E2D::check player's walking/running speed
P:1E30::against preset amount
P:1E32::if greater than a certain amount, branch ahead
P:1E34::otherwise increment Y
P:1E35::compare against lower amount
P:1E37::if greater than this but not greater than first, skip increment
P:1E39::otherwise increment Y again
P:1E3A:ChkSkid:get controller bits
P:1E3D::mask out A button
P:1E3F::if no other buttons pressed, branch ahead of all this
P:1E41::mask out all others except left and right
P:1E43::check against moving direction
P:1E45::if left/right controller bits <> moving direction, branch
P:1E47::otherwise set zero value here
P:1E49:SetRunSpd:store zero or running speed here
P:1E4F:ProcSkid:check player's walking/running speed
P:1E52::against one last amount
P:1E54::if greater than this amount, branch
P:1E58::otherwise use facing direction to set moving direction
P:1E5C::nullify player's horizontal speed
P:1E5E::and dummy variable for player
P:1E61:SetAnimSpd:get animation timer setting using Y as offset
P:1E68:ImposeFriction:-------------------------------------------------------------------------------------
P:1E73::perform AND between left/right controller bits and collision flag
P:1E76::cmp #$00                  ;then compare to zero (this instruction is redundant)\nif any bits set, branch to next part
P:1E7A::if player has no horizontal speed, branch ahead to last part
P:1E7C::if player moving to the right, branch to slow
P:1E7E::otherwise logic dictates player moving left, branch to slow
P:1E80:JoypFrict:put right controller bit into carry
P:1E81::if left button pressed, carry = 0, thus branch
P:1E83:LeftFrict:load value set here
P:1E87::add to it another value set here
P:1E8A::store here
P:1E8F::add value plus carry to horizontal speed
P:1E92::set as new horizontal speed
P:1E94::compare against maximum value for right movement
P:1E97::if horizontal speed greater negatively, branch
P:1E99::otherwise set preset value as horizontal speed
P:1E9C::thus slowing the player's left movement down
P:1E9E::skip to the end
P:1EA1:RghtFrict:load value set here
P:1EA5::subtract from it another value set here
P:1EA8::store here
P:1EAD::subtract value plus borrow from horizontal speed
P:1EB0::set as new horizontal speed
P:1EB2::compare against maximum value for left movement
P:1EB5::if horizontal speed greater positively, branch
P:1EB7::otherwise set preset value as horizontal speed
P:1EBA::thus slowing the player's right movement down
P:1EBC:XSpdSign:if player not moving or moving to the right,
P:1EBE::branch and leave horizontal speed value unmodified
P:1EC2::otherwise get two's compliment to get absolute
P:1EC3::unsigned walking/running speed
P:1EC5:SetAbsSpd:store walking/running speed here and leave
P:1EC8:NoFBall3
P:1EC9:ProcFireball_Bubble:-------------------------------------------------------------------------------------\n$00 - used to store downward movement force in FireballObjCore\n$02 - used to store maximum vertical speed in FireballObjCore\n$07 - used to store pseudorandom bit in BubbleCheck\nCheckForACE:\n	  lda Enemy_X_Position\n	  sta $7001\n	  lda Up_Down_Buttons\n	  and #Up_Dir\n	  beq +\n	  lda Up_Down_Buttons\n	  and #Down_Dir\n	  beq + \n	  jmp $7002\n+:	  lda A_B_Buttons\n	  and #B_Button\n	  beq +\n	  and PreviousA_B_Buttons\n	  bne +\n	  lda Up_Down_Buttons\n	  and #Up_Dir\n	  beq +\n	  ldy $7000\n	  lda Enemy_X_Position\n	  sta $7002,y\n	  inc $7000\n+:	  rts
P:1ECB::check for b button pressed
P:1ECD::branch if not pressed
P:1ED1::if button pressed in previous frame, branch
P:1ED8::load fireball counter
P:1EDB::get LSB and use as offset for buffer
P:1EDE::load fireball state
P:1EE0::if not inactive, branch
P:1EE2::if player too high or too low, branch
P:1EE7::if player crouching, branch
P:1EEC::if player's state = climbing, branch
P:1EF2::play fireball sound effect
P:1EF6::load state
P:1EFA::copy animation frame timer setting
P:1EFD::into fireball throwing timer
P:1F01::decrement and store in player's animation timer
P:1F04::increment fireball counter
P:1F07:ProcFireballs
P:1F09::process first fireball object
P:1F0E::process second fireball object
P:1F11:FireballExplosion:then leave\nHammerObjCore:\n         stx ObjectOffset             ;store offset as current object\nRunHam:  txa                          ;add 7 to offset to use\n         clc                          ;as hammer offset for next routines\n         adc #$07\n         tax\n         jsr ImposeGravity            ;do sub here to impose gravity on hammer and move vertically               ;if any bits still set, branch to kill hammer\n         jsr FireballEnemyCollision   ;do hammer to enemy collision detection and deal with collisions\n         jmp DrawHammer               ;draw hammer appropriately and leave\nNoHam:   rts                          ;leave\nThrowHammers:\n     lda A_B_Buttons\n      and #B_Button              ;check for b button pressed\n      beq ProcHammer          ;branch if not pressed\n      and PreviousA_B_Buttons\n      bne ProcHammer          ;if button pressed in previous frame, branch\n      lda FireballCounter        ;load hammer counter\n      and #%00000001             ;get LSB and use as offset for buffer\n      tax\n      lda Fireball_State,x       ;load hammer state\n      bne ProcHammer          ;if not inactive, branch\n      ldy Player_Y_HighPos       ;if player too high or too low, branch\n      dey\n      bne ProcHammer\n      lda CrouchingFlag          ;if player crouching, branch\n      bne ProcHammer\n     lda Player_State           ;if player's state = climbing, branch\n      cmp #$03\n      beq ProcHammer\n      lda #Sfx_Fireball          ;play fireball sound effect\n      sta Square1SoundQueue\n      lda #$02                   ;load state\n      sta Fireball_State,x\n      ldy PlayerAnimTimerSet     ;copy animation frame timer setting\n      sty FireballThrowingTimer  ;into fireball throwing timer\n      dey\n      sty PlayerAnimTimer        ;decrement and store in player's animation timer\n      inc FireballCounter        ;increment fireball counter\nProcHammer:\n      ldx #$00\n      jsr HammerObjCore  ;process first fireball object\n      ldx #$01\n      jsr HammerObjCore  ;process second fireball object, then do air bubbles\n	  jmp ProcAirBubbles
P:1F14:DrawExplosion_Fireball:get OAM data offset of alternate sort for fireball's explosion
P:1F17::load fireball state
P:1F19::increment state for next frame
P:1F1B::divide by 2
P:1F1C::mask out all but d3-d1
P:1F1E::check to see if time to kill fireball
P:1F20::branch if so, otherwise continue to draw explosion
P:1F22:DrawExplosion_Fireworks:use whatever's in A for offset
P:1F23::get tile number using offset
P:1F26::increment Y (contains sprite data offset)
P:1F27::into second row sprites
P:1F2D::and into first row sprites
P:1F30::and dump into tile number part of sprite data
P:1F33::decrement Y so we have the proper offset again
P:1F34::return enemy object buffer offset to X
P:1F36::get relative vertical coordinate
P:1F39::subtract four pixels vertically
P:1F3A::for first and third sprites
P:1F42::add eight pixels vertically
P:1F43::for second and fourth sprites
P:1F4B::get relative horizontal coordinate
P:1F4E::subtract four pixels horizontally
P:1F4F::for first and second sprites
P:1F57::add eight pixels horizontally
P:1F58::for third and fourth sprites
P:1F60::set palette attributes for all sprites, but
P:1F62::set no flip at all for first sprite
P:1F67::set vertical flip for second sprite
P:1F6C::set horizontal flip for third sprite
P:1F71::set both flips for fourth sprite
P:1F74::we are done
P:1F75:KillFireBall:clear fireball state to kill it
P:1F79:NoFBall2
P:1F7A:FireballXSpdData
P:1F7C:FireballObjCore:store offset as current object
P:1F7E::check for d7 = 1
P:1F80::if so, branch to get relative coordinates and draw explosion
P:1F82::if fireball inactive, branch to leave
P:1F86::if fireball state set to 1, skip this part and just run it
P:1F89::get player's horizontal position
P:1F8B::add four pixels and store as fireball's horizontal position
P:1F8F::get player's page location
P:1F91::add carry and store as fireball's page location
P:1F95::get player's vertical position and store
P:1F99::set high byte of vertical position
P:1F9D::get player's facing direction
P:1F9F::decrement to use as offset here
P:1FA0::set horizontal speed of fireball accordingly
P:1FA5::set vertical speed of fireball
P:1FAB::set bounding box size control for fireball
P:1FAE::decrement state to 1 to skip this part from now on
P:1FB0:RunFB:add 7 to offset to use
P:1FB1::as fireball offset for next routines
P:1FB5::set downward movement force here
P:1FB9::set maximum speed here
P:1FBF::do sub here to impose gravity on fireball and move vertically
P:1FC2::do another sub to move it horizontally
P:1FC5::return fireball offset to X
P:1FC7::set for fireball offsets
P:1FC9::move offset to A
P:1FCB::add amount of bytes to offset depending on setting in Y
P:1FD1::load vertical coordinate low
P:1FD3::store here
P:1FD6::load horizontal coordinate
P:1FD8::subtract left edge coordinate
P:1FDC::store result here
P:1FE1::set for fireball offsets
P:1FE3::move offset to A
P:1FE5::add amount of bytes to offset depending on setting in Y
P:1FE9::set other offset for fireball's offscreen bits
P:1FEB::save offscreen bits offset to stack for now
P:1FED::do subroutine here
P:1FF4::store here
P:1FFD::mask together with previously saved low nybble
P:1FFF::store both here
P:2001::get offscreen bits offset from stack
P:2003::get value here and store elsewhere
P:200A::add seven bytes to offset
P:200B::to use in routines as offset for fireball
P:200F::set offset for relative coordinates
P:2011::save offset here
P:2013::store object coordinates relative to screen
P:2016::vertically and horizontally, respectively
P:201D::multiply offset by four and save to stack
P:2021::use as offset for Y, X is left alone
P:2022::load value here to be used as offset for X
P:2025::multiply that by four and use as X
P:2028::add the first number in the bounding box data to the
P:202A::relative horizontal coordinate using enemy object offset
P:202B::and store somewhere using same offset * 4
P:202E::store here
P:2034::add the third number in the bounding box data to the
P:2037::relative horizontal coordinate and store
P:203A::increment both offsets
P:203C::add the second number to the relative vertical coordinate
P:203E::using incremented offset and store using the other
P:203F::incremented offset
P:2048::add the fourth number to the relative vertical coordinate
P:204B::and store
P:204E::get original offset loaded into $00 * y from stack
P:204F::use as Y
P:2050::get original offset and use as X again
P:2052::jump to handle any offscreen coordinates
P:2055::do fireball to background collision detection
P:2058::get fireball offscreen bits
P:205B::mask out certain bits
P:205D::if any bits still set, branch to kill fireball
P:205F::do fireball to enemy collision detection and deal with collisions
P:2062::get fireball's sprite data offset
P:2065::get relative vertical coordinate
P:2068::store as sprite Y coordinate
P:206B::get relative horizontal coordinate
P:206E::store as sprite X coordinate, then do shared code
P:2071::get frame counter
P:2073::divide by four
P:2075::save result to stack
P:2076::mask out all but last bit
P:2078::set either tile $64 or $65 as fireball tile
P:207A::thus tile changes every four frames
P:207D::get from stack
P:207E::divide by four again
P:2080::load value $02 to set palette in attrib byte
P:2082::if last bit shifted out was not set, skip this
P:2084::otherwise flip both ways every eight frames
P:2086:FireA:store attribute byte and leave
P:208A:EraseFB:erase fireball state
P:208E:NoFBall
P:208F:RunGameTimer:-------------------------------------------------------------------------------------\nget primary mode of operation
P:2092::branch to leave if in title screen mode
P:2096::if routine number less than eight running,
P:2098::branch to leave
P:209A::if running death routine,
P:209C::branch to leave
P:20A0::if player below the screen,
P:20A2::branch to leave regardless of level type
P:20A4::if game timer control not yet expired,
P:20A7::branch to leave
P:20AC::otherwise check game timer digits
P:20B2::if game timer digits at 000, branch to time-up code
P:20B4::otherwise check first digit
P:20B7::branch to reset game timer control
P:20B9::if timer not at 60, branch to reset game timer control
P:20BE::otherwise check second and third digits
P:20C3::branch to reset game timer control
P:20C7::otherwise load time running out music
P:20E5:ResGTCtrl
P:20E8::reset game timer control
P:20F6::set offset for last digit
P:20F8::set value to decrement game timer digit
P:20FD::do sub to decrement game timer slowly
P:2102::write player's score and coin tally to screen
P:2105::set status nybbles to update game timer display
P:2107::do sub to update the display
P:210A:ExGTimer1:ldy VRAM_Buffer1_Offset   \nlda VRAM_Buffer1-3,y      ;check highest digit of score\nbne ExGTimer1                ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-3,y
P:210B:TimeUpOn
P:2110::init player status (note A will always be zero here)
P:2113::do sub to kill the player (note player is small here)
P:2116::set game timer expiration flag
P:2119:ExGTimer:leave
P:211A:timerthings:-------------------------------------------------------------------------------------
P:211C:yeah
P:211E:WarpZoneObject:check for scroll lock flag
P:2121::branch if not set to leave
P:2123::check to see if player's vertical coordinate has
P:2125::same bits set as in vertical high byte (why?)
P:2127::if so, branch to leave
P:212D::apparently this sometimes refuses to work correctly lmao
P:213A::otherwise nullify scroll lock flag
P:213E::increment warp zone flag to make warp pipes for warp zone
P:2141::kill this object
P:2144:FlagpoleScoreMods:-------------------------------------------------------------------------------------
P:2149:FlagpoleScoreDigits
P:214E:FlagpoleRoutine
P:2152::if flagpole slide routine not running,
P:2154::branch to near the end of code
P:2158::if player state not climbing,
P:215A::branch to near the end of code
P:215C::check flagpole flag's vertical coordinate
P:215E::if flagpole flag down to a certain point,
P:2160::branch to end the level
P:2162::check player's vertical coordinate
P:2164::if player down to a certain point,
P:2166::branch to end the level
P:216B::add movement amount to dummy variable
P:216D::save dummy variable
P:2170::get flag's vertical coordinate
P:2172::add 1 plus carry to move flag, and
P:2174::store vertical coordinate
P:2179::subtract movement amount from dummy variable
P:217C::save dummy variable
P:2182::subtract one plus borrow to move floatey number,
P:2184::and store vertical coordinate here
P:2187:SkipScore:jump to skip ahead and draw flag and floatey number
P:218A:GiveFPScr:get score offset from earlier (when player touched flagpole)
P:218D:NoEL4F:get amount to award player points
P:2190::get digit with which to award points
P:2193::store in digit modifier
P:219C::and play the 1-up sound
P:21AB:NoSc4F:do sub to award player points depending on height of collision
P:21AE:NoScore
P:21B0::set to run end-of-level subroutine on next frame
P:21B2:FPGfx:get offscreen information
P:21B5::get relative coordinates
P:21B8::draw flagpole flag and floatey number
P:21BB:ExitFlagP
P:21BC:Setup_Vine1:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\nload identifier for vine object
P:21BE::store in buffer
P:21C2::set flag for enemy object buffer
P:21C7::copy page location from previous object
P:21CC::copy horizontal coordinate from previous object
P:21D1::copy vertical coordinate from previous object
P:21D3::load vine flag/offset to next available vine slot
P:21D6::if set at all, don't bother to store vertical
P:21D8::otherwise store vertical coordinate here
P:21DB:NextVO:store object offset to next available vine slot
P:21DC::using vine flag as offset
P:21DF::increment vine flag offset
P:21E4::load vine grow sound
P:21E7:VineHeightData:-------------------------------------------------------------------------------------\n$06-$07 - used as address to block buffer data\n$02 - used as vertical high nybble of block buffer offset
P:21E9:VineObjectHandler:check enemy offset for special use slot
P:21EC::if not in last slot, branch to leave
P:21F1::decrement vine flag in Y, use as offset
P:21F5::if vine has reached certain height,
P:21F8::branch ahead to skip this part
P:21FA::get frame counter
P:21FC::shift d1 into carry
P:21FE::if d1 not set (2 frames every 4) skip this part
P:2202::subtract vertical position of vine
P:2204::one pixel every frame it's time
P:2206::increment vine height
P:2209:RunVSubs:if vine still very small,
P:220C::branch to leave
P:2210::get relative coordinates of vine,
P:2213::and any offscreen bits
P:2216::initialize offset used in draw vine sub
P:2218:VDrawLoop:draw vine
P:221B::increment offset
P:221C::if offset in Y and offset here
P:221F::do not yet match, loop back to draw more vine
P:2224::mask offscreen bits
P:2226::if none of the saved offscreen bits set, skip ahead
P:2228::otherwise decrement Y to get proper offset again
P:2229:KillVine:get enemy object offset for this vine object
P:222C::kill this vine object
P:222F::decrement Y
P:2230::if any vine objects left, loop back to kill it
P:2232::initialize vine flag/offset
P:2235::initialize vine height
P:2238:WrCMTile:check vine height
P:223B::if vine small (less than 32 pixels tall)
P:223D::then branch ahead to leave
P:2243::set A to obtain horizontal in $04, but we don't care
P:2245::set Y to offset to get block at ($04, $10) of coordinates
P:2247::do a sub to get block buffer address set, return contents
P:224C::if vertical high nybble offset beyond extent of
P:224E::current block buffer, branch to leave, do not write
P:2250::otherwise check contents of block buffer at 
P:2252::current offset, if not empty, branch to leave
P:2256::otherwise, write climbing metatile to block buffer
P:2258:ExitVH:get enemy object offset and leave
P:225B:CannonBitmasks:-------------------------------------------------------------------------------------
P:225D:ProcessCannons:lda AreaType                ;get area type\nbeq ExCannon                ;if water type area, branch to leave\nlda SwimmingFlag\nbne ExCannon
P:225F:ThreeSChk:start at third enemy slot
P:2261::check enemy buffer flag
P:2263::if set, branch to check enemy
P:2265::otherwise get part of LSFR
P:2268::get secondary hard mode flag, use as offset
P:226B::mask out bits of LSFR as decided by flag
P:226E::check to see if lower nybble is above certain value
P:2270::if so, branch to check enemy
P:2272::transfer masked contents of LSFR to Y as pseudorandom offset
P:2276::get page location
P:2279::if not set or on page 0, branch to check enemy
P:227B::get cannon timer
P:227E::if expired, branch to fire cannon
P:2280::otherwise subtract borrow (note carry will always be clear here)
P:2282::to count timer down
P:2285::then jump ahead to check enemy
P:2288:FireCannon:if master timer control set,
P:228B::branch to check enemy
P:2290::otherwise we start creating one
P:2292::first, reset cannon timer
P:2295::get page location of cannon
P:2298::save as page location of bullet bill
P:229A::get horizontal coordinate of cannon
P:229D::save as horizontal coordinate of bullet bill
P:229F::get vertical coordinate of cannon
P:22A3::subtract eight pixels (because enemies are 24 pixels tall)
P:22A5::save as vertical coordinate of bullet bill
P:22A9::set vertical high byte of bullet bill
P:22AB::set buffer flag
P:22AD::shift right once to init A
P:22AE::then initialize enemy's state
P:22B2::set bounding box size control for bullet bill
P:22B7::load identifier for bullet bill (cannon variant)
P:22CC::move onto next slot
P:22CF:Chk_BB:check enemy identifier for bullet bill (cannon variant)
P:22D3::if not found, branch to get next slot
P:22D5::otherwise, check to see if it went offscreen
P:22D8::check enemy buffer flag
P:22DA::if not set, branch to get next slot
P:22DC::otherwise, get offscreen information
P:22DF::then do sub to handle bullet bill
P:22E2:Next3Slt:move onto next slot
P:22E3::do this until first three slots are checked
P:22E5:ExCannon:then leave
P:22E6:ThreeSChk1:--------------------------------
P:22E9:MoveBulletBill:check bullet bill's enemy object state for d5 set
P:22ED::if not set, continue with movement code
P:22EF::otherwise jump to move defeated bullet bill downwards
P:22F2:NotDefB:set bullet bill's horizontal speed
P:22F4::and move it accordingly (note: this bullet bill
P:22F6::object occurs in frenzy object $17, not from cannons)
P:22F9:MoveJumpingEnemy:do a sub to impose gravity on green paratroopa
P:22FC::jump to move enemy horizontally
P:22FF:BulletBillXSpdData
P:2301:BulletBillHandler:if master timer control set,
P:2304::branch to run subroutines except movement sub
P:2308::if bullet bill's state set, branch to check defeated state
P:230A::otherwise load offscreen bits
P:230D::mask out bits
P:230F::check to see if all bits are set
P:2311::if so, branch to kill this object
P:2313::set to move right by default
P:2315::get horizontal difference between player and bullet bill
P:2318::if enemy to the left of player, branch
P:231A::otherwise increment to move left
P:231B:SetupBB:set bullet bill's moving direction
P:231D::decrement to use as offset
P:231E::get horizontal speed based on moving direction
P:2321::and store it
P:2323::get horizontal difference
P:2325::add 40 pixels
P:2327::if less than a certain amount, player is too close
P:2329::to cannon either on left or right side, thus branch
P:232D::otherwise set bullet bill's state
P:2331::set enemy frame timer
P:2336::play fireworks/gunfire sound
P:2338:ChkDSte:check enemy state for d5 set
P:233C::if not set, skip to move horizontally
P:233E::otherwise do sub to move bullet bill vertically
P:2341:BBFly:increment offset for enemy offset
P:2342::position object horizontally according to
P:2345::counters, return with saved value in A,
P:2347:RunBBSubs:get offscreen information
P:234A::get relative coordinates
P:234D::get bounding box coordinates
P:2350::handle player to enemy collisions
P:2353::jsr EnemiesCollision\ndraw the bullet bill and leave
P:2356:KillBB:kill bullet bill and leave
P:2359:HammerEnemyOfsData:-------------------------------------------------------------------------------------
P:2362:HammerXSpdData
P:2364:SpawnHammerObj:          lda PseudoRandomBitReg+1 ;get pseudorandom bits from\n          and #%00000111           ;second part of LSFR\n          bne SetMOfs              ;if any bits are set, branch and use as offset\n          lda PseudoRandomBitReg+1\n          and #%00001000           ;get d3 from same part of LSFR
P:2366::if any values loaded in
P:2369::$2a-$32 where offset is then leave with carry clear
P:2370::ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset\nlda Enemy_Flag,x         ;check enemy buffer flag at offset\nbne NoHammer             ;if buffer flag set, branch to leave with carry clear\nget original enemy object offset
P:2373::save here
P:2378::save hammer's state here
P:237D::set something else entirely, here
P:2380::return with carry set
P:2382:NoHammer:get original enemy object offset
P:2384::return with carry clear
P:2386:ProcHammerObj:--------------------------------\n$00 - used to set downward force\n$01 - used to set upward force (residual)\n$02 - used to set maximum speed\nif master timer control set
P:2389::skip all of this code and go to last subs at the end
P:238B::otherwise get hammer's state
P:238D::mask out d7
P:238F::get enemy object offset that spawned this hammer
P:2392::check hammer's state
P:2394::if currently at 2, branch
P:2396::if greater than 2, branch elsewhere
P:2399::add 13 bytes to use
P:239A::proper misc object
P:239C::return offset to X
P:239F::set downward movement force
P:23A1::lda #$0f\nsta $01                    ;set upward movement force (not used)
P:23A3::set maximum vertical speed
P:23A5::set A to impose gravity on hammer
P:23A7::do sub to impose gravity on hammer and move vertically
P:23AA::do sub to move it horizontally
P:23AD::get original misc object offset
P:23AF::branch to essential subroutines
P:23B2:SetHSpd
P:23B4::set hammer's vertical speed
P:23B6::get enemy object state
P:23B9::mask out d3
P:23BB::store new state
P:23BE::get enemy's moving direction
P:23C0::decrement to use as offset
P:23C1::get proper speed to use based on moving direction
P:23C4::reobtain hammer's buffer offset
P:23C6::set hammer's horizontal speed
P:23C8:SetHPos:decrement hammer's state
P:23CA::get enemy's horizontal position
P:23CE::set position 2 pixels to the right
P:23D0::store as hammer's horizontal position
P:23D2::get enemy's page location
P:23D5::add carry
P:23D7::store as hammer's page location
P:23D9::get enemy's vertical position
P:23DD::move position 10 pixels upward
P:23DF::store as hammer's vertical position
P:23E3::set hammer's vertical high byte
P:23E5::unconditional branch to skip first routine
P:23E7:RunAllH:handle collisions
P:23EA:RunHSubs:set for misc object offsets
P:23EE::add amount of bytes to offset depending on setting in Y
P:23F1::put back in X and leave
P:23F2::set other offset for misc object's offscreen bits
P:23F4::save offscreen bits offset to stack for now
P:23FD::mask together with previously saved low nybble
P:23FF::store both here
P:2401::get offscreen bits offset from stack
P:2403::get value here and store elsewhere
P:240A::set for misc object offsets
P:240E::add amount of bytes to offset depending on setting in Y
P:2414::get the coordinates
P:2417::add nine bytes to offset
P:2418::to use in routines as offset for misc object
P:241C::set offset for relative coordinates
P:241E::get bounding box coordinates
P:2421::jump to handle any offscreen coordinates
P:2424::draw the hammer
P:2427:CoinBlock:-------------------------------------------------------------------------------------\n$02 - used to store vertical high nybble offset from block buffer routine\n$06 - used to store low byte of block buffer address\nset offset for empty or last misc object buffer slot
P:242A::get page location of block object
P:242C::store as page location of misc object
P:242F::get horizontal coordinate of block object
P:2431::add 5 pixels
P:2433::store as horizontal coordinate of misc object
P:2436::get vertical coordinate of block object
P:2438::subtract 16 pixels
P:243A::store as vertical coordinate of misc object
P:243D::jump to rest of code as applies to this misc object
P:2440:SetupJumpCoin:set offset for empty or last misc object buffer slot
P:2443::get page location saved earlier
P:2446::and save as page location for misc object
P:2449::get low byte of block buffer offset
P:244C::multiply by 16 to use lower nybble
P:244F::add five pixels
P:2451::save as horizontal coordinate for misc object
P:2454::get vertical high nybble offset from earlier
P:2456::add 32 pixels for the status bar
P:2458::store as vertical coordinate
P:245B:JCoinC
P:245D::set vertical speed
P:2460::increment coin tally used to activate 1-up block flag
P:2465::set vertical high byte
P:2468::set state for misc object
P:246B::load coin grab sound
P:246D::store current control bit as misc object offset 
P:246F::update coin tally on the screen and coin amount variable
P:2472:FindEmptyMiscSlot:start at end of misc objects buffer
P:2474:FMiscLoop:get misc object state
P:2477::branch if none found to use current offset
P:2479::decrement offset
P:247A::do this for three slots
P:247C::do this until all slots are checked
P:247E::if no empty slots found, use last slot
P:2480:UseMiscS:store offset of misc object buffer here (residual)
P:2484:MiscObjectsCore:-------------------------------------------------------------------------------------\nset at end of misc object buffer
P:2486:MiscLoop:store misc object offset here
P:2488::check misc object state
P:248A::branch to check next slot
P:248C::if d7 not set, jumping coin, thus skip to rest of code here
P:2494::otherwise go to process hammer,
P:2497::decrement misc object offset
P:2498::store misc object offset here
P:249A::check misc object state
P:249C::branch to check next slot
P:249E::if d7 not set, jumping coin, thus skip to rest of code here
P:24A6::otherwise go to process hammer,
P:24A9::decrement misc object offset
P:24AA::store misc object offset here
P:24AC::check misc object state
P:24AE::branch to check next slot
P:24B0::if d7 not set, jumping coin, thus skip to rest of code here
P:24B8::otherwise go to process hammer,
P:24BB::decrement misc object offset
P:24BC::store misc object offset here
P:24BE::check misc object state
P:24C0::branch to check next slot
P:24C2::if d7 not set, jumping coin, thus skip to rest of code here
P:24CA::otherwise go to process hammer,
P:24CD::decrement misc object offset
P:24CE::store misc object offset here
P:24D0::check misc object state
P:24D2::branch to check next slot
P:24D4::if d7 not set, jumping coin, thus skip to rest of code here
P:24DC::otherwise go to process hammer,
P:24DF::decrement misc object offset
P:24E0::store misc object offset here
P:24E2::check misc object state
P:24E4::branch to check next slot
P:24E6::if d7 not set, jumping coin, thus skip to rest of code here
P:24EE::otherwise go to process hammer,
P:24F1::decrement misc object offset
P:24F2::store misc object offset here
P:24F4::check misc object state
P:24F6::branch to check next slot
P:24F8::if d7 not set, jumping coin, thus skip to rest of code here
P:2500::otherwise go to process hammer,
P:2503::decrement misc object offset
P:2504::store misc object offset here
P:2506::check misc object state
P:2508::branch to check next slot
P:250A::if d7 not set, jumping coin, thus skip to rest of code here
P:2512::otherwise go to process hammer,
P:2515::decrement misc object offset
P:2516::store misc object offset here
P:2518::check misc object state
P:251A::branch to check next slot
P:251C::if d7 not set, jumping coin, thus skip to rest of code here
P:2521::otherwise go to process hammer,
P:2525:ProcJumpCoin:--------------------------------\n$00 - used to set downward force\n$01 - used to set upward force (residual)\n$02 - used to set maximum speed\ncheck misc object state
P:2527::decrement to see if it's set to 1
P:2528::if so, branch to handle jumping coin
P:252A::otherwise increment state to either start off or as timer
P:252C::get horizontal coordinate for misc object
P:252E::whether its jumping coin (state 0 only) or floatey number
P:252F::add current scroll speed
P:2532::store as new horizontal coordinate
P:2534::get page location
P:2536::add carry
P:2538::store as new page location
P:253C::check state of object for preset value
P:253E::if not yet reached, branch to subroutines
P:2542::otherwise nullify object state
P:2545:JCoinRun
P:2546::add 13 bytes to offset for next subroutine
P:254A::set downward movement amount
P:254E::set maximum vertical speed
P:2552::divide by 2 and set
P:2553::as upward movement amount (apparently residual)
P:2555::set A to impose gravity on jumping coin
P:2557::do sub to move coin vertically and impose gravity on it
P:255A::get original misc object offset
P:255C::check vertical speed
P:2560::if not moving downward fast enough, keep state as-is
P:2562::otherwise increment state to change to floatey number
P:2564:RunJCSubs:set for misc object offsets
P:2566::move offset to A
P:2568::add amount of bytes to offset depending on setting in Y
P:256B::put back in X and leave
P:256E::load vertical coordinate low
P:2570::store here
P:2573::load horizontal coordinate
P:2575::subtract left edge coordinate
P:2579::store result here
P:257C::return original offset
P:257E::set for misc object offsets
P:2580::move offset to A
P:2582::add amount of bytes to offset depending on setting in Y
P:2585::put back in X and leave
P:2586::set other offset for misc object's offscreen bits
P:2588::and get offscreen information about misc object
P:258B::jsr GetMiscBoundBox       ;get bounding box coordinates (why?)\ndraw the coin or floatey number
P:258E:JCoinGfxHandler:get coin/floatey number's OAM data offset
P:2591::get state of misc object
P:2593::if 2 or greater, 
P:2595::branch to draw floatey number
P:2599::store vertical coordinate as
P:259B::Y coordinate for first sprite
P:259F::add eight pixels
P:25A1::store as Y coordinate for second sprite
P:25A4::get relative horizontal coordinate
P:25AA::store as X coordinate for first and second sprites
P:25AD::get frame counter
P:25AF::divide by 2 to alter every other frame
P:25B0::mask out d2-d1
P:25B2::use as graphical offset
P:25B3::load tile number
P:25B6::increment OAM data offset to write tile numbers
P:25B7::and into first row sprites
P:25BA::and do sub to dump into first and second sprites
P:25BD::decrement to get old offset
P:25C0::set attribute byte in first sprite
P:25C5::set attribute byte with vertical flip in second sprite
P:25CB::check offscreen bits
P:25CD::if all bits clear, leave object alone
P:25D1::and into first row sprites
P:25D7:ExJCGfx:get misc object offset
P:25DA:DrawFloateyNumber_Coin
P:25E1::set number of points control for floatey numbers
P:25E6::set timer for floatey numbers
P:25EC::check offscreen bits
P:25EE::if all bits clear, leave object alone
P:25F9::set vertical coordinate
P:2602::set horizontal coordinate and leave
P:260F:CoinTallyOffsets:		  lda FrameCounter          ;get frame counter\n          lsr                       ;divide by 2\n          bcs NotRsNum              ;branch if d0 not set to raise number every other frame\n          dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate\nNotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate\n          sta Sprite_Data+4,y            ;and into first row sprites\n	      sta Sprite_Data,y              ;and do sub to dump into first and second sprites\n          lda Misc_Rel_XPos         ;get relative horizontal coordinates\n		  sta Sprite_X_Position,y\n          clc\n          adc #$08                  ;add eight pixels\n          sta Sprite_X_Position+4,y ;store as X coordinate for second sprite\n          lda #$02\n          sta Sprite_Attributes,y   ;store attribute byte in both sprites\n          sta Sprite_Attributes+4,y\n          lda #$f6\n          sta Sprite_Tilenumber,y   ;put tile numbers into both sprites\n          lda #$fb                  ;that resemble "200"\n          sta Sprite_Tilenumber+4,y\n          rts        \n-------------------------------------------------------------------------------------
P:2612:ScoreOffsets
P:2615:StatusBarNybbles
P:2619:GiveOneCoin:set digit modifier to add 1 coin
P:261B::to the current player's coin tally
P:2620::update the coin tally
P:2623::increment onscreen player's coin amount
P:2629::does player have 100 coins yet?
P:262B::if not, skip all of this
P:262F::otherwise, reinitialize coin amount
P:2634::and play the 1-up sound
P:263D::give the player an extra life
P:2644::set number of points control for floatey numbers
P:264C::set timer for floatey numbers
P:2651::set vertical coordinate
P:2657::set horizontal coordinate and leave
P:2662:CoinPoints:set digit modifier to award
P:2664::200 points to the player
P:2669:AddToScore
P:266B::update the score internally with value in digit modifier
P:266E:WriteScoreAndCoinTally
P:2670:UpdateNumber:inc bocata3\nldx ObjectOffset\nrts\nprint status bar numbers based on nybbles, whatever they be
P:2676:RealUpdateNumber:jmp NoZSup
P:267C:NoZSup:lda VRAM_Buffer1-6,y      ;check highest digit of score\nbne NoZSup                ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-6,y\nget enemy object buffer offset
P:267F:SetupPowerUp:-------------------------------------------------------------------------------------
P:268B::load power-up identifier into
P:268D::special use slot of enemy object buffer
P:268F::store page location of block object
P:2692::as page location of power-up object
P:2694::store horizontal coordinate of block object
P:2697::as horizontal coordinate of power-up object
P:269B::set vertical high byte of power-up object
P:269D::get vertical coordinate of block object
P:26A1::subtract 8 pixels
P:26A3::and use as vertical coordinate of power-up object
P:26A5:PwrUpJmp:this is a residual jump point in enemy object jump table
P:26A7::set power-up object's state
P:26A9::set buffer flag
P:26AD::set bounding box size control for power-up object
P:26B2::check currently loaded power-up type
P:26B4::if star or 1-up, branch ahead
P:26B6::otherwise check player's current status
P:26BB::if player not fiery, use status as power-up type
P:26BD::otherwise shift right to force fire flower type
P:26BE:StrType:store type here
P:26C1:PutBehind
P:26C3::set background priority bit
P:26C8::load power-up reveal sound and leave
P:26CA:ExitPUp
P:26CB:idk
P:26D4:PowerUpObjHandler:-------------------------------------------------------------------------------------\ncheck power-up object's state
P:26D6::if not set, branch to leave
P:26D8::if not set, branch ahead to skip this part
P:26DA::if master timer control set,
P:26DD::branch ahead to enemy object routines
P:26DF::check power-up type
P:26E2::if normal mushroom, branch ahead to move it
P:26E6::if 1-up mushroom, branch ahead to move it
P:26EA::if not star, branch elsewhere to skip movement
P:26EC::otherwise impose gravity on star power-up and make it jump
P:26F1::note that green paratroopa shares the same code here 
P:26F6::then jump to other power-up subroutines
P:26F9:ShroomM:do sub to make mushrooms move
P:26FE::deal with collisions
P:2701::bug fix: pswitch modifies the x register
P:2703::run the other subroutines
P:2706:GrowThePowerUp:get frame counter
P:2708::mask out all but 2 LSB
P:270A::if any bits set here, branch
P:270C::otherwise decrement vertical coordinate slowly
P:270E::load power-up object state
P:2710::increment state for next frame (to make power-up rise)
P:2712::if power-up object state not yet past 16th pixel,
P:2714::branch ahead to last part here
P:2721::make the paratroopa jump again
P:2725::otherwise set horizontal speed
P:2729::and then set d7 in power-up object's state
P:272B::shift once to init A
P:272C::initialize background priority bit set here
P:272F::rotate A to set right moving direction
P:2730::set moving direction
P:2732:ChkPUSte:check power-up object's state
P:2734::for if power-up has risen enough
P:2736::if not, don't even bother running these routines
P:2738:RunPUSubs:get coordinates relative to screen
P:273B::get offscreen bits
P:273E::get bounding box coordinates
P:2741::draw the power-up object
P:2744::check for collision with player
P:2747::check to see if it went offscreen
P:274A:ExitPUp2
P:274B:BlockYPosAdderData:-------------------------------------------------------------------------------------\nThese apply to all routines in this section unless otherwise noted:\n$00 - used to store metatile from block buffer routine\n$02 - used to store vertical high nybble offset from block buffer routine\n$05 - used to store metatile stored in A at beginning of PlayerHeadCollision\n$06-$07 - used as block buffer address indirect
P:274D:PlayerHeadCollision:store metatile number to stack
P:2759::load unbreakable block object state by default
P:275B::load offset control bit here
P:275E::check player's size
P:2761::if small, branch
P:2763::otherwise load breakable block object state
P:2765:DBlockSte:store into block object buffer
P:2767::store blank metatile in vram buffer to write to name table
P:276A::load offset control bit
P:276D::get vertical high nybble offset used in block buffer routine
P:276F::set as vertical coordinate for block object
P:2773::get low byte of block buffer address used in same routine
P:2775::save as offset here to be used later
P:2780::get contents of block buffer at old address at $06, $07
P:2791::do a sub to check which block player bumped head on
P:2794::store metatile here
P:279B::check player's size
P:279E::if small, use metatile itself as contents of A
P:27A3::otherwise init A (note: big = 0)
P:27A6:ChkBrick
P:27A7::if no match was found in previous sub, skip ahead
P:27A9::otherwise load unbreakable state into block object buffer
P:27AB::note this applies to both player sizes
P:27AD::load empty block metatile into A for now
P:27AF::get metatile from before
P:27B1::is it brick with coins (with line)?
P:27B3::if so, branch
P:27BD::is it brick with coins (without line)?
P:27BF::if not, branch ahead to store empty block metatile
P:27C1:StartBTmr:check brick coin timer flag
P:27C4::if set, timer expired or counting down, thus branch
P:27C8::if not set, set brick coin timer
P:27CB::and set flag linked to it
P:27CE:ContBTmr
P:27D1::check brick coin timer
P:27D4::if not yet expired, branch to use current metatile
P:27D9::otherwise use empty block metatile
P:27DB:PutOldMT:put metatile into A
P:27DC:PutMTileB:store whatever metatile be appropriate here
P:27DF::get block object horizontal coordinates saved
P:27E2::get vertical high nybble offset
P:27F0::write blank metatile $23 to block buffer
P:27F4::set block bounce timer
P:27F7::pull original metatile from stack
P:27F8::and save here
P:27FA::set default offset
P:27FC::is player crouching?
P:27FF::if so, branch to increment offset
P:2801::is player big?
P:2804::if so, branch to use default offset
P:2806:SmallBP:increment for small or big and crouching
P:280A:BigBP
P:2812::get player's vertical coordinate
P:2816::save as vertical coordinate for block object
P:281B:BumpChkRt:get player's vertical coordinate
P:281E::add value determined by size
P:2821::mask out low nybble to get 16-pixel correspondence
P:2823::save as vertical coordinate for block object
P:2825:JumpBack:get block object state
P:2829::if set to value loaded for unbreakable, branch
P:282B::execute code for breakable brick
P:2830::set vertical speed for player
P:2835:Unbreak:execute code for unbreakable brick or question block
P:2838:InvOBit
P:2840::leave!
P:2841:UnderWaterBumpChk:get player's vertical coordinate
P:2845::save as vertical coordinate for block object
P:284A:BumpBlock:--------------------------------
P:2852::check to see if there's a coin directly above this block
P:2857::play bump sound
P:285B::initialize horizontal speed for block object
P:285D::init fractional movement force
P:2860::init player's vertical speed
P:2864::set vertical speed for block object
P:2866::get original metatile from stack
P:2867::do a sub to check which block player bumped head on
P:286A::if no match was found, branch to leave
P:286C::move block number to A
P:286D::if block number was within 0-8 range,
P:286F::branch to use current number
P:2871::otherwise subtract 5 for second set to get proper number
P:2873:BlockCode:run appropriate subroutine depending on block number
P:28A2:MushFlowerBlock:.dw HammerMushBlock\n.dw HammerMushBlock\n.dw HammerMushBlock\n.dw MushFlowerBlock\n--------------------------------\nload mushroom/fire flower into power-up type
P:28A4::BIT instruction opcode
P:28A5:StarBlock:load star into power-up type
P:28A7::BIT instruction opcoded
P:28A8:ExtraLifeMushBlock:load 1-up mushroom into power-up type
P:28AA::store correct power-up type
P:28B1:VineBlock
P:28B9::get control bit
P:28BC::set up vine object
P:28BF:ExitBlockChk:leave
P:28C0:BrickQBlockMetatiles:--------------------------------\nused by question blocks
P:28CD::these two sets are functionally identical, but look different\n, $70, $6f, $c4, $72 ;used by ground level types
P:28D6::, $71, $6f, $c4, $72 ;used by other level types
P:28DF:BlockBumpedChk:BrickQBlockMetatiles:\n.db $c1, $c2, $c0, $5e, $5f, $60, $61 ;used by question blocks\n.db $52, $53, $54, $55, $56, $57 ;used by ground level bricks\n.db $58, $59, $5a, $5b, $5c, $5d ;used by other level bricks\nstart at end of metatile data
P:28E1:BumpChkLoop:check to see if current metatile matches
P:28E4::metatile found in block buffer, branch if so
P:28E6::otherwise move onto next metatile
P:28E7::do this until all metatiles are checked
P:28E9::if none match, return with carry clear
P:28EA:MatchBump:note carry is set if found match
P:28EB:BrickShatter:--------------------------------\ncheck to see if there's a coin directly above this block
P:28F0::set flag for block object to immediately replace metatile
P:28F6::load brick shatter sound
P:28F8::set horizontal coordinate of block object
P:28FA::as original horizontal coordinate here
P:28FF::set horizontal speed for brick chunk objects
P:2905::set vertical speed for one
P:2909::set lower vertical speed for the other
P:290D::init fractional movement force for both
P:2915::copy page location
P:2919::copy horizontal coordinate
P:291D::add 8 pixels to vertical coordinate
P:291E::and save as vertical coordinate for one of them
P:2924::set digit modifier to give player 50 points
P:2927::do sub to update the score
P:292A::load control bit and leave
P:292E:CheckTopOfBlock:--------------------------------\nload control bit
P:2931::get vertical high nybble offset used in block buffer
P:2933::branch to leave if set to zero, because we're at the top
P:2935::otherwise set to A
P:2937::subtract $10 to move up one row in the block buffer
P:2939::store as new vertical high nybble offset
P:293C::get contents of block buffer in same column, one row up
P:2943::is it a coin? (not underwater)
P:2945::if not, branch to leave
P:294D::otherwise put blank metatile where coin was
P:2952::write blank metatile to vram buffer
P:2955::get control bit
P:2958::create jumping coin object and update coin variable
P:295B:TopEx:--------------------------------
P:295F:UpdSte2:store contents of A in block object state
P:2962:BouncingBlockHandler1:-------------------------------------------------------------------------------------
P:2965:BlockObjectsCore:get state of block object
P:2967::if not set, branch to leave
P:2969::mask out high nybble
P:296B::push to stack
P:296C::put in Y for now
P:296F::add 9 bytes to offset (note two block objects are created
P:2971::when using brick chunks, but only one offset for both)
P:2972::decrement Y to check for solid block state
P:2973::branch if found, otherwise continue for brick chunks
P:2975::set offset for maximum speed
P:2977::set movement amount here
P:297B::get maximum speed
P:297E::set maximum speed here
P:2980::set value to move downwards
P:2982::jump to the code that actually moves it
P:2985::do another sub to move horizontally
P:2989::move onto next block object
P:298D::set offset for maximum speed
P:298F::set movement amount here
P:2993::get maximum speed
P:2996::set maximum speed here
P:2998::set value to move downwards
P:299A::jump to the code that actually moves it
P:299D::do another sub to move horizontally
P:29A0::get block object offset used for both
P:29A5:sacrificaopapu2
P:29A6:sacrificaopapu:get coordinates of one block object
P:29A8::relative to the screen
P:29AA::store value to add to A here
P:29AD::add A to value stored
P:29AF::use as enemy offset
P:29B0::load vertical coordinate low
P:29B2::store here
P:29B5::load horizontal coordinate
P:29B7::subtract left edge coordinate
P:29BB::store result here
P:29BE::reload old object offset and leave
P:29C0::adjust offset for other block object if any
P:29C4::adjust other and get coordinates for other one
P:29C5::store value to add to A here
P:29C8::add A to value stored
P:29CA::use as enemy offset
P:29CB::load vertical coordinate low
P:29CD::store here
P:29D0::load horizontal coordinate
P:29D2::subtract left edge coordinate
P:29D6::store result here
P:29D9::reload old object offset and leave
P:29E1::add contents of X to A to get
P:29E2::appropriate offset, then give back to X
P:29E5::save offscreen bits offset to stack for now
P:29E7::do subroutine here
P:29EE::store here
P:29F7::mask together with previously saved low nybble
P:29F9::store both here
P:29FB::get offscreen bits offset from stack
P:29FD::get value here and store elsewhere
P:2A04::set palette bits here
P:2A08::set tile number for ball (something residual, likely)
P:2A0C::if end-of-level routine running,
P:2A0E::use palette and tile number assigned
P:2A10::otherwise set different palette bits
P:2A14::and set tile number for brick chunks
P:2A16:DChunks:get OAM data offset
P:2A19::increment to start with tile bytes in OAM
P:2A1A::into second row sprites
P:2A20::and into first row sprites
P:2A23::and dump into tile number part of sprite data
P:2A26::get frame counter
P:2A2C::get what was originally d3-d2 of low nybble
P:2A2E::add palette bits
P:2A30::increment offset for attribute bytes
P:2A31::into second row sprites
P:2A37::and into first row sprites
P:2A3A::and dump into tile number part of sprite data
P:2A3E::decrement offset to Y coordinate
P:2A3F::get first block object's relative vertical coordinate
P:2A42::and into first row sprites
P:2A45::and dump into tile number part of sprite data
P:2A48::get first block object's relative horizontal coordinate
P:2A4B::save into X coordinate of first sprite
P:2A4E::get original horizontal coordinate
P:2A52::subtract coordinate of left side from original coordinate
P:2A55::store result as relative horizontal coordinate of original
P:2A58::get difference of relative positions of original - current
P:2A5B::add original relative position to result
P:2A5D::plus 6 pixels to position second brick chunk correctly
P:2A5F::save into X coordinate of second sprite
P:2A62::get second block object's relative vertical coordinate
P:2A68::dump into Y coordinates of third and fourth sprites
P:2A6B::get second block object's relative horizontal coordinate
P:2A6E::save into X coordinate of third sprite
P:2A71::use original relative horizontal position
P:2A74::get difference of relative positions of original - current
P:2A77::add original relative position to result
P:2A79::plus 6 pixels to position fourth brick chunk correctly
P:2A7B::save into X coordinate of fourth sprite
P:2A7E::get offscreen bits for block object
P:2A81::check to see if d3 in offscreen bits are set
P:2A83::if not set, branch, otherwise move sprites offscreen
P:2A85::move offscreen two OAMs
P:2A87::on the left side (or two rows of enemy on either side
P:2A8A::if branched here from enemy graphics handler)
P:2A8D::get offscreen bits again
P:2A90::shift d7 into carry
P:2A91::if d7 not set, branch to last part
P:2A95::and into first row sprites
P:2A98::and do sub to dump into first and second sprites
P:2A9B:ChnkOfs:if relative position on left side of screen,
P:2A9D::go ahead and leave
P:2A9F::otherwise compare left-side X coordinate
P:2AA2::to right-side X coordinate
P:2AA5::branch to leave if less
P:2AA7::otherwise move right half of sprites offscreen
P:2AAF:ExBCDr:get lower nybble of saved state
P:2AB0::check vertical high byte of block object
P:2AB4::store contents of A in block object state
P:2AB7::otherwise save state back into stack
P:2ABA::check to see if bottom block object went
P:2ABC::to the bottom of the screen, and branch if not
P:2ABE::otherwise set offscreen coordinate
P:2AC0:ChkTop:get top block object's vertical coordinate
P:2AC2::see if it went to the bottom of the screen
P:2AC4::pull block object state from stack
P:2AC7::store contents of A in block object state
P:2ACD:BouncingBlockHandler:set offset for maximum speed
P:2ACF::set movement amount here
P:2AD3::get maximum speed
P:2AD6::set maximum speed here
P:2AD8::set value to move downwards
P:2ADA::jump to the code that actually moves it
P:2ADD::get block object offset
P:2ADF::get coordinates of one block object
P:2AE1::relative to the screen
P:2AE3::store value to add to A here
P:2AE6::add A to value stored
P:2AE8::use as enemy offset
P:2AE9::load vertical coordinate low
P:2AEB::store here
P:2AEE::load horizontal coordinate
P:2AF0::subtract left edge coordinate
P:2AF4::store result here
P:2AF7::reload old object offset and leave
P:2AF9::adjust offset for other block object if any
P:2AFD::adjust other and get coordinates for other one
P:2AFE::store value to add to A here
P:2B01::add A to value stored
P:2B03::use as enemy offset
P:2B04::load vertical coordinate low
P:2B06::store here
P:2B09::load horizontal coordinate
P:2B0B::subtract left edge coordinate
P:2B0F::store result here
P:2B12::reload old object offset and leave
P:2B1A::add contents of X to A to get
P:2B1B::appropriate offset, then give back to X
P:2B1E::save offscreen bits offset to stack for now
P:2B20::do subroutine here
P:2B27::store here
P:2B30::mask together with previously saved low nybble
P:2B32::store both here
P:2B34::get offscreen bits offset from stack
P:2B36::get value here and store elsewhere
P:2B3D::draw the block
P:2B40::get vertical coordinate
P:2B42::mask out high nybble
P:2B44::check to see if low nybble wrapped around
P:2B46::pull state from stack
P:2B47::if still above amount, not time to kill block yet, thus branch
P:2B4B::otherwise set flag to replace metatile
P:2B4E:KillBlock:if branched here, nullify object state
P:2B50:UpdSte:store contents of A in block object state
P:2B53:BlockObjMT_Updater:-------------------------------------------------------------------------------------\n$02 - used to store offset to block buffer\n$06-$07 - used to store block buffer address\nset offset to start with second block object
P:2B55:UpdateLoop:set offset here
P:2B57::if vram buffer already being used here,
P:2B5C::branch to move onto next block object
P:2B5E::if flag for block object already clear,
P:2B61::branch to move onto next block object
P:2B63::get low byte of block buffer
P:2B66::store into block buffer address
P:2B6B::set high byte of block buffer address
P:2B6D::get original vertical coordinate of block object
P:2B70::store here and use as offset to block buffer
P:2B73::get metatile to be written
P:2B76::write it to the block buffer
P:2B78::do sub to replace metatile where block object is
P:2B7B::ldy temp8
P:2B83::clear block object flag
P:2B86:NextBUpd:decrement block object offset
P:2B87::set offset here
P:2B89::if vram buffer already being used here,
P:2B90::if flag for block object already clear,
P:2B93::branch to move onto next block object
P:2B95::get low byte of block buffer
P:2B98::store into block buffer address
P:2B9D::set high byte of block buffer address
P:2B9F::get original vertical coordinate of block object
P:2BA2::store here and use as offset to block buffer
P:2BA5::get metatile to be written
P:2BA8::write it to the block buffer
P:2BAA::do sub to replace metatile where block object is
P:2BAD::ldy temp8
P:2BB5::clear block object flag
P:2BB8::then leave
P:2BB9:MovePlatformDown:-------------------------------------------------------------------------------------\n$00 - used to store high nybble of horizontal speed as adder\n$01 - used to store low nybble of horizontal speed\n$02 - used to store adder to page location\nsave value to stack (if branching here, execute next
P:2BBB::part as BIT instruction)
P:2BBC:MovePlatformUp:save value to stack
P:2BBF::get enemy object identifier
P:2BC1::increment offset for enemy object
P:2BC2::load default value here
P:2BC4::this code, thus unconditional branch here
P:2BC6:SetDplSpd:save downward movement amount here
P:2BC8::save upward movement amount here
P:2BCC::save maximum vertical speed here
P:2BD0::get value from stack
P:2BD1::use as Y, then move onto code shared by red koopa
P:2BD2:RedPTroopaGrav:do a sub to move object gradually
P:2BD5::get enemy object offset and leave
P:2BD8:MoveDropPlatform:set movement amount for drop platform
P:2BDA::skip ahead of other value set here
P:2BDC:MoveEnemySlowVert:set movement amount for bowser/other objects
P:2BDE:SetMdMax:set maximum speed in A
P:2BE0::unconditional branch
P:2BE2:MoveJ_EnemyVertically:--------------------------------\nset movement amount for podoboo/other objects
P:2BE4:SetHiMax:set maximum speed in A
P:2BE6:SetXMoveAmt:set movement amount here
P:2BE8::increment X for enemy offset
P:2BE9::set maximum speed here
P:2BEB::set value to move downwards
P:2BED::jump to the code that actually moves it
P:2BF0::get enemy object buffer offset and leave
P:2BF2:HE
P:2BF3:MoveRedPTroopaDown:--------------------------------\n--------------------------------\nset Y to move downwards
P:2BF5::skip to movement routine
P:2BF7:MoveRedPTroopaUp:set Y to move upwards
P:2BF9:MoveRedPTroopa:increment X for enemy offset
P:2BFC::set downward movement amount here
P:2C00::set upward movement amount here
P:2C04::set maximum speed here
P:2C06::set movement direction in A, and
P:2C07::jump to move this thing
P:2C09:MoveD_EnemyVertically:--------------------------------\n-------------------------------------------------------------------------------------\n$00 - used to store high nybble of horizontal speed as adder\n$01 - used to store low nybble of horizontal speed\n$02 - used to store adder to page location\n--------------------------------\nset quick movement amount downwards
P:2C0B::then check enemy state
P:2C0D::if not set to unique state for spiny's egg, go ahead
P:2C0F::and use, otherwise set different movement amount, continue on
P:2C11:MoveFallingPlatform:set movement amount
P:2C13:ContVMove:jump to skip the rest of this
P:2C16:MoveObjectHorizontally1:get currently saved value (horizontal
P:2C1C::store result here
P:2C1E::get saved value again
P:2C24::if < 8, branch, do not change
P:2C28::otherwise alter high nybble
P:2C2A:SaveXSp1:save result here
P:2C2C::load default Y value here
P:2C2E::if result positive, leave Y alone
P:2C32::otherwise decrement Y
P:2C33:UseAdde1:save Y here
P:2C35::get whatever number's here
P:2C39::add low nybble moved to high
P:2C3B::store result here
P:2C3E::init A
P:2C40::rotate carry into d0
P:2C41::push onto stack
P:2C42::rotate d0 back onto carry
P:2C45::add carry plus saved value (high nybble moved to low
P:2C47::ldy FramesMissed\n beq +\n adc $00\nplus $f0 if necessary) to object's horizontal position
P:2C4B::add carry plus other saved value to the
P:2C4D::object's page location and save
P:2C50::pull old carry from stack and add
P:2C51::to high nybble moved to low
P:2C53:ExXMove1
P:2C55::and leave
P:2C56:MovePlayerHorizontally:if jumpspring currently animating,
P:2C59::branch to leave
P:2C5B::otherwise set zero for offset to use player's stuff
P:2C5C:MoveObjectHorizontally:get currently saved value (horizontal
P:2C62::store result here
P:2C64::get saved value again
P:2C6A::if < 8, branch, do not change
P:2C6E::otherwise alter high nybble
P:2C70:SaveXSpd:save result here
P:2C72::ldy FramesMissed\nbeq +\nclc\nadc $00\nsta $00\nload default Y value here
P:2C74::if result positive, leave Y alone
P:2C78::otherwise decrement Y
P:2C79:UseAdder:save Y here
P:2C7B::get whatever number's here
P:2C7F::add low nybble moved to high
P:2C81::store result here
P:2C84::init A
P:2C86::rotate carry into d0
P:2C87::push onto stack
P:2C88::rotate d0 back onto carry
P:2C8B::add carry plus saved value (high nybble moved to low
P:2C8D::plus $f0 if necessary) to object's horizontal position
P:2C91::add carry plus other saved value to the
P:2C93::object's page location and save
P:2C97::ldy FramesMissed\nbeq +\nto high nybble moved to low
P:2C99:ExXMove:and leave
P:2C9A:BounceJS:-------------------------------------------------------------------------------------\n$00 - used for downward force\n$01 - used for upward force\n$02 - used for maximum vertical speed\n    .db $08, $10, $08, $00\n      jsr GetEnemyOffscreenBits   ;get offscreen information\n     lda TimerControl            ;check master timer control\n   bne DrawJSpr                ;branch to last section if set\n  lda JumpspringAnimCtrl      ;check jumpspring frame control\n; ;   beq DrawJSpr                ;branch to last section if not set\n tay\n   dey                         ;subtract one from frame control,\ntya                         ;the only way a poor nmos 6502 can\n and #%00000010              ;mask out all but d1, original value still in Y\nbne DownJSpr                ;if set, branch to move player up\ninc Player_Y_Position\n  inc Player_Y_Position       ;move player's vertical position down two pixels\n  jmp PosJSpr                 ;skip to next part\n  dec Player_Y_Position       ;move player's vertical position up two pixels\n  dec Player_Y_Position\n  lda Jumpspring_FixedYPos,x  ;get permanent vertical position\n  clc\n  adc Jumpspring_Y_PosData,y  ;add value using frame control as offset\n  sta Enemy_Y_Position,x      ;store as new vertical position\n  cpy #$01                    ;check frame control offset (second frame is $00)\n  bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part\n  lda A_B_Buttons\n  and #A_Button               ;check saved controller bits for A button press\n  beq BounceJS                ;skip to next part if A not pressed\n  and PreviousA_B_Buttons     ;check for A button pressed in previous frame\n  bne BounceJS                ;skip to next part if so\n  lda #$f4\n  sta JumpspringForce         ;otherwise write new jumpspring force here\n  cpy #$03                    ;check frame control offset again\n  bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)\n  lda JumpspringForce\n  sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed\n  if JUMPSPRING_FIX == 1\n      lda #$40                ;PAL bugfix: Define vertical acceleration on springs (was undefined on NTSC)\n      sta VerticalForce\n  endif\n  lda #$00\n  sta JumpspringAnimCtrl      ;initialize jumpspring frame control\n  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates\n  jsr EnemyGfxHandler         ;draw jumpspring\n  jsr OffscreenBoundsCheck    ;check to see if we need to kill it\n  lda JumpspringAnimCtrl      ;if frame control at zero, don't bother\n  beq ExJSpring               ;trying to animate it, just leave\n  lda JumpspringTimer\n  bne ExJSpring               ;if jumpspring timer not expired yet, leave\n  lda #$04\n  sta JumpspringTimer         ;otherwise initialize jumpspring timer\n  inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring\nExJSpring: rts                         ;leave\npush value to stack
P:2C9A:DownJSpr
P:2C9A:DrawJSpr
P:2C9A:ImposeGravity
P:2C9A:JumpspringHandler
P:2C9A:Jumpspring_Y_PosData
P:2C9A:PosJSpr
P:2C9E::add value in movement force to contents of dummy variable
P:2CA5::set Y to zero by default
P:2CA7::get current vertical speed
P:2CA9::if currently moving downwards, do not decrement Y
P:2CAB::otherwise decrement Y
P:2CAC:AlterYP:store Y here
P:2CAE::add vertical position to vertical speed plus carry
P:2CB0::ldy FramesMissed\n  beq +\n  adc SprObject_Y_Speed,x\nstore as new vertical position
P:2CB4::add carry plus contents of $07 to vertical high byte
P:2CB6::store as new vertical high byte
P:2CBC::add downward movement amount to contents of $0433
P:2CC1::add carry to vertical speed and store
P:2CC7::compare to maximum speed
P:2CC9::if less than preset value, skip this part
P:2CD2::keep vertical speed within maximum value
P:2CD6::clear fractional
P:2CD9:ChkUpM:get value from stack
P:2CDA::if set to zero, branch to leave
P:2CDE::otherwise get two's compliment of maximum speed
P:2CE2::store two's compliment here
P:2CE7::subtract upward movement amount from contents
P:2CE8::of movement force, note that $01 is twice as large as $00,
P:2CEA::thus it effectively undoes add we did earlier
P:2CEF::subtract borrow from vertical speed and store
P:2CF3::compare vertical speed to two's compliment
P:2CF5::if less negatively than preset maximum, skip this part
P:2CFA::and if so, branch to leave
P:2CFE::keep vertical speed within maximum value
P:2D02::clear fractional
P:2D05:ExVMove:leave!
P:2D06:MaxSpdBlockData
P:2D08:ImposeGravityBlock:set offset for maximum speed
P:2D0A::set movement amount here
P:2D0E::get maximum speed
P:2D11:ImposeGravitySprObj:set maximum speed here
P:2D13::set value to move downwards
P:2D15::jump to the code that actually moves it
P:2D18:UpdateLives:--------------------------------\n DPCM data must be at $C000 or later, aligned to 64 byte boundry\ninclude code\sound\shmup_dpcm.asm\nincbin code\sound\vyu.dmc
P:2D1D::otherwise, check number of lives
P:2D20::iny\ntya\nmore than 9 lives?
P:2D24::if so, subtract 10 and add one to the 10s digit
P:2D26::instead of showing 100 lives, A0 will show, etc.
P:2D2F::if so, subtract 10 and add to the digit
P:2D31::next to the difference
P:2D37:PutLives2
P:2D3F:RunOffscrBitsSubs:do subroutine here
P:2D46::store here
P:2D4B:RelativePlayerPosition:set offsets for relative cooordinates
P:2D4D::routine to correspond to player object
P:2D4F::load vertical coordinate low
P:2D51::store here
P:2D54::load horizontal coordinate
P:2D56::subtract left edge coordinate
P:2D5A::store result here
P:2D60:RelativeFireballPosition:set for fireball offsets
P:2D62::move offset to A
P:2D64::add amount of bytes to offset depending on setting in Y
P:2D67::put back in X and leave
P:2D6A:RelWOfs:load vertical coordinate low
P:2D6C::store here
P:2D6F::load horizontal coordinate
P:2D71::subtract left edge coordinate
P:2D75::store result here
P:2D78::return original offset
P:2D7A::leave
P:2D7B:SetOffscrBitsOffset:leave
P:2D7D::add contents of X to A to get
P:2D7E::appropriate offset, then give back to X
P:2D81:GetOffScreenBitsSet:save offscreen bits offset to stack for now
P:2D83::do subroutine here
P:2D8A::store here
P:2D93::mask together with previously saved low nybble
P:2D95::store both here
P:2D97::get offscreen bits offset from stack
P:2D99::get value here and store elsewhere
P:2DA1:ObjOffsetData
P:2DA4:PlayerGfxTblOffsets
P:2DB4:PowerUpGfxTable:regular mushroom
P:2DB8::fire flower
P:2DBC::star
P:2DC0::1-up mushroom
P:2DC4:PowerUpAttributes:.db $d6, $d6, $d9, $d9 ;hammer suit
P:2DC9:Player_DifferenceUD:--------------------------------\n-------------------------------------------------------------------------------------\n$00-$01 - tile numbers\n$02 - Y coordinate\n$03 - flip control\n$04 - sprite attributes\n$05 - X coordinate
P:2DCB:MoveUpsideDownPiranhaP:check enemy state
P:2DCD::if set at all, branch to leave
P:2DCF::check enemy's timer here
P:2DD2::branch to end if not yet expired
P:2DD4::check movement flag
P:2DD6::if moving, skip to part ahead
P:2DD8::if currently rising, branch 
P:2DDA::to move enemy upwards out of pipe
P:2DDC::get distance between enemy object's
P:2DDE::horizontal coordinate and the player's
P:2DDF::horizontal coordinate
P:2DE1::and store here
P:2DE5::subtract borrow, then leave
P:2DE7::piranha plant, and branch if enemy to right of player
P:2DE9::otherwise get saved horizontal difference
P:2DED::and change to two's compliment
P:2DF0::save as new horizontal difference
P:2DF2:ChkPlayerNearPipe1
P:2E00::get saved horizontal difference
P:2E05::if player within a certain distance, branch to leave
P:2E07:ReverseUPlantSpeed:get vertical speed
P:2E0B::change to two's compliment
P:2E0E::save as new vertical speed
P:2E10::increment to set movement flag
P:2E12:SetupToMoveUDPPlant:get original vertical coordinate (lowest point)
P:2E15::get vertical speed
P:2E17::branch if moving downwards
P:2E19::otherwise get other vertical coordinate (highest point)
P:2E1C:RiseFallUDPiranhaPlant:save vertical coordinate here
P:2E29::get frame counter
P:2E2C::branch to leave if d0 set (execute code every other frame)
P:2E2E::get master timer control
P:2E31::branch to leave if set (likely not necessary)
P:2E33::get current vertical coordinate
P:2E36::add vertical speed to move up or down
P:2E38::save as new vertical coordinate
P:2E3A::compare against low or high coordinate
P:2E3C::branch to leave if not yet reached
P:2E40::otherwise clear movement flag
P:2E44::set timer to delay piranha plant movement
P:2E47:ExMoveUDPP
P:2E48:PlayerNamesOffset
P:2E4A:MarioName
P:2E4A:PlayerNames
P:2E4F:LuigiName
P:2E54:XOffscreenBitsData
P:2E64:DefaultXOnscreenOfs
P:2E67:GetXOffscreenBits:save position in buffer to here
P:2E69::start with right side of screen
P:2E6B:XOfsLoop:get pixel coordinate of edge
P:2E6E::get difference between pixel coordinate of edge
P:2E6F::and pixel coordinate of object position
P:2E71::store here
P:2E73::get page location of edge
P:2E76::subtract from page location of object position
P:2E78::load offset value here
P:2E7D::if beyond right edge or in front of left edge, branch
P:2E7F::if not, load alternate offset value here
P:2E84::if one page or more to the left of either edge, branch
P:2E86::if no branching, load value here and store
P:2E8A::load some other value and execute subroutine
P:2E8C::store current value in A here
P:2E8E::get pixel difference
P:2E90::compare to preset value
P:2E92::if pixel difference >= preset value, branch
P:2E94::divide by eight
P:2E97::mask out all but 3 LSB
P:2E99::right side of the screen or top?
P:2E9B::if so, branch, use difference / 8 as offset
P:2E9D::if not, add value to difference / 8
P:2E9F:SetOscrO:use as offset
P:2EA0:ExDivPD:get bits here
P:2EA0:XLdBData
P:2EA3::reobtain position in buffer
P:2EA5::if bits not zero, branch to leave
P:2EA9::otherwise, do left side of screen now
P:2EAA::branch if not already done with left side
P:2EAC:ExXOfsBS
P:2EAD:YOffscreenBitsData
P:2EB6:DefaultYOnscreenOfs
P:2EB9:HighPosUnitData
P:2EBB:GetYOffscreenBits:save position in buffer to here
P:2EBD::start with top of screen
P:2EBF:YOfsLoop:load coordinate for edge of vertical unit
P:2EC3::subtract from vertical coordinate of object
P:2EC5::store here
P:2EC7::subtract one from vertical high byte of object
P:2ECB::load offset value here
P:2ED0::if under top of the screen or beyond bottom, branch
P:2ED2::if not, load alternate offset value here
P:2ED7::if one vertical unit or more above the screen, branch
P:2ED9::if no branching, load value here and store
P:2EDD::load some other value and execute subroutine
P:2EDF::store current value in A here
P:2EE1::get pixel difference
P:2EE3::compare to preset value
P:2EE5::if pixel difference >= preset value, branch
P:2EE7::divide by eight
P:2EEA::mask out all but 3 LSB
P:2EEC::right side of the screen or top?
P:2EEE::if so, branch, use difference / 8 as offset
P:2EF0::if not, add value to difference / 8
P:2EF2:SetOscrO1:use as offset
P:2EF3:ExDivPD1:get offscreen data bits using offset
P:2EF3:YLdBData
P:2EF6::reobtain position in buffer
P:2EFA::if bits not zero, branch to leave
P:2EFC::otherwise, do bottom of the screen now
P:2EFF:ExYOfsBS
P:2F00:RelativeEnemyPosition:get coordinates of enemy object 
P:2F02::relative to the screen
P:2F04::store value to add to A here
P:2F07::add A to value stored
P:2F09::use as enemy offset
P:2F0A::load vertical coordinate low
P:2F0C::store here
P:2F0F::load horizontal coordinate
P:2F11::subtract left edge coordinate
P:2F15::store result here
P:2F18::reload old object offset and leave
P:2F1B:ShrinkPlayer:add ten bytes to frame control as offset
P:2F1D::this thing apparently uses two of the swimming frames
P:2F1F::to draw the player shrinking
P:2F20::load offset for small player swimming
P:2F22::get what would normally be offset adder
P:2F25::and branch to use offset if nonzero
P:2F27::otherwise load offset for big player swimming
P:2F29:ShrPlF:get offset to graphics table based on offset loaded
P:2F2C::and leave
P:2F2D:ChkForPlayerAttrib:get sprite data offset
P:2F32::if executing specific game engine routine,
P:2F34::branch to change third and fourth row OAM attributes
P:2F36::get graphics table offset
P:2F3B::if crouch offset, either standing offset,
P:2F3D::or intermediate growing offset,
P:2F3F::go ahead and execute code to change 
P:2F41::fourth row OAM attributes only
P:2F47::if none of these, branch to leave
P:2F49:KilledAtt
P:2F4C::mask out horizontal and vertical flip bits
P:2F4E::for third row sprites and save
P:2F56::set horizontal flip bit for second
P:2F58::sprite in the third row
P:2F5B:C_S_IGAtt
P:2F5E::mask out horizontal and vertical flip bits
P:2F60::for fourth row sprites and save
P:2F68::set horizontal flip bit for second
P:2F6A::sprite in the fourth row
P:2F6D:ExPlyrAt:leave
P:2F6E:ShrinkPlayer2
P:2F71:HandleChangeSize:get animation frame control
P:2F76::get frame counter and execute this code every
P:2F78::fourth frame, otherwise branch ahead
P:2F7A::increment frame control
P:2F7B::check for preset upper extent
P:2F7D::if not there yet, skip ahead to use
P:2F7F::otherwise initialize both grow/shrink flag
P:2F81::and animation frame control
P:2F84:CSzNext:store proper frame control
P:2F87:GorSLog
P:2F92::get player's size
P:2F95::if player small, skip ahead to next part
P:2F97::get offset adder based on frame control as offset
P:2F9A::load offset for player growing
P:2F9C:GetOffsetFromAnimCtrl:multiply animation frame control
P:2F9D::by eight to get proper amount
P:2F9E::to add to our offset
P:2F9F::add to offset to graphics table
P:2FA2::and return with result in A
P:2FA3:ProcessPlayerAction:get player's state
P:2FA7::if climbing, branch here
P:2FAB::if falling, branch here
P:2FAF::if not jumping, branch here
P:2FB4::if swimming flag set, branch elsewhere
P:2FB6::load offset for crouching
P:2FB8::get crouching flag
P:2FBB::if set, branch to get offset for graphics table
P:2FBD::otherwise load offset for jumping
P:2FBF::go to get offset to graphics table
P:2FC2:ProcOnGroundActs:load offset for crouching
P:2FC4::get crouching flag
P:2FC7::if set, branch to get offset for graphics table
P:2FC9::load offset for standing
P:2FCB::check player's horizontal speed
P:2FCD::and left/right controller bits
P:2FD2::if no speed or buttons pressed, use standing offset
P:2FD4::load walking/running speed
P:2FD9::if less than a certain amount, branch, too slow to skid
P:2FDB::otherwise check to see if moving direction
P:2FDD::and facing direction are the same
P:2FDF::if moving direction = facing direction, branch, don't skid
P:2FE7::if running the change size, fire flower, injure
P:2FE9::or death game engine subroutines, skip this
P:2FEB::otherwise play skid sound
P:2FEF:NoSkidS:increment to skid offset ($03)
P:2FF0:NonAnimatedActs:load offset for crouching\nget crouching flag\nif set, branch to get offset for graphics table\nload offset for standing\ncheck player's horizontal speed\nand left/right controller bits\nif no speed or buttons pressed, use standing offset\nload walking/running speed\nif less than a certain amount, branch, too slow to skid\notherwise check to see if moving direction\nand facing direction are the same\nif moving direction = facing direction, branch, don't skid\notherwise increment to skid offset ($03)\ndo a sub here to get offset adder for graphics table
P:2FF5::initialize animation frame control
P:2FF8::load offset to graphics table using size as offset
P:2FFC:ActionFalling:load offset for walking/running
P:2FFE::get offset to graphics table
P:3001::execute instructions for falling state
P:3004:ActionWalkRun:load offset for walking/running
P:3006::get offset to graphics table
P:3009::execute instructions for normal state
P:300C:ActionClimbing:load offset for climbing
P:300E::check player's vertical speed
P:3010::if no speed, branch, use offset as-is
P:3012::otherwise get offset for graphics table
P:3015::then skip ahead to more code
P:3018:ActionSwimming:load offset for swimming
P:301D::check jump/swim timer
P:3020::and animation frame control
P:3023::if any one of these set, branch ahead
P:3027::branch to same place if A button pressed
P:3029:GetCurrentAnimOffset:get animation frame control
P:302C::jump to get proper offset to graphics table
P:302F:FourFrameExtent:load upper extent for frame control
P:3031::jump to get offset and animate player object
P:3034:ThreeFrameExtent:load upper extent for frame control for climbing
P:3036:AnimationControl:store upper extent here
P:3038::get proper offset to graphics table
P:303B::save offset to stack
P:303C::load animation frame timer
P:303F::branch if not expired
P:3041::get animation frame timer amount
P:3044::and set timer accordingly
P:304A::add one to animation frame control
P:304D::compare to upper extent
P:304F::if frame control + 1 < upper extent, use as next
P:3051::otherwise initialize frame control
P:3053:SetAnimC:store as new animation frame control
P:3056:ExAnimC:get offset to graphics table from stack and leave
P:3058:GetGfxOffsetAdder:get player's size
P:305B::if player big, use current offset as-is
P:305D::for big player
P:305E::otherwise add eight bytes to offset
P:305F::for small player
P:3062:SzOfs:go back
P:3063:GetEnemyOffscreenBits:-------------------------------------------------------------------------------------\n$00 - used in adding to get proper offset\nset A to add 1 byte in order to get enemy offset
P:3069:ChkLandedEnemyState:if enemy in normal state, branch back to jump here
P:3070::if in state used by spiny's egg
P:3074::then branch elsewhere
P:3077::if already in state used by koopas and buzzy beetles
P:3079::or in higher numbered state, branch to leave
P:307B::lda Enemy_State,x         ;load enemy state again (why?)\nif not in $02 state (used by koopas and buzzy beetles)
P:307F::then branch elsewhere
P:3082::load default timer here
P:3084::check enemy identifier for spiny
P:3088::branch if not found
P:308A::set timer for $00 if spiny
P:308C:SetForStn:set timer here
P:308F::set state here, apparently used to render
P:3091::upside-down koopas and buzzy beetles
P:3093::initialize vertical speed
P:3095::and movement force
P:30A5::do something here to vertical speed and something else
P:30AA::save high nybble of vertical coordinate, and
P:30AC::set d3, then store, probably used to set enemy object
P:30AE::neatly on whatever it's landing on
P:30B0:ExSteChk:then leave
P:30B1:DrawTitleScreen:are we in title screen mode?
P:30B6::if not, exit
P:30B9::put address $0300 into
P:30BB::the indirect at $00
P:30C9:OutputTScr
P:30D6:ChkHiByte:check high byte?
P:30D8::at $0400?
P:30DA::if not, loop back and do another
P:30DC::check if offset points past end of data (This is #$3a normally).
P:30DE::if not, loop back and do another
P:30E0::set buffer transfer control to $0300,
P:30E2::increment task and exit
P:30E5:titleScreenData:.incbin data\SMB Annoyance.nes, TitleScreenDataOffset + $8000 + $10, $13a      ; does not work\n.incbin data\SMB Annoyance.nes, $1ec0 + $8000 + $10, $13a                      ; does not work\n.incbin SMBAnnoyance.nes, $9ed0                                                ; works\n.incbin "SMB Annoyance.nes", $9ed0                                             ; works\n.incbin data\SMB Annoyance.nes, $9ed0                                          ; does not work\n.incbin SMBAnnoyance.nes, $1ec0 + $8000 + $10, $13a                            ; works\n.incbin SMBAnnoyance.nes, TitleScreenDataOffset + $8000 + $10, $13a            ; assembles, does not work\n.incbin "data\SMB Annoyance.nes", TitleScreenDataOffset + $8000 + $10, $13a    ; works\n.incbin "data/SMB Annoyance.nes", TitleScreenDataOffset + $8000 + $10, $13a    ; works\n.incbin data\SMB Annoyance.nes, $8000 + $10, $13a + TitleScreenDataOffset      ; does not work\n.incbin SMBAnnoyance.nes, $8000 + $10, $13a + TitleScreenDataOffset            ; does not work
P:320F::.db $20, $a6, $54, $26, $20, $c6, $54, $26, $20, $e6, $54, $26, $21, $06, $54, $26\n.db $20, $85, $01, $44, $20, $86, $54, $48, $20, $9a, $01, $49, $20, $a5, $c9, $46\n.db $20, $ba, $c9, $4a, $20, $a6, $0a, $d0, $d1, $d8, $d8, $de, $d1, $d0, $da, $de\n.db $d1, $20, $c6, $0a, $d2, $d3, $db, $db, $db, $d9, $db, $dc, $db, $df, $20, $e6\n.db $0a, $d4, $d5, $d4, $d9, $db, $e2, $d4, $da, $db, $e0, $21, $06, $0a, $d6, $d7\n.db $d6, $d7, $e1, $26, $d6, $dd, $e1, $e1, $21, $26, $14, $d0, $e8, $d1, $d0, $d1\n.db $de, $d1, $d8, $d0, $d1, $26, $de, $d1, $de, $d1, $d0, $d1, $d0, $d1, $26, $21\n.db $46, $14, $db, $42, $42, $db, $42, $db, $42, $db, $db, $42, $26, $db, $42, $db\n.db $42, $db, $42, $db, $42, $26, $21, $66, $46, $db, $21, $6c, $0e, $df, $db, $db\n.db $db, $26, $db, $df, $db, $df, $db, $db, $e4, $e5, $26, $21, $86, $14, $db, $db\n.db $db, $de, $43, $db, $e0, $db, $db, $db, $26, $db, $e3, $db, $e0, $db, $db, $e6\n.db $e3, $26, $21, $a6, $14, $db, $db, $db, $db, $42, $db, $db, $db, $d4, $d9, $26\n.db $db, $d9, $db, $db, $d4, $d9, $d4, $d9, $e7, $21, $c5, $16, $5f, $95, $95, $95\n.db $95, $95, $95, $95, $95, $97, $98, $78, $95, $96, $95, $95, $97, $98, $97, $98\n.db $95, $7a;, $21, $ed, $0e, $cf, $01, $09, $08, $05, $24, $17, $12, $17, $1d, $0e, $17, $0d, $18, 
P:322C::$22, $ec, $04, $1d, $18, $19, $28, $22, $f6, $01, $00, $23, $c9
P:322F::.db $56, $55, $23, $e2, $04, $99, $aa, $aa, $aa, $23, $ea, $04, $99, $aa, $aa, $aa\n.db $00, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff\n.db $21, $ed, $0e, $cf, $02, $00, $02, $01, $24, "ALEFUNKY"-55
P:3231:PauseRoutine:.db $22, $0a\n.db titleMessageEnd-titleMessageStart\ntitleMessageStart:\n.db "SCANLINE-TEST"-$37\ntitleMessageEnd:\nare we in victory mode?
P:3231:titleScreenDataEnd
P:3234::if so, go ahead
P:3238::are we in game mode?
P:323A::if not, leave
P:323C::if we are in game mode, are we running game engine?
P:3241::if not, leave
P:3257:ChkPauseTimer:lda debug			  ;check if debug mode is enabled		  \nbeq +				  ;skip the debug routine if not
P:325A::check if pause timer is still counting down
P:325F::if so, decrement and leave
P:3262:ExitPause1
P:3263:ChkStart:check to see if start is pressed
P:3266::on controller 1
P:3283::set pause timer
P:3289::is set to less than 4
P:329D:UnPause
P:32B4::lda Mirror_PPU_CTRL_REG2\neor #%01100000\nsta Mirror_PPU_CTRL_REG2\nsta PPU_CTRL_REG2
P:32CF::set pause timer
P:32D8::set pause sfx queue for next pause mode
P:32DB::invert d0 and set d7
P:32DF::unconditional branch
P:32E1:ClrPauseTimer:clear timer flag if timer is at zero and start button
P:32E4::is not pressed
P:32E6:SetPause
P:32E9:ExitPause
P:32EA:DebugModeRoutine:check to see if SELECT is pressed
P:32ED::on controller 1
P:32EF::if not don't bother checking more
P:32F8::check to see if UP is pressed
P:32FA::on controller 1
P:32FE::check to see if DOWN is pressed
P:3300::on controller 1
P:3304::check to see if B is pressed
P:3306::on controller 1
P:330A::check to see if A is pressed
P:330C::on controller 1
P:3310::lda #$01\nsta	TextboxID\nrts
P:331D::lda GameEngineSubroutine\ncmp #$08\nbne Ex
P:3324::check if timer setting is 0 to detect pipe intro
P:3329::decrement LevelNumber so we end up on the same level for next area
P:332C:Soweback
P:3331::increment level number
P:3337:SetRunOutMusic:lda #TimeRunningOutMusic\nsta EventMusicQueue     ;load time running out music\ninc HurryUp
P:3338:Inour:check to see if world end timer expired
P:333B::this doesnt do anything (fix?) 
P:3349:Ex
P:334A:Swam
P:334C:SetSwim
P:3350::sta DebugSwim				;also store here because collision routine sets swimming flag to zero every frame\ntay\nlda Swam,y\nsta VerticalForceDown
P:3351:ChangePower:load player powerup status
P:3354::if fiery, set to small
P:3358::otherwise increment
P:335B::load mario status
P:335E::store here to prevent size change animation when hit in fiery mario
P:3361::load again (to compare if zero)
P:3364::branch if small
P:3368::set size to big
P:336B::jump to change colors
P:336E:FiretoSmall
P:3370::set status to small
P:3376::set size to small
P:337B::jump to change colors
P:337E:GrabShelltest
P:33A1::check if mario is holding anything
P:33A4::if not, branch to exit
P:33AE::jump to grab routine
P:33B1:SpriteShuffler:sample start addresses LUT\nsample lengths LUT\n        lda \n        dpcm_sample_SD2ddx2002d909Snare\n        lda <dpcm_sample_SD2ddx2002d909Snare\n        lsr\n        lsr\n        lsr\n        lsr\n        lsr\n        lsr\n        sta $00\n        lda >dpcm_sample_SD2ddx2002d909Snare\n        asl\n        asl\n        clc\n        adc $00\n        sta $4012\n        lda #$8f\n        sta $4013\n        lda #$80\n        sta $4010\n        ldx #$00\n  ldx #$00\n  stx $2000\n  stx $2001\n  stx $4010\nSND_SQUARE1_REG       = $4000\nSND_SQUARE2_REG       = $4004\nSND_TRIANGLE_REG      = $4008\nSND_NOISE_REG         = $400c\nSND_DELTA_REG         = $4010\nSND_MASTERCTRL_REG    = $4015\n        ldx #$00                ;if end of sfx reached, clear buffer\n        stx Square1SoundBuffer  ;and stop making the sfx\n        ldx #$0e\n        stx SND_MASTERCTRL_REG\n        ldx #$0f\n        stx SND_MASTERCTRL_REG\n  lda #$fe\n  sta SND_MASTERCTRL_REG\n  lda #$ff\n  sta SND_MASTERCTRL_REG\nload sample number into X\nload pitch ($00-$0F) into Y\nload starting level ($00-$7F) into a temp variable\nDPCM disable\nY = pitch\ntemp = starting sample level\nX = sample number\nDPCM enable (plays sample)\n- jmp -\n-------------------------------------------------------------------------------------\n$00 - used for preset value\nldy AreaType               ;load level type, likely residual code\nlda #$28                    ;load preset value which will put it at\nsta $00                     ;sprite #10\nstart at the end of OAM data offsets
P:33B1:sndTest
P:33B3:ShuffleLoop:check for offset value against
P:33B6::the preset value
P:33B8::if less, skip this part
P:33BA::get current offset to preset value we want to add
P:33BE::get shuffle amount, add to current sprite offset
P:33C1::if not exceeded $ff, skip second add
P:33C4::otherwise add preset value $28 to offset
P:33C6:StrSprOffset:store new offset here or old one if branched to here
P:33C9:NextSprOffset:move backwards to next one
P:33CC::load offset
P:33D0::check if offset + 1 goes to 3
P:33D2::if offset + 1 not 3, store
P:33D4::otherwise, init to 0
P:33D6:SetAmtOffset
P:33D9::load offsets for values and storage
P:33DD:SetMiscOffset:load one of three OAM data offsets
P:33E0::store first one unmodified, but
P:33E3::add eight to the second and eight
P:33E4::more to the third one
P:33E6::note that due to the way X is set up,
P:33E9::this code loads into the misc sprite offsets
P:33F3::do this until all misc spr offsets are loaded
P:33F6:LandEnemyInitState2:-------------------------------------------------------------------------------------\nBitchTable:\n		.db $08, $09, $0a, $0b, $0c, $0d, $0e, $0f\n		.db $00, $01, $02, $03, $04, $05, $06, $07\nAnotherBitchTable:\n		.db $0f, $0e, $0d, $0c, $0b, $0a, $09, $08\n		.db $07, $06, $05, $04, $03, $02, $01, $00\nPutEnemyOnSlope:\n		lda Enemy_Y_Position,x\n		sec\n		sbc #$08\n		sta tempD\n		lda Enemy_X_Position,x\n		and #$0f\n		tay\n		lda BitchTable,y\n		sta tempC\n+:		lda tempD\n		and #$0f\n		tay\n		lda AnotherBitchTable,y\n		cmp tempC\n		beq ++\n		bcs +\n++:		lda tempD\n		clc\n		adc #$10\n		and #$f0\n		clc\n		adc #$08\n		sec\n		sbc tempC\n		sta Enemy_Y_Position,x\n		lda Enemy_State,x      \n        and #%01000000          ;branch if d6 in enemy state is set\n        bne LandEnemyInitState2\n        lda Enemy_State,x\n        asl                     ;branch if d7 in enemy state is not set\n        bcs +\n	    jsr ChkLandedEnemyState\n	    lda tempD\n		clc\n		adc #$10\n		and #$f0\n		clc\n		adc #$08\n		sec\n		sbc tempC\n		sta Enemy_Y_Position,x\n		lda #$01\n		.db $2c\n+:		lda #$00\n		sta EnemyOnSlope,x\n		rts
P:33F9:Chorizo:		sty tempD\n		lda Player_X_Position\n		and #$0f\n		tay\n		lda BitchTable,y\n		sta tempC\n		lda GroundedTimer\n		cmp #$08\n		bcc ++\n+:		lda Player_Y_Position\n		and #$0f\n		tay\n		lda AnotherBitchTable,y\n		sec\n		sbc tempC\n		bpl +\n++:		lda Player_Y_Position\n		clc \n		adc #$0f\n		adc tempD\n		and #$f0\n		sec\n		sbc tempC\n		sta Player_Y_Position\n		lda #$00\n		sta Player_State\n		lda #$ff\n		sta GroundedTimer\n		ldy Player_MovingDir\n		dey\n		beq +\n		lda #$01\n		sta Player_Y_Speed\n+:		inc GroundedTimer\nSlopeExit:		\n		rts
P:33F9:PutOnSlope
P:3406:Adio:jmp GoBack
P:3409:JmpToBreakblock
P:3410:JmpGetBlockCoin
P:3414:DoSide2
P:3456:NoPe2
P:3460::regular coin?
P:3465:NoPe3:blank metatile used for vines?
P:3479::regular coin?
P:34A5:Oetu2
P:34A9:Boi2
P:34AF:Webos
P:34B0::hidden coin block?
P:34D4:jod
P:350F:SolidMTileUpperExt
P:3513:PlayerKilled2
P:3516:DoChangeSize2
P:3519:FindPlayerAction2
P:351C:PlayerGfxHandler:if player's injured invincibility timer
P:351F::not set, skip checkpoint and continue code
P:3523::otherwise check frame counter and branch
P:3525::to leave on every other frame (when d0 is set)
P:3527:CntPl:if executing specific game engine routine,
P:3529::branch ahead to some other part
P:352D::if grow/shrink flag set
P:3530::then branch to some other code
P:3532::if swimming flag set, branch to
P:3535::different part, do not return
P:3539::cmp #$00                    ;if player status normal,\nbranch and do not return
P:353B::otherwise jump and return
P:3540::check frame counter for d2 set (8 frames every
P:3542::eighth frame), and branch if set to leave
P:3544::initialize X to zero
P:3545::get player sprite data offset
P:3548::get player's facing direction
P:354B::if player facing to the right, use current offset
P:354E::otherwise move to next OAM data
P:3551:SwimKT:check player's size
P:3554::if big, use first tile
P:3556::check tile number of seventh/eighth sprite
P:3559::against tile number in player graphics table
P:355C::if spr7/spr8 tile number = value, branch to leave
P:355E::otherwise increment X for second tile
P:355F:BigKTS:overwrite tile number in sprite 7/8
P:3562::to animate player's feet when swimming
P:3565:ExPGH:then leave
P:3566:DrawOneSprite
P:357A::add eight to the offset in Y to
P:357B::move to the next two sprites
P:3580:RenderPlayerSub:store number of rows of sprites to draw
P:3585::store player's relative horizontal position
P:3588::store it here also
P:358D::store player's vertical position
P:3591::store player's facing direction
P:3596::store player's sprite attributes
P:3598::load graphics table offset
P:359B::get player's sprite data offset
P:359E:DrawPlayerLoop:load player's left side
P:35A3::now load right side
P:35A9::decrement rows of sprites to draw
P:35AB::do this until all rows are drawn
P:35AD::        lda #$75                ; tile\n        sta $00\n        lda $02                 ; load stored y position\n        sec                     ; set carry bit\n        sbc #$20                ; subtract 32\n        sta $02                 ; store it again\n        lda #$00\n        sta $04                 ; attributes\n        jsr DrawOneSprite\n        lda $05                 ; load stored x position\n        clc                     ; clear carry bit\n        adc #$0b                ; add 12\n        sta $05                 ; store it again\n        jsr DrawOneSprite
P:35AE:PlayerKilled:load offset for player killed
P:35B0::get offset to graphics table
P:35B3:PlayerGfxProcessing:store offset to graphics table here
P:35B8::draw player based on offset loaded
P:35BB::set horizontal flip bits as necessary
P:35C1::if fireball throw timer not set, skip to the end
P:35C3::set value to initialize by default
P:35C5::get animation frame timer
P:35C8::compare to fireball throw timer
P:35CB::initialize fireball throw timer
P:35CE::if animation frame timer => fireball throw timer skip to end
P:35D0::otherwise store animation timer into fireball throw timer
P:35D3::load offset for throwing
P:35D5::get offset to graphics table
P:35D8::store it for use later
P:35DB::set to update four sprite rows by default
P:35DF::check for horizontal speed or left/right button press
P:35E1::if no speed or button press, branch using set value in Y
P:35E3::otherwise set to update only three sprite rows
P:35E4:SUpdR:save in A for use
P:35E5::in sub, draw player object again
P:35E8:PlayerOffscreenChk:get player's offscreen bits
P:35EC::move vertical bits to low nybble
P:35EF::store here
P:35F1::check all four rows of player sprites
P:35F3::get player's sprite data offset
P:35F7::add 24 bytes to start at bottom row
P:35F9::set as offset here
P:35FA:PROfsLoop:load offscreen Y coordinate just in case
P:35FC::shift bit into carry
P:35FE::if bit not set, skip, do not move sprites
P:3600::and into first row sprites
P:3603::and do sub to dump into first and second sprites
P:3606:NPROffscr
P:3607::subtract eight bytes to do
P:3608::next row up
P:360B::decrement row counter
P:360C::do this until all sprite rows are checked
P:360E::then we are done!
P:360F:PlayerCollisionCore:-------------------------------------------------------------------------------------\n$06 - second object's offset\n$07 - counter\ninitialize X to use player's bounding box for comparison
P:3611:SprObjectCollisionCore:save contents of Y here
P:3615::save value 1 here as counter, compare horizontal coordinates first
P:3617:CollisionCoreLoop:compare left/top coordinates
P:361A::of first and second objects' bounding boxes
P:361D::if first left/top => second, branch
P:361F::otherwise compare to right/bottom of second
P:3622::if first left/top < second right/bottom, branch elsewhere
P:3624::if somehow equal, collision, thus branch
P:3626::if somehow greater, check to see if bottom of
P:3629::first object's bounding box is greater than its top
P:362C::if somehow less, vertical wrap collision, thus branch
P:362E::otherwise compare bottom of first bounding box to the top
P:3631::of second box, and if equal or greater, collision, thus branch
P:3633::otherwise return with carry clear and Y = $0006
P:3635::note horizontal wrapping never occurs
P:3636:SecondBoxVerticalChk:check to see if the vertical bottom of the box
P:3639::is greater than the vertical top
P:363C::if somehow less, vertical wrap collision, thus branch
P:363E::otherwise compare horizontal right or vertical bottom
P:3641::of first box with horizontal left or vertical top of second box
P:3644::if equal or greater, collision, thus branch
P:3646::otherwise return with carry clear and Y = $0006
P:3649:FirstBoxGreater:compare first and second box horizontal left/vertical top again
P:364C::if first coordinate = second, collision, thus branch
P:364E::if not, compare with second object right or bottom edge
P:3651::if left/top of first less than or equal to right/bottom of second
P:3653::then collision, thus branch
P:3655::otherwise check to see if top of first box is greater than bottom
P:3658::if less than or equal, no collision, branch to end
P:365C::otherwise compare bottom of first to top of second
P:365F::if bottom of first is greater than top of second, vertical wrap
P:3662::collision, and branch, otherwise, proceed onwards here
P:3664:NoCollisionFound:clear carry, then load value set earlier, then leave
P:3665::like previous ones, if horizontal coordinates do not collide, we do
P:3667::not bother checking vertical ones, because what's the point?
P:3668:CollisionFound:increment offsets on both objects to check
P:3669::the vertical coordinates
P:366A::decrement counter to reflect this
P:366C::if counter not expired, branch to loop
P:366E::otherwise we already did both sets, therefore collision, so set carry
P:366F::load original value set here earlier, then leave
P:3672:BoundBoxCtrlData:-------------------------------------------------------------------------------------\n$00 - used to hold one of bitmasks, or offset\n$01 - used for relative X coordinate, also used to store middle screen page location\n$02 - used for relative Y coordinate, also used to store middle screen coordinate\nthis data added to relative coordinates of sprite objects\nstored in order: left edge, top edge, right edge, bottom edge\n00
P:3676::01
P:367A::02
P:367E::03
P:3682::04
P:3686::05
P:368A::06
P:368E::07
P:3692::08
P:3696::PAL diff: some enemies (Piranha, Bullet Bill, Goomba, Spiny, Blooper, Cheep Cheep) has larger hitbox
P:369A::09\n0a
P:369E::0b
P:36A2::0c
P:36A6::0d
P:36AA::0e
P:36AE::0f
P:36B2::10
P:36B6:GetFireballBoundBox:add seven bytes to offset
P:36B7::to use in routines as offset for fireball
P:36BB::set offset for relative coordinates
P:36BD::unconditional branch
P:36BF:GetMiscBoundBox:add nine bytes to offset
P:36C0::to use in routines as offset for misc object
P:36C4::set offset for relative coordinates
P:36C6:FBallB:get bounding box coordinates
P:36C9::jump to handle any offscreen coordinates
P:36CC:GetEnemyBoundBox:store bitmask here for now
P:36D0::store another bitmask here for now and jump
P:36D5:SmallPlatformBoundBox:store bitmask here for now
P:36D9::store another bitmask here for now
P:36DB:GetMaskedOffScrBits:get enemy object position relative
P:36DD::to the left side of the screen
P:36E1::store here
P:36E3::subtract borrow from current page location
P:36E5::of left side
P:36E8::if enemy object is beyond left edge, branch
P:36EC::if precisely at the left edge, branch
P:36EE::if to the right of left edge, use value in $00 for A
P:36F0:CMBits:otherwise use contents of Y
P:36F1::preserve bitwise whatever's in here
P:36F4::save masked offscreen bits here
P:36F7::if anything set here, branch
P:36F9::otherwise, do something else
P:36FC:LargePlatformBoundBox:increment X to get the proper offset
P:36FD::then jump directly to the sub for horizontal offscreen bits
P:3700::decrement to return to original offset
P:3701::if completely offscreen, branch to put entire bounding
P:3703::box offscreen, otherwise start getting coordinates
P:3705:SetupEOffsetFBBox
P:3706::load 1 as offset here, same reason
P:3708::save offset here
P:370A::store object coordinates relative to screen
P:370D::vertically and horizontally, respectively
P:3714::multiply offset by four and save to stack
P:3718::use as offset for Y, X is left alone
P:3719::load value here to be used as offset for X
P:371C::multiply that by four and use as X
P:371F::add the first number in the bounding box data to the
P:3721::relative horizontal coordinate using enemy object offset
P:3722::and store somewhere using same offset * 4
P:3725::store here
P:372B::add the third number in the bounding box data to the
P:372E::relative horizontal coordinate and store
P:3731::increment both offsets
P:3733::add the second number to the relative vertical coordinate
P:3735::using incremented offset and store using the other
P:3736::incremented offset
P:373F::add the fourth number to the relative vertical coordinate
P:3742::and store
P:3745::get original offset loaded into $00 * y from stack
P:3746::use as Y
P:3747::get original offset and use as X again
P:3749::jump to handle offscreen coordinates of bounding box
P:374C:MoveBoundBoxOffscreen:multiply offset by 4
P:374F::use as offset here
P:3752::load value into four locations here and leave
P:375F:BoundingBoxCore:save offset here
P:3761::store object coordinates relative to screen
P:3764::vertically and horizontally, respectively
P:376B::multiply offset by four and save to stack
P:376F::use as offset for Y, X is left alone
P:3770::load value here to be used as offset for X
P:3773::multiply that by four and use as X
P:3776::add the first number in the bounding box data to the
P:3778::relative horizontal coordinate using enemy object offset
P:3779::and store somewhere using same offset * 4
P:377C::store here
P:3782::add the third number in the bounding box data to the
P:3785::relative horizontal coordinate and store
P:3788::increment both offsets
P:378A::add the second number to the relative vertical coordinate
P:378C::using incremented offset and store using the other
P:378D::incremented offset
P:3796::add the fourth number to the relative vertical coordinate
P:3799::and store
P:379C::get original offset loaded into $00 * y from stack
P:379D::use as Y
P:379E::get original offset and use as X again
P:37A1:CheckRightScreenBBox:add 128 pixels to left side of screen
P:37A4::and store as horizontal coordinate of middle
P:37A9::add carry to page location of left side of screen
P:37AC::and store as page location of middle
P:37B0::get horizontal coordinate
P:37B2::compare against middle horizontal coordinate
P:37B4::get page location
P:37B6::subtract from middle page location
P:37B8::if object is on the left side of the screen, branch
P:37BA::check right-side edge of bounding box for offscreen
P:37BD::coordinates, branch if still on the screen
P:37BF::load offscreen value here to use on one or both horizontal sides
P:37C1::check left-side edge of bounding box for offscreen
P:37C4::coordinates, and branch if still on the screen
P:37C6::store offscreen value for left side
P:37C9:SORte:store offscreen value for right side
P:37CC:NoOfs:get object offset and leave
P:37CF:CheckLeftScreenBBox:check left-side edge of bounding box for offscreen
P:37D2::coordinates, and branch if still on the screen
P:37D4::check to see if left-side edge is in the middle of the
P:37D6::screen or really offscreen, and branch if still on
P:37DA::check right-side edge of bounding box for offscreen
P:37DD::coordinates, branch if still onscreen
P:37DF::store offscreen value for right side
P:37E2:SOLft:store offscreen value for left side
P:37E5:NoOfs2:get object offset and leave
P:37E8:_InitializeMemory:$06 - RAM address low\n$07 - RAM address high\nset initial high byte to $0700-$07ff
P:37EA::set initial low byte to start of page (at $00 of page)
P:37EE:InitPageLoop
P:37F0:InitByteLoop:check to see if we're on the stack ($0100-$01ff)
P:37F2::if not, go ahead anyway
P:37F4::otherwise, check to see if we're at $0160-$01ff
P:37F6::if so, skip write
P:37F8:InitByte:otherwise, initialize byte with current low byte in Y
P:37FA:SkipByte
P:37FB::do this until all bytes in page have been erased
P:37FF::go onto the next page
P:3800::do this until all pages of memory have been erased
P:3803:: set default chr banks
P:3804:SwimKickTileNum
P:3806:LakituDiffAdj
P:3809:HammerThrowTmrData
P:380B:XSpeedAdderData
P:380F:RevivedXSpeed
P:3813:SwimSpeed
P:3816:PlayerGraphicsTable:big player table\nwalking frame 1
P:381E::        frame 2
P:3826::        frame 3
P:382E::skidding
P:3836::jumping
P:383E::swimming frame 1
P:3846::         frame 2
P:384E::         frame 3
P:3856::climbing frame 1
P:385E::         frame 2
P:3866::crouching
P:386E::fireball throwing
P:3876::small player table\nwalking frame 1
P:387E::        frame 2
P:3886::        frame 3
P:388E::skidding
P:3896::jumping
P:389E::swimming frame 1
P:38A6::         frame 2
P:38AE::         frame 3
P:38B6::climbing frame 1
P:38BE::         frame 2
P:38C6::killed
P:38CE::used by both player sizes\nsmall player standing
P:38D6::intermediate grow frame
P:38DE::big player standing
P:38E6::crouching
P:38EE:FindPlayerAction:find proper offset to graphics table by player's actions
P:38F1::draw player, then process for fireball throwing
P:38F4:DoChangeSize:find proper offset to graphics table for grow/shrink
P:38F7::draw player, then process for fireball throwing
P:38FA:MetatileThingy:this table specifies the metatile id that each metatile acts like, for example, a metatile which acts like metatile id $54, acts like the ground, thus solid
P:39EC:DoWarpZone
P:39F1::load value of 4 for game text routine as default
P:39F3::warp zone (4-3-2), then check world number
P:39F8::if world number > 1, increment for next warp zone (5)
P:39FB::check area type
P:39FF::if ground area type, increment for last warp zone emanems
P:3A03::(8-7-6) and move on
P:3A04:WarpNum
P:3A05::store number here to be used by warp zone routine
P:3A08::print text and warp zone numbers
P:3A0D::load identifier for piranha plants and do sub
P:3A10:KillEnemies:store identifier here
P:3A14::check for identifier in enemy object buffer
P:3A16:KillELoop
P:3A18::if not found, branch
P:3A1C::if found, deactivate enemy object flag
P:3A1E:NoKillE:do this until all slots are checked
P:3A22:LoadBattery
P:3A31:SaveBattery
P:3A3D:FirebarPosLookupTbl
P:3AA0:FirebarMirrorData
P:3AA4:FirebarTblOffsets
P:3AB0:FirebarYPos
P:3AB2:BlockBufferAdderData
P:3AB5:BlockBuffer_X_Adder:00-07
P:3ABD::08-0f
P:3AC5::10-17
P:3ACD::18-1f
P:3ADC:BlockBuffer_Y_Adder
P:3B03:BlockBuffer_Y_Adder3
P:3B2A:jmpidk
P:3B46:QUe
P:3B53:ImpedePlayerMove
P:3B59::initialize value here
P:3B5B::get player's horizontal speed
P:3B5D::check value set earlier for
P:3B5F::left side collision
P:3B60::if right side collision, skip this part
P:3B62::return value to X
P:3B63::if player moving to the left,
P:3B65::branch to invert bit and leave
P:3B69::otherwise load A with value to be used later
P:3B6B::and jump to affect movement
P:3B6E:RImpd:return $02 to X
P:3B70::if player moving to the right
P:3B76::otherwise load A with value to be used here
P:3B78:NXSpd
P:3B7C::set timer of some sort
P:3B81::nullify player's horizontal speed
P:3B85::if value set in A not set to $ff,
P:3B87::branch ahead, do not decrement Y
P:3B89::otherwise decrement Y now
P:3B8A:PlatF:store Y as high bits of horizontal adder
P:3B90::add contents of A to player's horizontal
P:3B92::position to move player left or right
P:3B96::add high bits and carry to
P:3B98::page location if necessary
P:3BA2:ExIPM:invert contents of X
P:3BA5::mask out bit that was set here
P:3BA8::store to clear bit
P:3BB9:EXPM
P:3BBA:SixSpriteStacker:do six sprites
P:3BBC:StkLp:store X or Y coordinate into OAM data
P:3BC0::add eight pixels
P:3BC3::move offset four bytes forward
P:3BC6::do another sprite
P:3BC7::do this until all sprites are done
P:3BC9::get saved OAM data offset and leave
P:3BCC:MoveFlyingCheepCheep:PAL diff: reworked movement function for Cheep Cheeps\ncheck cheep-cheep's enemy state\nfor d5 set\nincrement offset for enemy offset\nposition object horizontally according to\ncounters, return with saved value in A,\ncheck cheep-cheep's enemy state
P:3BCE::for d5 set
P:3BD0::branch to continue code if not set
P:3BD4::otherwise clear sprite attributes
P:3BD7::and jump to move defeated cheep-cheep downwards
P:3BDA:FlyCC:increment offset for enemy offset                       ;increment offset for enemy offset
P:3BDB::position object horizontally according to
P:3BDE::ldx ObjectOffset            ;counters, return with saved value in A,\ncounters, return with saved value in A,
P:3BE0::set vertical movement amount
P:3BE2::set maximum speed
P:3BE4::branch to impose gravity on flying cheep-cheep
P:3BEA::get vertical movement force and
P:3BEB::move high nybble to low
P:3BEE::save as offset (note this tends to go into reach of code)
P:3BEF::get vertical position
P:3BF1::subtract pseudorandom value based on offset from position
P:3BF5::if result within top half of screen, skip this part
P:3BF9::otherwise get two's compliment
P:3BFC:AddCCF:if result or two's compliment greater than eight,
P:3BFE::skip to the end without changing movement force
P:3C04::otherwise add to it
P:3C09::move high nybble to low again
P:3C0E:BPGet:load bg priority data and store (this is very likely
P:3C11::broken or residual code, value is overwritten before
P:3C14::drawing it next frame), then leave
P:3C15:BlockBufferAdderData1
P:3C18:BlockBuffer_X_Adder1:00-07
P:3C20::08-0f
P:3C28::10-17
P:3C30::18-1f
P:3C3E:BlockBuffer_Y_Adder1
P:3C64:BlockBuffer_Y_Adder2
P:3C8A:BlockBufferAddr1
P:3C8E:BlockBufferColli_Feet:inc PlayerFoot\nif branched here, increment to next set of adders
P:3C8F:BlockBufferColli_Head:set flag to return vertical coordinate
P:3C91::BIT instruction opcode
P:3C92:BlockBufferColli_Side:set flag to return horizontal coordinate
P:3C94:BlockBufferCollision:ldx #$00       ;set offset for player object\nsave contents of A to stack
P:3C95::save contents of Y here
P:3C97::add horizontal coordinate
P:3C9A::of object to value obtained using Y as offset
P:3C9D::store here
P:3C9F::of indirect here
P:3CA8::lda SprObject_PageLoc       ;get LSB, mask out all other bits\nlsr                         ;move to carry
P:3CAD::store here and leave
P:3CAF::get old contents of Y
P:3CB1::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3CB4::add it to value obtained using Y as offset
P:3CB7::mask out low nybble
P:3CB9::store result here
P:3CBB::use as offset for block buffer
P:3CBC::check current content of block buffer
P:3CBE::and store here
P:3CC0::get old contents of Y again
P:3CC2::pull A from stack
P:3CC3::if A = 1, branch
P:3CC5::if A = 0, load vertical coordinate
P:3CC7::and mask out high nybble
P:3CC9::store masked out result here
P:3CCB::get saved content of block buffer
P:3CD0::and leave, again...
P:3CD1:RetXC:otherwise load horizontal coordinate
P:3CD3::and mask out high nybble
P:3CD5::store masked out result here
P:3CD7::get saved content of block buffer
P:3CDC::and leave
P:3CDD:KillPlant
P:3CEF::mask out 2 MSB of enemy object's state
P:3CF1::set d5 to defeat enemy and save as new state
P:3CF5::play smack enemy sound
P:3CFC::get chain counter for shell
P:3D0E::mask out 2 MSB of enemy object's state
P:3D10::set d5 to defeat enemy and save as new state
P:3D14::play smack enemy sound
P:3D24:MSBtoLSB
P:3E24:LSBtoMSB
P:3F24:BridgeCollapseData:axe
P:3F25::bridge
P:3F32:DrawPowerUp:-------------------------------------------------------------------------------------\n$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type\n$02 - used to hold bottom row Y position\n$03 - used to hold flip control (not used here)\n$04 - used to hold sprite attributes\n$05 - used to hold X position\n$07 - counter\ntiles arranged in top left, right, bottom left, right order\nget power-up's sprite data offset
P:3F41::get relative vertical coordinate
P:3F45::add eight pixels
P:3F47::store result here
P:3F49::get relative horizontal coordinate
P:3F4C::store here
P:3F52::ldx PowerUpType            ;get power-up type\nget attribute data for power-up type
P:3F55::add background priority bit if set
P:3F58::store attributes here
P:3F5B::save power-up type to the stack
P:3F5D::multiply by four to get proper offset
P:3F5E::use as X
P:3F61::set counter here to draw two rows of sprite object
P:3F70::init d1 of flip control
P:3F72:PUpDrawLoop:load left tile of power-up object
P:3F77::load right tile
P:3F7A::branch to draw one row of our power-up object
P:3F7D::decrement counter
P:3F7F::branch until two rows are drawn
P:3F81::get sprite data offset again
P:3F84::pull saved power-up type from the stack
P:3F85::if regular mushroom, branch, do not change colors or flip
P:3F89::if 1-up mushroom, branch, do not change colors or flip
P:3F8B::store power-up type here now
P:3F8D::get frame counter
P:3F8F::divide by 2 to change colors every two frames
P:3F90::mask out all but d1 and d0 (previously d2 and d1)
P:3F92::add background priority bit if any set
P:3F95::set as new palette bits for top left and
P:3F98::top right sprites for fire flower and star
P:3F9D::check power-up type for fire flower
P:3F9E::if found, skip this part
P:3FA0::otherwise set new palette bits  for bottom left
P:3FA3::and bottom right sprites as well for star only
P:3FA6:FlipPUpRightSide
P:3FA9::set horizontal flip bit for top right sprite
P:3FB1::set horizontal flip bit for bottom right sprite
P:3FB3::note these are only done for fire flower and star power-ups
P:3FB6:PUpOfs:jump to check to see if power-up is offscreen at all, then leave
P:4000:: bank 01 -- custom code\n bank identifier
P:4001:MMC3Setup: THIS CODE SUCKS!!!!!!!!! :))))))
P:4011::lda #$1f\nsta $c000\nlda #$00
P:401C::set on block by default
P:4028:LoopMMC3Setup
P:406C::lda #$20\nsta $7f03\nlda #$80\nsta $ff
P:408F:MMC3SetupTable
P:4095:setCHR:setMirroring:\n    sta $a000\n    rts\n setLeftCHR sets both left CHR banks\n setRightCHR sets all 4 right CHR banks\n\n The chr is divided like this (but it can be \n inverted to switch which side gets 2 and which\n side gets 4 banks).\n\n______________________  ______________________\n| 0                  |  | 2                  |\n|                    |  |____________________|\n|                    |  | 3                  |\n|____________________|  |____________________|\n| 1                  |  | 4                  |\n|                    |  |____________________|\n|                    |  | 5                  |\n|____________________|  |____________________|\n The values used are as if they were all 2k banks.\n An example of the values is:\n CHR0: 0\n CHR1: 2\n CHR2: 4\n CHR3: 5\n CHR4: 6\n CHR5: 7\nlda #$00\nsta Old8000\nsta $8000\nlda CHR0\nsta $8001\nlda #$01\nsta Old8000\n sta $8000\nlda CHR1\nsta $8001\nlda #$02\nsta Old8000\nsta $8000\nlda CHR2\nsta $8001
P:40A6::lda #$84\n;sta $8000\nlda CHR4\nsta $8001
P:40B1::load depending of on block and pswitch flag
P:40C1::lda #$05\nsta Old8000\nsta $8000\nlda CHR5\nsta $8001
P:40C2:setLeftCHR
P:40CE:setRightCHR
P:40E1:setLeftCHRDirect
P:40FB:setRightCHRDirect
P:412C:MessageBoxData_Low:include code\lagmaker.asm
P:412D:MessageBoxData_High
P:412E:MessageBoxData
P:428F:ASCII2CHR
P:42ED::button emojis
P:42F4:TestText:01
P:4346:ID01:02
P:43AF:VeryLongText:03
P:4431:Jigas:04
P:4462:ID05:05
P:44A3:Structured:06
P:4537:Firefox:07
P:4583:Textbox_Low
P:458A:Textbox_High
P:4592:SetupTextbox
P:45A2::only increment by 1
P:45A4::write contents of A to PPU register 1
P:45A7::and its mirror
P:45D7::sets vram address to $3f00
P:45E3::set y to 0 :)
P:45EE:DisplayTextbox: DisplayTextbox
P:4676::substract lowest ascii char for smaller table
P:4692:NeedsWaitForInputAndEnd
P:4695:NeedsContinueChar
P:4698:NeedsNewLine
P:469B:NeedsWaitAndScrollNoDec
P:469E:NeedsWaitAndScroll
P:46A1:NewLineChar
P:46CA:WaitAndScrollNoDec
P:46E7:WaitAndScroll
P:4705:ScrollTextBox
P:478B:TextBoxYClearTable
P:4792:ScrollLineTable
P:47B2:NewLine
P:47C2:WaitForInputAndEnd
P:47FD::set so no jumping after closing
P:4801::set y to 0 :)
P:480C:ContinueThingy
P:480E:TableOfCompares
P:4815:ContinueChar
P:4885:CustomText_AddrTable_Low
P:488A:CustomText_AddrTable_High
P:488F:CustomText0
P:48C5:Livestext
P:48CA:WellOk
P:48D4:MessageCrash1
P:4914:EndOfDemo
P:494D:ExitHere: $00 - used to hold low byte of custom text address\n $01 - used to hold high byte of custom text address\n $03 - used to hold ascii handling state
P:494F:CustomCode
P:494F:skipCustomOperModeTask
P:4956:: load ScreenRoutineTask
P:4959:: compare it to our stored ScreenRoutineTask
P:495C:: store ScreenRoutineTask
P:495F:: branch if they're the same
P:496D::lda FinishedDemo\ncmp #$ff\nbeq xd\ninc FinishedDemo\nlda FinishedDemo\ncmp #$04\nbcs xd\nlda #$04\njmp LoadCustomText\n here we run code when ScreenRoutineTask modes are initially set\n Display a message on intermediate screen\n check ScreenRoutineTask for DisplayIntermediate
P:496F:: branch if not
P:4971:: load message
P:4973:xd:jmp LoadCustomText
P:4974:OnOffCb:Off, On, pswitchOff, pswitchoOn
P:4978:OnOffCbW:Off, On, pswitchOff, pswitchoOn (water area)
P:497C:OnOffCHR
P:4988::load CHR bank depending if block is on or pswitch is triggered
P:4999:TitleScreenCHR
P:49A1::if loading level, decrement
P:49A6:Est
P:49D2:EE
P:49D3:Force
P:49D5:jmpik:the start
P:49E1:emin
P:49E4:vaina
P:49E6:ClearRemainings2
P:4A34:ClearVRAM
P:4A3E:WorldCHRTable
P:4A47:WorldPalHigh:---------------------------------------------\n\n			START OF BANK 01\n\n---------------------------------------------
P:4A4B:WorldPalLow
P:4A4F:World4Pal
P:4A6F:World6Pal
P:4A8F:World7Pal
P:4AAF:World8Pal
P:4ACF:ChangeBankRunner
P:4B86::if in pause mode, do not bother with sprites at all
P:4B8C::check mode of operation
P:4B91::if in title screen mode, branch to lock score
P:4B93::fifth digit of coin
P:4BC7::unconditional
P:4BC9:WebosJoder
P:4BCD:ExitThere
P:4BD0:EnemyLoadingRoutine
P:4BD5::get horizontal coordinate for left side of screen
P:4BDD::store result here
P:4BE5::store result here
P:4BEB::get horizontal coordinate for left side of screen
P:4BF3::store result here
P:4BFB::store result here
P:4C03:LoopEL
P:4C09::if defeated don't load anymore
P:4C22::sign ID + 1
P:4C26::power up ID + 1
P:4C95:_LoopEL
P:4CCA:emkn
P:4CCD::check for next saved enemy
P:4CDC:ExitTher
P:4CEC::jmp ++
P:4CF1::dec GlobalSaveOffset
P:4CF4::inc GlobalSaveOffset
P:4D0C:NoPlease2
P:4D12:PSpeedHud
P:4D45::lda WorldNumber\nasl\nasl\nadd LevelNumber\ntay
P:4D4F::ldy LevelNumber
P:4DD2:WriteDat
P:4E09::lda $7f03
P:4E2C:NoPlease
P:4E4E::ldy VRAM_Buffer1_Offset   \nlda VRAM_Buffer1-6,y      ;check highest digit of score\nbne +++	                  ;if zero, overwrite with space tile for zero suppression\nlda #$24\nsta VRAM_Buffer1-6,y\njmp ++
P:4E67::change the last 0 to a 9
P:4E76::jmp +\nlda IntervalTimerControl\nbne +\n\nlda FrameCaunter+2\nadd #$01\nsta FrameCaunter+2\nlda FrameCaunter+1\nadc #$00\nsta FrameCaunter+1\nlda FrameCaunter\nadc #$00\nsta FrameCaunter\n\nldx VRAM_Buffer1_Offset\nlda #$20\nsta VRAM_Buffer1,x\ninx\nlda #$00\nsta VRAM_Buffer1,x\ninx\nlda #$06\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter\nand #$f0\nlsr\nlsr\nlsr\nlsr\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter\nand #$0f\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+1\nand #$f0\nlsr\nlsr\nlsr\nlsr\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+1\nand #$0f\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+2\nand #$f0\nlsr\nlsr\nlsr\nlsr\nsta VRAM_Buffer1,x\ninx\nlda FrameCaunter+2\nand #$0f\nsta VRAM_Buffer1,x\ninx\nlda #$00\nsta VRAM_Buffer1,x\nstx VRAM_Buffer1_Offset\nlda EvenFrame\neor #$01\nsta EvenFrame\nldx $07eb					;load first digit of coin counter\ndex\nbne ++\ninc UnlockWorld9			;unlock world 9
P:4E81::get primary mode of operation
P:4E84::branch to set title screen CHR
P:4E86::are we in game over mode?
P:4E88::if so, proceed change platform sprite to the coin heaven one
P:4E8A::check timer to change CHR
P:4E8D::branch if zero
P:4E95::if cloud level override flag not set, use normal platform CHR
P:4E97:CldPlt
P:4E9F::set cloud platform sprite
P:4EA4::skip to FireballCooldown
P:4EA7:NrmlPl
P:4EAF::set normal platform sprite
P:4EB4:FireballCooldown:if fireball cooldown set, don't decrement
P:4ECC::check grabflag
P:4ECF::branch if not
P:4EDB::set grabbing sprite
P:4EE1:Chavo
P:4F01::set normal sprite
P:4F35::set grabbing sprite
P:4F3B::do not animate if master timer set
P:4F40::branch if not under 60 seconds
P:4F4D::check if last animation CHR bank
P:4F4F::if not, skip this
P:4F53::set first animation CHR bank and
P:4F56::jump to speed up animation
P:4F84::check ptimer
P:4F87::branch to set if set
P:4F89::if ptimer is 0
P:4F8C::then save only bit 0
P:4F97::load animation depending of the area type
P:4F9A::increment bank timer
P:4FA7:PSwitchBank
P:4FC0:Fuk
P:4FCE:@e
P:4FD1:@i
P:4FDF:Bank1
P:4FE6:BankR
P:4FE8::reset bank change
P:4FEE:PSwitchBank1
P:4FF1:AnimAdder
P:4FF9:AreaAdder
P:4FFD:AreaAdderP
P:5001:HurryUpChg
P:5006::lda PTimer\nbne PSwitchBank1\nlda #$01\nsta ChangeBankRDelay\n+:		 dec ChangeBankRDelay
P:501C::add #%01000100
P:5022::if ptimer not set
P:5025::save only bit 0
P:503E::increment bank timer
P:504B:bocataprint:store player-specific offset
P:504D::use first nybble to print the coin display
P:5050::move high nybble to low
P:5052::and print to score display
P:5056:OutputNumbers1:add 1 to low nybble
P:5059::mask out high nybble
P:505F::save incremented value to stack for now and
P:5060::shift to left and use as offset
P:5062::get current buffer pointer
P:5069::put at top of screen by default
P:506B::are we writing top score on title screen?
P:506F::if so, put further down on the screen
P:5071:SetupNums1
P:5074::write low vram address and length of thing
P:5077::we're printing to the buffer
P:5080::save length byte in counter
P:5084::pull original incremented value from stack
P:5086::load offset to value we want to write
P:508A::subtract from length byte we read before
P:508D::use value as offset to display digits
P:5090:DigitPLoop1:write digits to the buffer
P:5098::do this until all the digits are written
P:509C::put null terminator at end
P:50A1::increment buffer pointer by 3
P:50A4::store it in case we want to use it again
P:50A7:ExitOutput1
P:50AD:Text_AddrTable_Low
P:50B5:Text_AddrTable_High
P:50BD:MuchoTexto
P:50DA:PocoTexto
P:50EE:Studs
P:5108:pending
P:511F:hellfire
P:5134:smbarena
P:514F:obviouslyme
P:5167:ElPepe
P:517B:PauseMenu
P:5191:UnPauses
P:5197:Clear6400
P:519E:DrawMenuCursorj
P:51A4:Some
P:51AB:SetPauseBG
P:51C2:Noth
P:51C3:DisplayPauseMenu
P:51C7::set pause sfx queue for next pause mode
P:51F8:MusicMutetxt
P:5207:MusicMuteON
P:5216:PSoundtxt
P:522D:PSoundON
P:5244:RestartText
P:5255:QTTSText
P:5267:DisplayMenuText:$28a2
P:526B::otherwise store A and B buttons in $0a
P:5272::store left and right buttons in $0c
P:527E::store up and down buttons in $0b
P:52DB:WhenTheSus
P:52E1::cmp #$05\nbcs ++
P:52EC:MusicSetting
P:531A:PauseMenuExit
P:531B:PSoundSetting
P:534A:RestartSetting:inc FetchNewGameTimerFlag ;set flag to load new game timer\ninc DisableScreenFlag     ;set flag to disable screen output
P:5387:QuitToTitleScreen
P:53CF:DrawMenuCursor
P:53F5::lda #$00\nsta VRAM_Buffer1+4,x
P:542A:DoFlagpoleEnemy
P:5432::multiply current offset where we're at by 16
P:5435::to obtain horizontal pixel coordinate
P:5439::get pixel coordinate of where the flagpole is,
P:543A::subtract eight pixels and use as horizontal
P:543F::sta Enemy_X_Position,x   ;coordinate for the flag
P:5442::subtract borrow from page location and use as
P:5447::page location for the flag
P:5450::set vertical coordinate for flag
P:5454::set initial vertical coordinate for flagpole's floatey number
P:5459::set flag identifier, note that identifier and coordinates
P:5460::use last space in enemy object buffer
P:5463:jmpidk2
P:5470:QUe2
P:547D:PlayerColorsOffset1
P:547F:MarioColors1:Small
P:547F:PlayerColors1
P:5483::Big
P:5487::Fiery
P:548B:LuigiColors1:Small
P:548F::Big
P:5493::Fiery
P:5497:BackgroundColors1:used by area type if bg color ctrl not set
P:549B::used by background color control if set
P:54A3:GetPlayerColors2:get current buffer offset
P:54B7:StartClrGet1:do four colors
P:54BB:ClrGetLoop1:fetch player colors and store them
P:54BE::in the buffer
P:54C7::load original offset from before
P:54CA::if this value is four or greater, it will be set
P:54CD::therefore use it as offset to background color
P:54D9::otherwise use area type bits from area offset as offset
P:54DC:SetBGColor1:to background color instead
P:54E2::set for sprite palette address
P:54E4::save to buffer
P:54EC::write length byte to buffer
P:54F1::now the null terminator
P:54F6::move the buffer pointer ahead 7 bytes
P:54F7::in case we want to write anything else later
P:54FA::store as new vram buffer offset
P:54FE:Hitboxes
P:5535:PPhitbox1
P:5537:MoveAllSpritesOffscreen1:ldy #$00                ;this routine moves all sprites off the screen\n.byte $2c                 ;BIT instruction opcode\nthis routine moves all but sprite 0
P:5537:MoveSpritesOffscreen1
P:5539::off the screen
P:553B:SprInitLoop:sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
P:55FC:BlankPalette
P:5604:Palette2Data:used based on area type
P:5614:ColorRotation:check vram buffer offset
P:5619::if offset over 48 bytes, branch to leave
P:561B::otherwise use frame counter's 3 LSB as offset here
P:561D:GetBlankPal:get blank palette for palette 3
P:5620::store it in the vram buffer
P:5623::increment offsets
P:5627::do this until all bytes are copied
P:5629::get current vram buffer offset
P:562E::set counter here
P:5637::get area type
P:563A::multiply by 4 to get proper offset
P:563C::save as offset here
P:563D:GetAreaPal
P:5648::fetch palette to be written based on area type
P:564B::store it to overwrite blank palette in vram buffer
P:5650::decrement counter
P:5652::do this until the palette is all copied
P:5657::add seven bytes to vram buffer offset
P:565D:ExitColorRot:leave
P:565E:EnemyGraphicsTable:-------------------------------------------------------------------------------------\n$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers\n$02 - used to store Y position\n$03 - used to store moving direction, used to flip enemies horizontally\n$04 - used to store enemy's sprite attributes\n$05 - used to store X position\n$eb - used to hold sprite data offset\n$ec - used to hold either altered enemy state or special value used in gfx handler as condition\n$ed - used to hold enemy state from buffer \n$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)\ntiles arranged in top left, right, middle left, right, bottom left, right order\nbuzzy beetle frame 1
P:5664::             frame 2
P:566A::koopa troopa frame 1
P:5670::             frame 2
P:5676::koopa paratroopa frame 1
P:567C::                 frame 2
P:5682::spiny frame 1
P:5688::      frame 2
P:568E::spiny's egg frame 1
P:5694::            frame 2
P:569A::bloober frame 1
P:56A0::        frame 2
P:56A6::cheep-cheep frame 1
P:56AC::            frame 2
P:56B2::goomba
P:56B8::koopa shell frame 1 (upside-down)
P:56BE::            frame 2
P:56C4::koopa shell frame 1 (rightsideup)
P:56CA::            frame 2
P:56D0::buzzy beetle shell frame 1 (rightsideup)
P:56D6::                   frame 2
P:56DC::buzzy beetle shell frame 1 (upside-down)
P:56E2::                   frame 2
P:56E8::defeated goomba
P:56EE::lakitu frame 1
P:56F4::       frame 2
P:56FA::princess
P:5700::mushroom retainer
P:5706::hammer bro frame 1
P:570C::           frame 2
P:5712::           frame 3
P:5718::           frame 4
P:571E::piranha plant frame 1
P:5724::              frame 2
P:572A::podoboo
P:5730::bowser front frame 1
P:5736::bowser rear frame 1
P:573C::       front frame 2
P:5742::       rear frame 2
P:5748::bullet bill
P:5754:EnemyGfxTableOffsets:.db $f2, $f2, $f3, $f3, $f2, $f2  ;jumpspring frame 1\n.db $f1, $f1, $f1, $f1, $fc, $fc  ;           frame 2\n.db $f0, $f0, $fc, $fc, $fc, $fc  ;           frame 3
P:575C::0f
P:576C::1f
P:5777:EnemyAttributeData
P:577F::0f
P:578F::1f
P:579A:EnemyAnimTimingBMask
P:579C:JumpspringFrameOffsets
P:57A1:SignPalettes
P:57A5:EnemyGfxHandler1:get enemy object vertical position
P:57A9::get enemy object horizontal position
P:57AC::relative to screen
P:57B1::get sprite data offset
P:57B5::initialize vertical flip flag by default
P:57BA::get enemy object moving direction
P:57BF::get enemy object sprite attributes
P:57DC::is enemy object piranha plant?
P:57DE::if not, branch
P:57E2::if piranha plant moving upwards, branch
P:57E7::if timer for movement expired, branch
P:57E9::if all conditions fail, leave
P:57EA:CheckForRetainerObj:store enemy state
P:57EE::nullify all but 5 LSB and use as Y
P:57F1::check for mushroom retainer/princess object
P:57F5::if not found, branch
P:57F7::if found, nullify saved state in Y
P:57F9::set value that will not be used
P:57FD::set value $15 as code for mushroom retainer/princess object
P:57FF:CheckForBulletBillCV:otherwise check for bullet bill object
P:5801::if not found, branch again
P:5803::decrement saved vertical position
P:5807::get timer for enemy object
P:580A::if expired, do not set priority bit
P:580C::otherwise do so
P:580E:SBBAt:set new sprite attributes
P:5810::nullify saved enemy state both in Y and in
P:5812::memory location here
P:5814::set specific value to unconditionally branch once
P:5816:CheckForPodoboo:CheckForJumpspring:\n      cmp #JumpspringObject        ;check for jumpspring object\n      bne CheckForPodoboo\n      ldy #$03                     ;set enemy state -2 MSB here for jumpspring object\n      ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object\n      lda JumpspringFrameOffsets,x ;load data using frame number as offset\nstore saved enemy object value here
P:5818::and Y here (enemy state -2 MSB if not changed)
P:581A::get enemy object offset
P:581C::check for podoboo object
P:581E::branch if not found
P:5820::if moving upwards, branch
P:5824::otherwise, set flag for vertical flip
P:5827:CheckBowserGfxFlag:if not drawing bowser at all, skip to something else
P:582C::if set to 1, draw bowser's front
P:5832::otherwise draw bowser's rear
P:5833:SBwsrGfxOfs
P:5835:CheckForGoomba:check value for goomba object
P:5841::branch if not found
P:5845::check for defeated state
P:5847::if not defeated, go ahead and animate
P:5849::if defeated, write new value here
P:584D:GmbaAnim:check for d5 set in enemy object state 
P:584F::or timer disable flag set
P:5852::if either condition true, do not animate goomba
P:5856::check for every eighth frame
P:585C::invert bits to flip horizontally every eight frames
P:585E::leave alone otherwise
P:5860:CheckBowserFront
P:5876::load sprite attribute using enemy object
P:5879::as offset, and add to bits already loaded
P:587D::load value based on enemy object as offset
P:5880::save as X
P:5881::get previously saved value
P:5886::if not drawing bowser object at all, skip all of this
P:588A::if not drawing front part, branch to draw the rear part
P:588C::check bowser's body control bits
P:588F::branch if d7 not set (control's bowser's mouth)      
P:5891::otherwise load offset for second frame
P:5893:ChkFrontSte:check saved enemy state
P:5895::if bowser not defeated, do not set flag
P:5899:FlipBowserOver:set vertical flip flag to nonzero
P:589C:DrawBowser:draw bowser's graphics now
P:589F:CheckBowserRear:check bowser's body control bits
P:58A4::branch if d0 not set (control's bowser's feet)
P:58A6::otherwise load offset for second frame
P:58A8:ChkRearSte:check saved enemy state
P:58AA::if bowser not defeated, do not set flag
P:58AE::subtract 16 pixels from
P:58B0::saved vertical coordinate
P:58B5::jump to set vertical flip flag
P:58B8:CheckForSpiny:check if value loaded is for spiny
P:58BA::if not found, branch
P:58BC::if enemy state set to $05, do this,
P:58BE::otherwise branch
P:58C0::set to spiny egg offset
P:58C4::set enemy direction to reverse sprites horizontally
P:58C8::set enemy state
P:58CA:NotEgg:skip a big chunk of this if we found spiny but not in egg
P:58CD:CheckForLakitu:check value for lakitu's offset loaded
P:58CF::branch if not loaded
P:58D3::check for d5 set in enemy state
P:58D5::branch if set
P:58DA::check timer to see if we've reached a certain range
P:58DC::branch if not
P:58DE::if d6 not set and timer in range, load alt frame for lakitu
P:58E0:NoLAFr:skip this next part if we found lakitu but alt frame not needed
P:58E3:CheckUpsideDownShell:check for enemy object => $04
P:590E::branch if true
P:5912::branch if enemy state < $02
P:5914::set for upside-down koopa shell by default
P:5918::check for buzzy beetle object
P:591E::increment vertical position by one pixel
P:5920:CheckRightSideUpShell:check for value set here
P:5922::if enemy state < $02, do not change to shell, if
P:5924::enemy state => $02 but not = $04, leave shell upside-down
P:5926::set right-side up buzzy beetle shell by default
P:5928::increment saved vertical position by one pixel
P:592C::check for buzzy beetle object
P:592E::branch if found
P:5930::change to right-side up koopa shell if not found
P:5932::and increment saved vertical position again
P:5934:CheckForDefdGoomba:check for goomba object (necessary if previously
P:5936::failed buzzy beetle object test)
P:593C::load for regular goomba
P:593E::note that this only gets performed if enemy state => $02
P:5940::check saved enemy state for d5 set
P:5942::branch if set
P:5944::load offset for defeated goomba
P:5946::set different value and decrement saved vertical position
P:5948:CheckForHammerBro
P:594A::check for hammer bro object
P:594E::branch if not found
P:5952::branch if not in normal enemy state
P:5956::if d3 not set, branch further away
P:5958::otherwise load offset for different frame
P:595A::unconditional branch
P:595C:CheckForBloober:check for cheep-cheep offset loaded
P:595E::branch if found
P:5965::branch if some timer is above a certain point
P:5967::check for bloober offset loaded
P:5969::branch if not found this time
P:596D::branch if timer is set to certain point
P:596F::increment saved vertical coordinate three pixels
P:5975::and do something else
P:5978:CheckToAnimateEnemy:check for specific enemy objects
P:5984::branch if goomba
P:598C::branch if bullet bill (note both variants use $08 here)
P:5990::branch if podoboo
P:599E::branch if => $18
P:59A4::check for mushroom retainer/princess object
P:59A6::which uses different code here, branch if not found
P:59A8::iny                      ;residual instruction\nare we on world 8?
P:59AD::if so, leave the offset alone (use princess)
P:59AF::otherwise, set for mushroom retainer object instead
P:59B1::set alternate state here
P:59B5::unconditional branch
P:59B7:CheckForSecondFrame:load frame counter
P:59B9::mask it (partly residual, one byte not ever used)
P:59BC::branch if timing is off
P:59BE:CheckAnimationStop:check saved enemy state
P:59C0::for d7 or d5, or check for timers stopped
P:59C5::if either condition true, branch
P:59CF::add $06 to current enemy offset
P:59D1::to animate various enemy objects
P:59D2:CheckDefeatedState
P:59DC::check saved enemy state
P:59DE::for d5 set
P:59E0::branch if not set
P:59E4::check for saved enemy object => $04
P:59E6::branch if less
P:59EE::set vertical flip flag
P:59F2::init saved value here
P:59F4:DrawEnemyObject:load sprite data offset
P:59F6::draw six tiles of data
P:59F9::into sprite data
P:59FF::get enemy object offset
P:5A01::get sprite data offset
P:5A06::get saved enemy object and check
P:5A08::for bullet bill, branch if not found
P:5A0A:SkipToOffScrChk:jump if found
P:5A0D:CheckForVerticalFlip:check if vertical flip flag is set here
P:5A10::branch if not
P:5A12::get enemy object offset
P:5A14::get sprite data offset
P:5A17::get attributes of first sprite we dealt with
P:5A1A::set bit for vertical flip
P:5A1D::increment two bytes so that we store the vertical flip
P:5A1E::dump A contents
P:5A21::into third row sprites
P:5A24::into second row sprites
P:5A2A::and into first row sprites
P:5A2D::in attribute bytes of enemy obj sprite data
P:5A31::now go back to the Y coordinate offset
P:5A33::give offset to X
P:5A36::check saved enemy object for hammer bro
P:5A3A::check saved enemy object for lakitu
P:5A3C::branch for hammer bro or lakitu
P:5A4C::also branch if enemy object => $15
P:5A50::if not selected objects or => $15, set
P:5A52::offset in X for next row
P:5A53:FlipEnemyVertically:load first or second row tiles
P:5A56::and save tiles to the stack
P:5A5B::exchange third row tiles
P:5A5E::with first or second row tiles
P:5A67::pull first or second row tiles from stack
P:5A68::and save in third row
P:5A6F:CheckForESymmetry:are we drawing bowser at all?
P:5A72::branch if so
P:5A76::get alternate enemy state
P:5A78::check for hammer bro object
P:5A7C::jump if found
P:5A7F:CheckToMirrorLakitu1
P:5A82:ContES:check for bloober object
P:5A86::check for piranha plant object
P:5A96::check for podoboo object
P:5A98::branch if either of three are found
P:5A9A::check for spiny object
P:5A9C::branch closer if not found
P:5A9E::check spiny's state
P:5AA0::branch if not an egg, otherwise
P:5AA2:ESRtnr:check for princess/mushroom retainer object
P:5AA6::set horizontal flip on bottom right sprite
P:5AA8::note that palette bits were already set earlier
P:5AAB:SpnySC:if alternate enemy state set to 1 or 0, branch
P:5AAF:MirrorEnemyGfx:if enemy object is bowser, skip all of this
P:5AB4::load attribute bits of first sprite
P:5AB9::save vertical flip, priority, and palette bits
P:5ABC::in left sprite column of enemy object OAM data
P:5AC2::set horizontal flip
P:5AC4::check for state used by spiny's egg
P:5AC6::if alternate state not set to $05, branch
P:5AC8::otherwise set vertical flip
P:5ACA:EggExc:set bits of right sprite column
P:5ACD::of enemy object sprite data
P:5AF5::check alternate enemy state
P:5AF7::branch if not $04
P:5AFA::get second row left sprite attributes
P:5AFF::store bits with vertical flip in
P:5B02::second and third row left sprites
P:5B07::store with horizontal and vertical flip in
P:5B0A::second and third row right sprites
P:5B0D:CheckToMirrorLakitu
P:5B13::check if enemy ID is piranha plant
P:5B17::store current X in here
P:5B1F::get the piranha's root Y position
P:5B25::	iny
P:5B36::subtract the current piranha position from it
P:5B38::and to check every 8 difference
P:5B3D::rotate xxxxx000 -> 000xxxxx
P:5B3F::load from this table, 0->this sprite is inside the pipe, 1->this sprite is outside of pipe
P:5B42::store it into a temporary address
P:5B45::rotate to the right, bit 0 becomes carry
P:5B48::if carry is clear, piranha is inside the pipe (this can be optimized to branch to the end of the code)
P:5B4A::otherwise get the sprite attribute
P:5B52::do it with the sprite next to it aswell
P:5B5A::same procedure as earlier
P:5B6F::same procedure as earlier
P:5B87:exitPiranha
P:5B8F::store current X in here
P:5B94::get the piranha's root Y position
P:5B9B::subtract the current piranha position from it
P:5B9D::and to check every 8 difference
P:5BA2::rotate xxxxx000 -> 000xxxxx
P:5BA4::load from this table, 0->this sprite is inside the pipe, 1->this sprite is outside of pipe
P:5BA7::store it into a temporary address
P:5BAA::rotate to the right, bit 0 becomes carry
P:5BAD::if carry is clear, piranha is inside the pipe (this can be optimized to branch to the end of the code)
P:5BBF::same procedure as earlier
P:5BD4::same procedure as earlier
P:5BD9::otherwise get the sprite attribute
P:5BE1::do it with the sprite next to it aswell
P:5BEC:exitPiranhaUD:check for lakitu enemy object
P:5BF0::branch if not found
P:5BF5::branch if vertical flip flag not set
P:5BF7::save vertical flip and palette bits
P:5BFA::in third row left sprite
P:5BFF::set horizontal flip and palette bits
P:5C02::in third row right sprite
P:5C07::check timer
P:5C0C::branch if timer has not reached a certain range
P:5C0E::otherwise set same for second row right sprite
P:5C13::preserve vertical flip and palette bits for left sprite
P:5C16::unconditional branch
P:5C18:NVFLak:get first row left sprite attributes
P:5C1D::save vertical flip and palette bits
P:5C20::get first row right sprite attributes
P:5C23::set horizontal flip and palette bits
P:5C25::note that vertical flip is left as-is
P:5C2B:PiranhaTable:CheckToMirrorJSpring:\nlda temp4                   ;check for jumpspring object (any frame)\ncmp #$18\nbcc SprObjectOffscrChk      ;branch if not jumpspring object at all\ncmp #RedKoopaShell\nbeq SprObjectOffscrChk\ncmp #RedPiranhaPlant\nbeq SprObjectOffscrChk\ncmp #RUDPiranhaPlant\nbeq SprObjectOffscrChk\ncmp #UDPiranhaPlant\nbeq SprObjectOffscrChk\nlda #$82\nsta Sprite_Attributes+8,y   ;set vertical flip and palette bits of \nsta Sprite_Attributes+16,y  ;second and third row left sprites\nora #%01000000\nsta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip\nsta Sprite_Attributes+20,y  ;for second and third row right sprites
P:5C2F:UDPiranhaTable
P:5C34:GameOverCursorData:.db $5b, $02, $48
P:5C37:GameOverCursorY:, $a7, $bf, $d7
P:5C39:GameOverMenu
P:5C6C::if player pressed the start button
P:5C6F::then either continue or start over
P:5C76::if player pressed the select button
P:5C78::then branch to select "continue" or "retry"
P:5C91::and toggle between the two choices
P:5C93::            inc ContinueMenuSelect\n            lda ContinueMenuSelect\n            and #$03
P:5C95:ChgSel
P:5C97:ChgSelLoop:set up cursor sprite tile, attribute
P:5C9A::and X position in sprite OAM data
P:5CA2::set Y position based on the selection
P:5CAF:ContinueOrRetry:if player selected "continue"
P:5CB1::then branch to continue
P:5CB3::lda #$00\nsta CompletedWorlds          ;otherwise init completed worlds flags
P:5CBA:Continue
P:5CBC::give five lives
P:5CCF::put at x-1 of the current world
P:5CD6:ISCont:reset score
P:5CDC::allow 1-up to be found again
P:5CE5:LevelSelectAreasOffsets1
P:8000:: bank 02 -- relocated original sound code\n bank identifier
P:8001:SoundEngine:are we in title screen mode?
P:8006::if so, disable sound and leave
P:800A:SndOn
P:800C::disable irqs and set frame counter mode???
P:8011::enable first four channels
P:8014::is sound already in pause mode?
P:8019::if not, check pause sfx queue    
P:801D::if queue is empty, skip pause mode routine
P:801F:InPause:check pause sfx buffer
P:8024::check pause queue
P:8028::if queue full, store in buffer and activate
P:802B::pause mode to interrupt game sounds
P:802E::disable sound and clear sfx buffers
P:803B::enable sound again
P:803E::store length of sound in pause counter
P:8043:PTone1F:play first tone
P:8045::unconditional branch
P:8047:ContPau:check pause length left
P:804A::time to play second?
P:804E::time to play first again?
P:8052::time to play second again?
P:8054::only load regs during times, otherwise skip
P:8056:PTone2F:store reg contents and play the pause sfx
P:8058:PTRegC
P:805F:DecPauC:decrement pause sfx counter
P:8064::lda #$00                  ;disable sound if in pause mode and
P:8069::not currently playing the pause sfx
P:806C::if no longer playing pause sfx, check to see
P:806F::if we need to be playing sound again
P:8073::clear pause mode to allow game sounds again
P:8078:SkipPIn:clear pause sfx buffer
P:807F:RunSoundSubroutines:play sfx on square channel 1
P:8082:: ''  ''  '' square channel 2
P:8085:: ''  ''  '' noise channel
P:8088::play music on all channels
P:808B::clear the music queues
P:8091:SkipSoundSubroutines:clear the sound effects queues
P:809B::load some sort of counter 
P:80A0::check for specific music
P:80A4::increment and check counter
P:80A9::if not there yet, just store it
P:80AB:NoIncDAC
P:80AC::if we are at zero, do not decrement 
P:80AE::decrement counter
P:80B1:StrWave:store into DMC load register (??)
P:80B4::we are done here
P:80B5:Dump_Squ1_Regs:--------------------------------\ndump the contents of X and Y into square 1's control regs
P:80BC:PlaySqu1Sfx:do sub to set ctrl regs for square 1, then set frequency regs
P:80BF:SetFreq_Squ1:set frequency reg offset for square 1 sound channel
P:80C1:Dump_Freq_Regs
P:80C2::use previous contents of A for sound reg offset
P:80C5::if zero, then do not load
P:80C7::first byte goes into LSB of frequency divider
P:80CA::second byte goes into 3 MSB plus extra bit for 
P:80CD::length counter
P:80D2:NoTone
P:80D3:Dump_Sq2_Regs:dump the contents of X and Y into square 2's control regs
P:80DA:PlaySqu2Sfx:do sub to set ctrl regs for square 2, then set frequency regs
P:80DD:SetFreq_Squ2:set frequency reg offset for square 2 sound channel
P:80DF::unconditional branch
P:80E1:SetFreq_Tri:set frequency reg offset for triangle sound channel
P:80E3::unconditional branch
P:80E5:SwimStompEnvelopeData:--------------------------------
P:80F3:PlayFlagpoleSlide:store length of flagpole sound
P:80F8::load part of reg contents for flagpole sound
P:80FD::now load the rest
P:8101:PlaySmallJump:branch here for small mario jumping sound
P:8105:PlayBigJump:branch here for big mario jumping sound
P:8107:JumpRegContents:note that small and big jump borrow each others' reg contents
P:8109::anyway, this loads the first part of mario's jumping sound
P:810E::store length of sfx for both jumping sounds
P:8110::then continue on here
P:8113:ContinueSndJump:jumping sounds seem to be composed of three parts
P:8116::check for time to play second part yet
P:811A::load second part
P:811E::unconditional branch
P:8120:N2Prt:check for third part
P:8124::load third part
P:8126:FPS2nd:the flagpole slide sound shares part of third part
P:8128:DmpJpFPS
P:812B::unconditional branch outta here
P:812D:PlayFireballThrow
P:812F::load reg contents for fireball throw sound
P:8131::unconditional branch
P:8133:PlayBump:load length of sfx and reg contents for bump sound
P:8137:Fthrow:the fireball sound shares reg contents with the bump sound
P:813C::load offset for bump sound
P:8141:ContinueBumpThrow:check for second part of bump sound
P:8148::load second part directly
P:814D:DecJpFPS:unconditional branch
P:814F:_PlayPipeDownInj
P:8152:_PlayFlagpoleSlide
P:8155:Square1SfxHandler:check for sfx in queue
P:8159::if found, put in buffer
P:815B::small jump
P:815F::big jump
P:8163::bump
P:8167::swim/stomp
P:816B::smack enemy
P:816F::pipedown/injury
P:8173::fireball throw
P:8177::slide flagpole
P:8179:CheckSfx1Buffer:check for sfx in buffer 
P:817B::if not found, exit sub
P:817D::small mario jump 
P:8180::big mario jump 
P:8183::bump
P:8186::swim/stomp
P:8189::smack enemy
P:818C::pipedown/injury
P:818F::fireball throw
P:8192::slide flagpole
P:8194:ExS1H
P:8195:PlaySwimStomp:store length of swim/stomp sound
P:819A::store reg contents for swim/stomp sound
P:81A3:ContinueSwimStomp:look up reg contents in data section based on
P:81A6::length of sound left, used to control sound's
P:81A9::envelope
P:81B0::when the length counts down to a certain point, put this
P:81B2::directly into the LSB of square 1's frequency divider
P:81B5:BranchToDecLength1:unconditional branch (regardless of how we got here)
P:81B7:PlaySmackEnemy:store length of smack enemy sound
P:81C0::store reg contents for smack enemy sound
P:81C5::unconditional branch
P:81C7:ContinueSmackEnemy
P:81CD::check about halfway through
P:81D4::if we're at the about-halfway point, make the second tone
P:81D6::stomp counter 1: #%10100000
P:81E1::in the smack enemy sound
P:81E8:SmSpc:this creates spaces in the sound, giving it its distinct noise
P:81EA:SmTick
P:81ED:DecrementSfx1Length:decrement length of sfx
P:81F2:StopSquare1Sfx
P:81F5:ExSfx1
P:81F6:PlayPipeDownInj:load length of pipedown sound
P:81FB:ContinuePipeDownInj:some bitwise logic, forces the regs
P:81FE::to be written to only during six specific times
P:81FF::during which d3 must be set and d1-0 must be clear
P:8208::and this is where it actually gets written in
P:8211:NoPDwnL
P:8214:NormalContinueSwimStomp:--------------------------------\ncheck about halfway through
P:821B::if we're at the about-halfway point, make the second tone
P:821D::in the smack enemy sound
P:8224:SmSpc1:this creates spaces in the sound, giving it its distinct noise
P:8226:SmTic1
P:8231:PowerUpGrabFreqData
P:824C::residual frequency data
P:824F:ExtraLifeFreqData
P:8255:PUp_VGrow_FreqData:used by both
P:8265::used by vinegrow
P:8275:PlayCoinGrab:load length of coin grab sound
P:8277::and part of reg contents
P:827B:PlayTimerTick:load length of timer tick sound
P:827D::and part of reg contents
P:8282::load the rest of reg contents 
P:8284::of coin grab and timer tick sound
P:828C:CGrab_TTickRegL
P:828F::load the rest of reg contents 
P:8291::of coin grab and timer tick sound
P:8296:ContinueCGrabTTick:check for time to play second tone yet
P:8299::timer tick sound also executes this, not sure why
P:829D::if so, load the tone directly into the reg
P:82A2:N2Tone
P:82A4:N2Ton3:lda #$54
P:82B9:PlayBlast:load length of fireworks/gunfire sound
P:82BE::load reg contents of fireworks/gunfire sound
P:82C4:ContinueBlast:check for time to play second part
P:82CB::load second part reg contents then
P:82CF:SBlasJ:unconditional branch to load rest of reg contents
P:82D2:PlayPowerUpGrab:load length of power-up grab sound
P:82D7:ContinuePowerUpGrab:load frequency reg based on length left over
P:82DA::divide by 2
P:82DB::alter frequency every other frame
P:82DE::use length left over / 2 for frequency offset
P:82E1::store reg contents of power-up grab sound
P:82E5:LoadSqu2Regs
P:82E8:DecrementSfx2Length:decrement length of sfx
P:82ED:EmptySfx2Buffer:initialize square 2's sound effects buffer
P:82F1:StopSquare2Sfx
P:82F4:ExSfx2
P:82F5:PlayTimerTick1
P:82F8:PlayCoinGrab2
P:82FB:Square2SfxHandler
P:8305::special handling for the 1-up sound to keep it
P:8307::from being interrupted by other sounds on square 2
P:830B::check for sfx in queue
P:830F::if found, put in buffer and check for the following
P:8311::bowser fall
P:8315::coin grab
P:8319::power-up reveal
P:831D::vine grow
P:8321::fireworks/gunfire
P:8325::timer tick
P:8329::power-up grab
P:832B:CheckSfx2Buffer:lsr Square2SoundQueue\nbcs PlayExtraLife      ;1-up\ncheck for sfx in buffer
P:832D::if not found, exit sub
P:832F::bowser fall
P:8332::coin grab
P:8335::power-up reveal
P:8338::vine grow
P:833B::fireworks/gunfire
P:833E::timer tick
P:8341::power-up grab
P:8344::1-up
P:8346:ExS2H
P:8347:Cont_CGrab_TTick
P:834A:N2Tone1
P:834D:JumpToDecLength2
P:8350:PlayBowserFall:load length of bowser defeat sound
P:8355::load contents of reg for bowser defeat sound
P:8359:BlstSJp
P:835B:ContinueBowserFall:check for almost near the end
P:8362::if so, load the rest of reg contents for bowser defeat sound
P:8366:PBFRegs:the fireworks/gunfire sound shares part of reg contents here
P:8368:EL_LRegs:this is an unconditional branch outta here
P:836B:PlayExtraLife:load length of 1-up sound
P:8370:ContinueExtraLife
P:8373::load new tones only every eight frames
P:8375:DivLLoop
P:8376::if any bits set here, branch to dec the length
P:8379::do this until all bits checked, if none set, continue
P:837C::load our reg contents
P:8383::unconditional branch
P:8385:PlayGrowPowerUp:load length of power-up reveal sound
P:8389:PlayGrowVine:load length of vine grow sound
P:838B:GrowItemRegs
P:838E::load contents of reg for both sounds directly
P:8393::start secondary counter for both sounds
P:8398:ContinueGrowItems:increment secondary counter for both sounds
P:839B::this sound doesn't decrement the usual counter
P:839E::divide by 2 to get the offset
P:83A0::have we reached the end yet?
P:83A3::if so, branch to jump, and stop playing sounds
P:83A5::load contents of other reg directly
P:83AA::use secondary counter / 2 as offset for frequency regs
P:83B0:StopGrowItems:branch to stop playing sounds
P:83B3:BrickShatterFreqData:--------------------------------
P:83C3:SkidSfxFreqData
P:83C9:PlaySkidSfx
P:83D0:ContinueSkidSfx
P:83E4:PlayBrickShatter
P:83E6::load length of brick shatter sound
P:83EB:ContinueBrickShatter
P:83EE::divide by 2 and check for bit set to use offset
P:83F2::load reg contents of brick shatter sound
P:83F8:PlayNoiseSfx:play the sfx
P:8403:DecrementSfx3Length:decrement length of sfx
P:8408::if done, stop playing the sfx
P:8416:ExSfx3
P:8417:NoiseSfxHandler
P:842D::lsr\nbcs ContinueWindSfx\nlsr NoiseSoundQueue\nbcs PlayWindSfx
P:842E:CheckNoiseBuffer:check for sfx in queue\nif found, put in buffer\nbrick shatter\nbowser flame\ncheck for sfx in buffer
P:8430::if not found, exit sub
P:8433::brick shatter
P:8436::bowser flame
P:8438:ExNH
P:8439:PlayBowserFlame
P:843B::load length of bowser flame sound
P:8440:ContinueBowserFlame
P:8445::load reg contents of bowser flame sound
P:844A::unconditional branch here
P:844C:ContinueMusic:--------------------------------\nif we have music, start with square 2 channel
P:844F:MusicHandler:check event music queue
P:8453::check area music queue
P:8467::check both buffers
P:8470::no music, then leave
P:8471:LoadEventMusic:copy event music queue contents to buffer
P:8474::is it death music?
P:8476::if not, jump elsewhere
P:8478::stop sfx in square 1 and 2
P:847B::but clear only square 1's sfx buffer
P:847E:NoStopSfx
P:8480::save current area music buffer to be re-obtained later
P:8485::default value for additional length byte offset
P:8488::clear area music buffer
P:848A::is it time running out music?
P:848E::load offset to be added to length byte of header
P:8493::unconditional branch
P:8495:LoadAreaMusic:is it underground music?
P:8497::no, do not stop square 1 sfx
P:849C:NoStop1:start counter used only by ground level music
P:849E:GMLoopB
P:84A1:HandleAreaMusicLoopB:clear event music buffer
P:84A6::copy area music queue contents to buffer
P:84B3::is it ground level music?
P:84B7::increment but only if playing ground level music
P:84BA::is it time to loopback ground level music?
P:84BF::branch ahead with alternate offset
P:84C3::unconditional branch
P:84C5:FindAreaMusicHeader:load Y for offset of area music
P:84C7::residual instruction here
P:84C9:FindEventMusicHeader:increment Y pointer based on previously loaded queue contents
P:84CA::bit shift and increment until we find a set bit for music
P:84CD:LoadHeader:load offset for header
P:84D1::now load the header
P:84F3::initialize music note counters
P:8501::initialize music data offset for square 2
P:8505::initialize alternate control reg data used by square 1
P:8508::disable triangle channel and reenable it
P:851E:HandleSquare2Music:decrement square 2 note length
P:8521::is it time for more data?  if not, branch to end tasks
P:8523::increment square 2 music offset and fetch data
P:8529::if zero, the data is a null terminator
P:852B::if non-negative, data is a note
P:852D::otherwise it is length data
P:852F:EndOfMusicData:check secondary buffer for time running out music
P:8536::load previously saved contents of primary buffer
P:8539::and start playing the song again if there is one
P:853B:NotTRO:check for victory music (the only secondary that loops)
P:853F::check primary buffer for any music except pipe intro
P:8543::if any area music except pipe intro, music loops
P:8545::clear primary and secondary buffers and initialize
P:8547::control regs of square and triangle channels
P:8558:MusicLoopBack
P:855B:VictoryMLoopBack
P:855E:Rest:lda Squ2_EnvelopeDataCtrl
P:8561:Squ2LengthHandler:store length of note
P:8567::fetch another byte (MUST NOT BE LENGTH BYTE!)
P:856D:Squ2NoteHandler:is there a sound playing on this channel?
P:8571::no, then play the note
P:8574::check to see if note is rest
P:8576::if not, load control regs for square 2
P:8579::save contents of A
P:857C::dump X and Y into square 2 control regs
P:857F:SkipFqL1:save length in square 2 note counter
P:8585:MiscSqu2MusicTasks:is there a sound playing on square 2?
P:8589::check for death music or d4 set on secondary buffer
P:858C::note that regs for death music or d4 are loaded by default
P:8590::check for contents saved from LoadControlRegs
P:8595::decrement unless already zero
P:8598:NoDecEnv1:do a load of envelope data to replace default
P:859B::based on offset set by first load unless playing
P:859E::death music or d4 set on secondary buffer
P:85A3:HandleSquare1Music:is there a nonzero offset here?
P:85A5::if not, skip ahead to the triangle channel
P:85A7::decrement square 1 note length
P:85AA::is it time for more data?
P:85AC:FetchSqu1MusicData:increment square 1 music offset and fetch data
P:85B2::if nonzero, then skip this part
P:85B6::store some data into control regs for square 1
P:85B9::and fetch another byte of data, used to give
P:85BB::death music its unique sound
P:85C1::unconditional branch
P:85C3:Squ1NoteHandler
P:85C6::save contents of A in square 1 note counter
P:85C9::is there a sound playing on square 1?
P:85CE::change saved data to appropriate note format
P:85D0::play the note
P:85D8:SkipCtrlL:save envelope offset
P:85DE:MiscSqu1MusicTasks:is there a sound playing on square 1?
P:85E2::check for death music or d4 set on secondary buffer
P:85E9::check saved envelope offset
P:85EE::decrement unless already zero
P:85F1:NoDecEnv2:do a load of envelope data
P:85F4::based on offset set by first load
P:85F7:DeathMAltReg:check for alternate control reg data
P:85FC::load this value if zero, the alternate value
P:85FE:DoAltLoad:if nonzero, and let's move on
P:8601:HandleTriangleMusic
P:8603::decrement triangle note length
P:8606::is it time for more data?
P:8608::increment square 1 music offset and fetch data
P:860E::if zero, skip all this and move on to noise 
P:8610::if non-negative, data is note
P:8612::otherwise, it is length data
P:8615::save contents of A
P:861A::load some default data for triangle control reg
P:861D::fetch another byte
P:8623::check once more for nonzero data
P:8625:TriNoteHandler
P:8628::save length in triangle note counter
P:8631::check for death music or d4 set on secondary buffer
P:8633::if playing any other secondary, skip primary buffer check
P:8635::check primary buffer for water or castle level music
P:8639::if playing any other primary, or death or d4, go on to noise routine
P:863B:NotDOrD4:if playing water or castle music or any secondary
P:863C::besides death music or d4 set, check length of note
P:8640::check for win castle music again if not playing a long note
P:8647::load value $0f if playing the win castle music and playing a short
P:8649::note, load value $1f if playing water or castle level music or any
P:864B:MediN:secondary besides death and d4 except win castle or win castle and playing
P:864D::a short note, and load value $ff if playing a long note on water, castle
P:864F:LongN:or any secondary (including win castle) except death and d4
P:8651:LoadTriCtrlReg:save final contents of A into control reg for triangle
P:8654:HandleNoiseMusic:check if playing underground or castle music
P:8658::if so, skip the noise routine
P:8660::decrement noise beat length
P:8663::is it time for more data?
P:8665:FetchNoiseBeatData:increment noise beat offset and fetch data
P:866B::get noise beat data, if nonzero, branch to handle
P:866F::if data is zero, reload original noise beat offset
P:8672::and loopback next time around
P:8675::unconditional branch
P:8677:NoiseBeatHandler
P:867A::store length in noise beat counter
P:867E::reload data and erase length bits
P:8680::if no beat data, silence
P:8682::check the beat data and play the appropriate
P:8684::noise accordingly
P:868E::short beat data
P:8696:StrongBeat:strong beat data
P:869E:LongBeat:long beat data
P:86A6:SilentBeat:silence
P:86A8:PlayBeat:load beat data into noise regs
P:86B1:ExitMusicHandler
P:86B2:AlternateLengthHandler:save a copy of original byte into X
P:86B3::save LSB from original byte into carry
P:86B4::reload original byte and rotate three times
P:86B5::turning xx00000x into 00000xxx, with the
P:86B6::bit in carry as the MSB here
P:86B8:ProcessLengthData:clear all but the three LSBs
P:86BB::add offset loaded from first header byte
P:86BD::add extra if time running out music
P:86C1::load length
P:86C5:LoadControlRegs:check secondary buffer for win castle music
P:86CC::this value is only used for win castle music
P:86CE::unconditional branch
P:86D0:NotECstlM
P:86D2::check primary buffer for water music
P:86D6::this is the default value for all other music
P:86DA:WaterMus:this value is used for water music and all other event music
P:86DC:AllMus:load contents of other sound regs for square 2
P:86E1:LoadEnvelopeData:check secondary buffer for win castle music
P:86E8::load data from offset for win castle music
P:86EC:LoadUsualEnvData:check primary buffer for water music
P:86F2::load default data from offset for all other music
P:86F6:LoadWaterEventMusEnvData:load data from offset for water music and all other event music
P:86FA:_StopSquare2Sfx
P:86FE::keep only the dmc bit
P:8700::stop playing the sfx
P:8704:: write #$d to lower nibble
P:8709:: write #$f to lower nibble
P:870D:_StopSquare1Sfx:if end of sfx reached, clear buffer
P:870F::and stop making the sfx
P:8715::keep only the dmc bit
P:8717::stop making the sfx
P:8723:MusicHeaderData:--------------------------------\nmusic header offsets\nstarts from 01 (or 00)\n01 - event music
P:8724::02
P:8725::03
P:8726::04
P:8727::05
P:8728::06
P:8729::07
P:872A::08
P:872B::09 - area music
P:872C::0a
P:872D::0b
P:872E::0c
P:872F::0d
P:8730::0e
P:8731::0f
P:8732::10
P:8733::12 - ground level music layout
P:8734::13 (13-14)
P:8736::14	(15-18)
P:873A::15	(19-1c)
P:873E::16	(1d-20)
P:8742::17	(21-22)
P:8744::18	(23-26)
P:8748::19	(27-2a)
P:874C::1a	(2b-2e)
P:8750::1b	(2f-32)
P:8754::32
P:8755:TimeRunningOutHdr:music headers\nheader format is as follows: \n1 byte - length byte offset\n2 bytes -  music data address\n1 byte - triangle data offset\n1 byte - square 1 data offset\n1 byte - noise data offset (not used by secondary music)\n01
P:875A:Star_CloudHdr:02
P:8760:EndOfLevelMusHdr:03
P:8765:ResidualHeaderData:04
P:876A:UndergroundMusHdr:05
P:876F:SilenceHdr:06
P:8773:CastleMusHdr:07
P:8778:VictoryMusHdr:08
P:877D:GameOverMusHdr:09
P:8782:WaterMusHdr:0a
P:8788:WinCastleMusHdr:0b
P:878D:GroundLevelPart1Hdr:0c
P:8793:GroundLevelPart2AHdr:0d
P:8799:GroundLevelPart2BHdr:0e
P:879F:GroundLevelPart2CHdr:0f
P:87A5:GroundLevelPart3AHdr:10
P:87AB:GroundLevelPart3BHdr:11
P:87B1:GroundLevelLeadInHdr:12
P:87B7:GroundLevelPart4AHdr:13
P:87BD:GroundLevelPart4BHdr:14
P:87C3:GroundLevelPart4CHdr:15
P:87C9:DeathMusHdr:16
P:87CF:PSwitchMusHdr:17
P:87D4:Star_CloudMData:--------------------------------\nMUSIC DATA\nsquare 2/triangle format\nd7 - length byte flag (0-note, 1-length)\nif d7 is set to 0 and d6-d0 is nonzero:\nd6-d0 - note offset in frequency look-up table (must be even)\nif d7 is set to 1:\nd6-d3 - unused\nd2-d0 - length offset in length look-up table\nvalue of $00 in square 2 data is used as null terminator, affects all sound channels\nvalue of $00 in triangle data causes routine to skip note\nsquare 1 format\nd7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)\nd5-d1 - note offset in frequency look-up table\nvalue of $00 in square 1 data is flag alternate control reg data to be loaded\nnoise format\nd7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)\nd5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)\nd3-d1 - unused\nvalue of $00 in noise data is used as null terminator, affects only noise\nall music data is organized into sections (unless otherwise stated):\nsquare 2, square 1, triangle, noise
P:881D:GroundM_P1Data
P:8838:SilenceData
P:8865:GroundM_P2AData
P:8891:GroundM_P2BData
P:88B9:GroundM_P2CData
P:88DE:GroundM_P3AData
P:88F7:GroundM_P3BData
P:890B::triangle data used by both sections of third part
P:8915:GroundMLdInData
P:8936::noise data used by lead-in and third part sections
P:8941:GroundM_P4AData
P:8967:GroundM_P4BData
P:898E:DeathMusData:death music share data with fourth part c of ground level music 
P:8990:GroundM_P4CData
P:899D::death music only
P:89AC::death music only
P:89BB::noise data used by fourth part sections
P:89C0:CastleMusData
P:8A61:GameOverMusData
P:8A8E:TimeRunOutMusData
P:8ACC:WinLevelMusData
P:8B08::unused byte
P:8B2D:UndergroundMusData:square 2 and triangle use the same data, square 1 is unused
P:8B6E:WaterMusData:noise data directly follows square 2 here unlike in other songs
P:8C6D:EndOfCastleMusData
P:8CE4:VictoryMusData
P:8D19:PSwitch:SQ2
P:8D5D::TRI  ;44
P:8D8E::SQ1  ;75
P:8DBE::af
P:8DC4:FreqRegLookupTbl
P:8E2A:MusicLengthLookupTbl
P:8E5A:EndOfCastleMusicEnvData
P:8E5E:AreaMusicEnvData
P:8E66:WaterEventMusEnvData
P:8E8E:BowserFlameEnvData
P:8EAE:BrickShatterEnvData
P:8EBE::include "D:\random\.disasembly w\smbdis mmc3\famitone\famitone2_asm6.asm"\ninclude "D:\random\.disasembly w\smbdis mmc3\famitone\tools\music.asm"\ninclude "D:\random\.disasembly w\smbdis mmc3\famitone\tools\sfx.asm"\n	----------------------------------------------------------------------------------------------------------------\n	ALL OF THIS CODE BELONGS TO STUDSX\n----------------------------------------------------------------------------------------------------------------\nCustomAudioInit 		EQU FamiToneInit\n	CustomAudioSfxInit 		EQU FamiToneSfxInit\n	CustomAudioSfxPlay 		EQU FamiToneSfxPlay\n	CustomAudioMusicPlay 	EQU FamiToneMusicPlay\n	CustomAudioMusicPause 	EQU FamiToneMusicPause\n	CustomAudioUpdate 		EQU FamiToneUpdate\n	SFX_CH0 EQU FT_SFX_CH0\n	SFX_CH1 EQU FT_SFX_CH1\n	SFX_CH2 EQU FT_SFX_CH2\n	SFX_CH3 EQU FT_SFX_CH3\n					;Enter music number here (Famitracker music number - 1)\n\nGroundMus        =	0\nWaterMus         =  1\nCaveMus          =  2\nCastleMus        =  3\nCloudMus         =  4\nPipeMus          =  5\nStarmanMus       =  6\nDeathMus         =  7\nGameOverMus      =  8\nPrincessMus      =  9\nCastleFinishMus  =  10\nLevelFinishMus   =  11\nHurryMus         =  12\n\nMusicLUT:\n		.db GroundMus, WaterMus, CaveMus, CastleMus, CloudMus, PipeMus, StarmanMus,	-1\n		.db DeathMus, GameOverMus, PrincessMus, CastleFinishMus, 0, LevelFinishMus, HurryMus, -1\n\nBRICK = 1		-1\nBREATH = 2		-1\nCOIN = 3		-1\nGROWPU = 4		-1\nVINE = 5		-1\nBLAST = 6		-1\nTIMER = 7		-1\nGROW = 8		-1\nEXTRALIFE = 9	-1\nBOWS_FALL = 10	-1\nBJUMP = 11		-1\nBUMP = 12		-1\nSTOMP = 13		-1\nSMACK = 14		-1\nINJURY = 15		-1\nFIREBALL = 16	-1\nFLAGPOLE = 17	-1\nSJUMP = 18		-1\nPAUSE_= 19		-1\n\n\nnoise_sfx_table:\n			.db BRICK      , SFX_CH2\n			.db BREATH     , SFX_CH2\n			.db PAUSE_	   , SFX_CH3 ;put pause here cuz i can	   \n			\nsq2_sfx_table:	           \n			.db COIN       , SFX_CH1\n			.db GROWPU     , SFX_CH1\n			.db VINE       , SFX_CH1\n			.db BLAST      , SFX_CH1\n			.db TIMER      , SFX_CH1\n			.db GROW       , SFX_CH1\n			.db EXTRALIFE  , SFX_CH3\n			.db BOWS_FALL  , SFX_CH1\n\nsq1_sfx_table:             \n			.db BJUMP      , SFX_CH0\n			.db BUMP       , SFX_CH0\n			.db STOMP      , SFX_CH0\n			.db SMACK      , SFX_CH0\n			.db INJURY     , SFX_CH0\n			.db FIREBALL   , SFX_CH0\n			.db FLAGPOLE   , SFX_CH0\n			.db SJUMP      , SFX_CH0\n		\nCustomMusicEngine:\n		lda GamePauseStatus\n		bmi +\n		and #$01\n		ora SettingsBits\n		jsr FamiToneMusicPause\n+:\n		lda EventMusicQueue\n		ora AreaMusicQueue\n		beq NoTrigger\n		lda AreaMusicQueue\n		beq +\n		sta AreaMusicBuffer\n		ldx #-1\n		-\n		inx\n		lsr\n		bcc -\n		ldy #0\n		sty AreaMusicQueue\n		+\n		lda EventMusicQueue\n		beq +\n		sta EventMusicBuffer\n		ldx #7\n		-\n		inx\n		lsr\n		bcc -\n		ldy #0\n		sty EventMusicQueue\n		+\n		lda MusicLUT,x\n		pha\n		ldx #<music_music_data\n		ldy #>music_music_data\n		lda #1\n		sta songPlaying\n		jsr CustomAudioInit\n		ldx #<sounds\n		ldy #>sounds\n		jsr CustomAudioSfxInit\n		pla\n		jsr CustomAudioMusicPlay\nNoTrigger:\n		lda Square2SoundQueue\n		beq noSQ2\n		jsr countBITS_asl\n		lda sq2_sfx_table,y\n		ldx sq2_sfx_table+1,y\n		jsr CustomAudioSfxPlay\n		lda #0\n		sta Square2SoundQueue\nnoSQ2:\n		lda Square1SoundQueue\n		beq noSQ1\n		jsr countBITS_asl\n		lda sq1_sfx_table,y\n		ldx sq1_sfx_table+1,y\n		jsr CustomAudioSfxPlay\n		lda #0\n		sta Square1SoundQueue\nnoSQ1:\n		lda NoiseSoundQueue\n		beq noNOI\n		jsr countBITS_asl\n		lda noise_sfx_table,y\n		ldx noise_sfx_table+1,y\n		jsr CustomAudioSfxPlay\n		lda #0\n		sta NoiseSoundQueue\nnoNOI:\n		jmp CustomAudioUpdate\n\ncountBITS_asl:\n			ldx #$ff\n			sec\n			-\n			inx\n			ror\n			bcc -\n			txa\n			asl\n			tay\n			rts\n			\nCustomMusicLoopCallback:\n	lda #0\n	sta songPlaying\n	lda EventMusicBuffer\n	cmp #$40\n	bne +\n	lda #0\n	sta EventMusicBuffer\n	lda AreaMusicBuffer\n	sta AreaMusicQueue\n	+\n	rts
P:C000:: bank 03 -- self-contained core routines\n bank identifier
P:C001:_WipePlayerData: handle management of player data\n $00\n $01\n use like this:\n    ; copy Hidden1UpFlag from on screen player to all offscreen players\n    lda Hidden1UpFlag-OnscreenPlayerInfo\n    jsr CopyToAllPlayers
P:C014:_CopyToAllPlayers:tay
P:C022:: add stored offset
P:C028:: use this for the high byte now
P:C035:_SavePlayerData
P:C04A:_LoadPlayerData
P:C05F:_ReadJoypads:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00 - temp joypad bit
P:C06A::reset and clear strobe of joypad ports
P:C070::start with joypad 1's port
P:C074:ReadPortBits:jsr ReadPortBits\ninx                   ;increment for joypad 2's port
P:C076:PortLoop:push previous bit onto stack
P:C077::read current bit on joypad port
P:C07A::check d1 and d0 of port output
P:C07C::this is necessary on the old
P:C07D::famicom systems in japan
P:C080::read bits from stack
P:C081::rotate bit from carry flag
P:C083::count down bits left
P:C085::save controller status here always
P:C088::              pha\n              and #%00110000         ;check for select or start\n              and JoypadBitMask,x    ;if neither saved state nor current state\n              beq Save8Bits          ;have any of these two set, branch\n              pla\n              and #%11001111         ;otherwise store without select\n              sta SavedJoypadBits,x  ;or start bits and leave\n              rts\nSave8Bits:    pla\nsave with all bits in another place and leave
P:C08C:D7_Attributes:-------------------------------------------------------------------------------------
P:C0A5:_InitializeNameTables:reset flip-flop
P:C0A8::load mirror of ppu reg $2000
P:C0AB::set sprites for first 4k and background for second 4k
P:C0AD::clear rest of lower nybble, leave higher alone
P:C0AF::write contents of A to PPU register 1
P:C0B2::and its mirror
P:C0B5::set vram address to start of name table 1
P:C0BA::set vram address to start of name table 2
P:C0C4::and then set it to name table 0
P:C0C6:WriteNTAddr
P:C0CE::clear name table with blank tile #24
P:C0D4:InitNTLoop:count out exactly 768 tiles
P:C0DD::now to clear the attribute table (with zero this time)
P:C0E0::init vram buffer 1 offset
P:C0E3::init vram buffer 1
P:C0E8:InitATLoop
P:C0F0::reset scroll variables
P:C0F6::initialize scroll registers to zero
P:C0F9:DemoActionData:-------------------------------------------------------------------------------------
P:C10E:DemoTimingData
P:C124:_DemoEngine:load current demo action
P:C127::load current action timer
P:C12A::if timer still counting down, skip
P:C12D::if expired, increment action, X, and
P:C130::set carry by default for demo over
P:C131::get next timer
P:C134::store as current timer
P:C137::if timer already at zero, skip
P:C139:DoAction:get and perform action (current or next)
P:C13F::decrement action timer
P:C142::clear carry if demo still going
P:C143:DemoOver
P:10000:: bank 04 -- level decode routines\n bank identifier
P:1000E:WorldNumberOffset:load level stuff\n Subtroutines that involve level loading\n AreaParserTaskHandler\n AreaParserTasks\n AreaParserCore\n IncrementColumnPos\n RenderAreaGraphics\n ProcessAreaData\n DecodeAreaData\n AlterAreaAttributes\n GetLrgObjAttrib\n\n GetAreaDataAddrs\n
P:10017:BankLevelOffset
P:10017:W1
P:1001C:W2
P:10021:W3
P:10025:W4
P:10029:W5
P:1002D:W6
P:10031:W7
P:10036:W8
P:1003A:W9
P:1003F:LoadAreaPointerR
P:1005E::replace for adc to enable
P:10063::find it and store it here
P:10069:GetAreaType:mask out all but d6 and d5
P:1006E::mask out all but d6 and d5\nmake %0xx00000 into %000000xx\nsave 2 MSB as area type
P:10072:FindAreaPointer:load offset from world variable
P:10075::and #%00000111
P:10079::add area number used to find data
P:1007E::from there we have our area pointer
P:10082:GetAreaDataAddrsR
P:1009F::use 2 MSB for Y
P:100A6::mask out all but 5 LSB
P:100AB::save as low offset
P:100AE::load base value with 2 altered MSB,
P:100B1::then add base value to 5 LSB, result
P:100B2::becomes offset for level data
P:100B6::use offset to load pointer
P:100C0:: fix the pointers to match original file\nuse area type as offset
P:100C3::do the same thing but with different base value
P:100CB::use this offset to load another pointer
P:100D5:: fix the pointers to match original file\nload first byte of header
P:100D9::save it to the stack for now
P:100DA::save 3 LSB for foreground scenery or bg color control
P:100E0::if 4 or greater, save value here as bg color control
P:100E5:StoreFore:if less, save value here as foreground scenery
P:100E8::pull byte from stack and push it back
P:100EA::save player entrance control bits
P:100EC::shift bits over to LSBs
P:100EF::save value here as player entrance control
P:100F2::pull byte again but do not push it back
P:100F3::save 2 MSB for game timer setting
P:100F6::rotate bits over to LSBs
P:100F9::save value here as game timer setting
P:100FD::load second byte of header
P:100FF::save to stack
P:10100::mask out all but lower nybble
P:10105::pull and push byte to copy it to A
P:10107::save 2 MSB for background scenery type
P:1010A::shift bits to LSBs
P:1010D::save as background scenery
P:10114::rotate bits over to LSBs
P:10117::if set to 3, store here
P:10119::and nullify other value
P:1011B::otherwise store value in other place
P:10120:StoreStyle
P:10123::increment area data address by 2 bytes
P:10131:BrickQBlockMetatiles1:used by question blocks
P:10135::these two sets are functionally identical, but look different\n, $70, $6f, $c4, $72 ;used by ground level types
P:1013C::, $71, $6f, $c4, $72 ;used by other level types
P:10143:MetatileGraphics_Low
P:10147:MetatileGraphics_High
P:1014B:Palette0_MTiles:blank 00
P:1014F::.db $a5, $a7, $a6, $a8 ;blank coin sprite\n.db $24, $24, $24, $24 ;blank\nblack metatile 01
P:10153::bush left 02
P:10157::bush middle 03
P:1015B::bush right 04
P:1015F::mountain left 05
P:10163::mountain left bottom/middle center 06
P:10167::mountain middle top 07
P:1016B::mountain right 08
P:1016F::mountain right bottom 09
P:10173::mountain middle bottom 0a
P:10177::bridge guardrail 0b
P:1017B::chain 0c
P:1017F::tall tree top, top half 0d
P:10183::short tree top 0e
P:10187::tall tree top, bottom half 0f
P:1018B::warp pipe end left, points up 10
P:1018F::warp pipe end right, points up 11
P:10193::decoration pipe end left, points up 12
P:10197::decoration pipe end right, points up 13
P:1019B::pipe shaft left 14
P:1019F::pipe shaft right 15
P:101A3::tree ledge left edge 16
P:101A7::tree ledge middle 17
P:101AB::tree ledge right edge 18
P:101AF::mushroom left edge 19
P:101B3::mushroom middle 1a
P:101B7::mushroom right edge 1b
P:101BB::sideways pipe end top 1c
P:101BF::sideways pipe shaft top 1d
P:101C3::sideways pipe joint top 1e
P:101C7::sideways pipe end bottom 1f
P:101CB::sideways pipe shaft bottom 20
P:101CF::sideways pipe joint bottom 21
P:101D3::seaplant 22
P:101D7::blank, used on bricks or blocks that are hit 23
P:101DB::flagpole ball 24
P:101DF::flagpole shaft 25
P:101E3::vine 26
P:101E7::breakable brick w/ line 27
P:101EB::breakable brick 28
P:101EF::hidden block (1 coin) 29
P:101F3::hidden block (1-up) 2a
P:101F7::hidden block (power-up) 2b
P:101FB::decoration pipe end left, points down 2c
P:101FF::decoration pipe end right, points down 2d
P:10203::warp pipe end left, points down 2e
P:10207::warp pipe end right, points down 2f
P:1020B::hidden block (star) 30
P:1020F::brick (power-up) 31
P:10213::brick (vine) 32
P:10217::brick (star) 33
P:1021B::brick (coins) 34
P:1021F::brick (1-up) 35
P:10223::sideways pipe end top 36
P:10227::sideways pipe end bottom 37
P:1022B::hidden block (1 coin) 38
P:1022F::hidden block (1-up) 39
P:10233::hidden block (power-up) 3a
P:10237::hidden block (star) 3b
P:1023B::brick (coin) 3c
P:1023F::pipe shaft right 3d
P:10243::sideways pipe shaft bottom 3e
P:10247:Palette1_MTiles:vertical rope 40
P:1024B::horizontal rope 41
P:1024F::left pulley 42
P:10253::right pulley 43
P:10257::blank used for balance rope 44
P:1025B::castle top 45
P:1025F::castle window left 46
P:10263::castle brick wall 47
P:10267::castle window right 48
P:1026B::castle top w/ brick 49
P:1026F::entrance top 4a
P:10273::entrance bottom 4b
P:10277::green ledge stump 4c
P:1027B::fence 4d
P:1027F::tree trunk 4e
P:10283::mushroom stump top 4f
P:10287::mushroom stump bottom 50
P:1028B::breakable brick w/ line 51  
P:1028F::breakable brick 52
P:10293::breakable brick (not used) 53
P:10297::cracked rock terrain 54
P:1029B::brick with line (power-up) 55
P:1029F::brick with line (vine) 56
P:102A3::brick with line (star) 57
P:102A7::brick with line (coins) 58
P:102AB::brick with line (1-up) 59
P:102AF::brick (power-up) 5a
P:102B3::brick (vine) 5b
P:102B7::brick (star) 5c
P:102BB::brick (coins) 5d
P:102BF::brick (1-up) 5e
P:102C3::hidden block (1 coin) 5f
P:102C7::hidden block (1-up) 60
P:102CB::solid block (3-d block) 61
P:102CF::solid block (white wall) 62
P:102D3::bridge 63
P:102D7::bullet bill cannon barrel 64
P:102DB::bullet bill cannon top 65
P:102DF::bullet bill cannon bottom 66
P:102E3::blank used for jumpspring 67
P:102E7::half brick used for jumpspring 68
P:102EB::solid block (water level, green rock) 69
P:102EF::half brick (???) 6a
P:102F3::water pipe top 6b
P:102F7::water pipe bottom 6c
P:102FB::flag ball (residual object) 6d
P:102FF::yoquse 6e
P:10303::hidden block (power-up) 6f
P:10307::castle stop 70
P:1030B::slope 71
P:1030F::p-block 72
P:10313::hidden block (star) 73
P:10317::anticheese bumpable block 74
P:1031B:Palette2_MTiles:cloud left 80
P:1031F::cloud middle 81 
P:10323::cloud right 82 
P:10327::cloud bottom left 83
P:1032B::cloud bottom middle 84
P:1032F::cloud bottom right 85
P:10333::water/lava top 86
P:10337::water/lava 87
P:1033B::cloud level terrain 88
P:1033F::bowser's bridge 89
P:10343::spikes 8a
P:10347::noteblock 8b
P:1034B::p-switch 8c
P:1034F::on off switch 8d
P:10353::on off block 8e
P:10357::on off block (on) 8f
P:1035B::water/lava top swimmable 90
P:1035F::water/lava swimmable 91
P:10363::door 92
P:10367:Palette3_MTiles:question block (coin) c0
P:1036B::question block (power-up) c1
P:1036F::coin c2
P:10373::underwater coin c3
P:10377::empty block c4
P:1037B::axe c5
P:1037F::question block (star) c6
P:10383::question block (1up) c7
P:10387::sideways pipe shaft top c8
P:1038B::sideways pipe joint top c9
P:1038F::sideways pipe shaft bottom ca
P:10393::sideways pipe joint bottom cb
P:10397::decoration pipe end left, points up cc
P:1039B::decoration pipe end right, points up cd
P:1039F::pipe shaft left ce
P:103A3::pipe shaft right cf
P:103A7::decoration pipe end left, points down d0
P:103AB::decoration pipe end right, points down d1
P:103AF::w3 star d2
P:103B3::w3 star d3
P:103B7::w3 star d4
P:103BB::w3 star d5
P:103BF::w4,7 sand d6
P:103C3::pipe shaft right d7
P:103C7::sideways pipe shaft bottom d8
P:103CB::w4 palmtree 1 d9
P:103CF::w4 palmtree 2 da
P:103D3::w4 palmtree 3 db
P:103D7::sideways pipe end top dc
P:103DB::sideways pipe end bottom dd
P:103DF::w5 cloud block de
P:103E3::w5 cloud ledge left edge df
P:103E7::w5 cloud ledge middle e0
P:103EB::w5 cloud ledge right edge e1
P:103EF::w6 snow ground e2
P:103F3::w6 snow ground bottom e3
P:103F7::w6 snow ground bottom (hurts) e4
P:103FB::w6 snow ground bottom (no collision) e5
P:103FF::w7 desert sea plant e6
P:10403::w7 tree trunk top e7
P:10407::w7 solid block (3-d block) pal0 e8
P:1040B::w7 castle top pal0 e9
P:1040F::w7 castle window left pal0 ea
P:10413::w7 castle brick wall pal0 eb
P:10417::w7 castle window right pal0 ec
P:1041B::w7 castle top w/ brick pal0 ed
P:1041F::w7 entrance top pal0 ee
P:10423::w7 entrance bottom pal0 ef
P:10427::w7 castle stop pal0 f0
P:1042B::w7 fence pal0 f1
P:1042F:AreaParserTaskHandler:-------------------------------------------------------------------------------------\nVRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM
P:10472::check number of tasks here
P:10475::if already set, go ahead
P:10477::ldy Player_X_Scroll\nbmi SkipATRender
P:10479::otherwise, set eight by default
P:1047C:DoAPTasks
P:10481::if all tasks not complete do not
P:10484::render attribute table yet
P:1048E:SkipATRender
P:1048F:AreaParserTasks:dec AreaParserTaskNum\nlda AreaParserTaskNum\nrts
P:1048F:NoThing
P:104A6:RenderAreaGraphics
P:104B0:NoSkipATRender:store LSB of where we're at
P:104BE::store vram buffer offset
P:104C3::get current name table address we're supposed to render
P:104E6:ExitDrawM1
P:104FA:@bru
P:1050A::store length byte of 26 here with d7 set
P:1050C::to increment by 32 (in columns)
P:1050F::init attribute row
P:10514:DrawMTLoop:store init value of 0 or incremented offset for buffer
P:1052F::get first metatile number, and mask out all but 2 MSB
P:10531::cmp #$10\nbeq ++\ncmp #$12\nbne +\npha\nlda AreaParserTaskNum        ;get current task number for level processing and\neor olddirscroll\nand #%00000001  \njmp ++\njsr FindEmptyEnemySlot   ;check for an empty moving data buffer space\n  bcs ++             ;if not found, too many enemies, thus skip\n  lda $fa\n  sub #$66\n; tay\nlda $ff\nand #$0f\nasl\nasl\nasl\nasl\nclc\nadc #$08                 ;add eight to put the piranha plant in the center\nsta Enemy_X_Position,x   ;store as enemy's horizontal coordinate\ntya\nadc #$00\nsta Enemy_PageLoc,x      ;store as enemy's page coordinate\nlda #$01\nsta Enemy_Y_HighPos,x\nsta Enemy_Flag,x         ;activate enemy flag\nlda $02  					;get piranha plant's vertical coordinate and store here\nand #$f0\nclc\nadc #$20\nsta Enemy_Y_Position,x\nlda #PiranhaPlant\nsta Enemy_ID,x\njsr InitPiranhaPlant1\nldy $02\npla
P:10535::sta $03                      ;store attribute table bits here\nnote that metatile format is:
P:10536::%xx000000 - attribute table bits, 
P:10537::%00xxxxxx - metatile number
P:10538::rotate bits to d1-d0 and use as offset here
P:10539::get address to graphics table from here
P:10552::get metatile number again
P:10553::multiply by 4 and use as tile offset
P:1055A::get current task number for level processing and
P:10560::mask out all but LSB, then invert LSB, multiply by 2
P:10562::eor #%00000001               ;to get the correct column position in the metatile,\nthen add to the tile offset so we can draw either side
P:10563::of the metatiles
P:10566::use vram buffer offset from before as X
P:1056A::get first tile number (top left or top right) and store
P:1056E::now get the second (bottom left or bottom right) and store
P:10573::get current attribute row
P:10575::get LSB of current column where we're at, and
P:10577::branch if set (clear = left attrib, set = right)
P:10579::get current row we're rendering
P:1057B::branch if LSB set (clear = top left, set = bottom left)
P:1057E::rotate attribute bits 3 to the left
P:10580::thus in d1-d0, for upper left square
P:10587:RightCheck:get LSB of current row we're rendering
P:10589::branch if set (clear = top right, set = bottom right)
P:1058C::shift attribute bits 4 to the right
P:1058E::thus in d3-d2, for upper right square
P:10597:DrawMTLoop1
P:1059A:LLeft:shift attribute bits 2 to the right
P:1059C::thus in d5-d4 for lower left square
P:1059E:NextMTRow:move onto next attribute row  
P:105A0:SetAttrib:get previously saved bits from before
P:105A3::if any, and put new bits, if any, onto
P:105A5::the old, and store
P:105A8::increment vram buffer offset by 2
P:105AC::get current gfx buffer row, and check for
P:105AE::the bottom of the screen
P:105B1::if not there yet, loop back
P:105B3::get current vram buffer offset, increment by 3
P:105B5::(for name table address and length bytes)
P:105BA::put null terminator at end of data for name table
P:105BD::store new buffer offset
P:105D5::increment name table address low
P:105D8::check current low byte
P:105DB::if no wraparound, just skip this part
P:105DF::if wraparound occurs, make sure low byte stays
P:105E1::just under the status bar
P:105E4::and then invert d2 of the name table address high
P:105E7::to move onto the next appropriate name table
P:105EC:ExitDrawM:jump to set buffer to $0341 and leave
P:105EF:RenderAttributeTables:-------------------------------------------------------------------------------------\n$00 - temp attribute table address high (big endian order this time!)\n$01 - temp attribute table address low\nget low byte of next name table address
P:105F2::to be written to, mask out all but 5 LSB,
P:105FC::subtract four 
P:105FF::mask out bits again and store
P:10603::get high byte and branch if borrow not set
P:10608::otherwise invert d2
P:1060A:SetATHigh:mask out all other bits
P:1060C::add $2300 to the high byte and store
P:10610::get low byte - 4, divide by 4, add offset for
P:10612::attribute table and store
P:10614::we should now have the appropriate block of
P:10616::attribute table in our temp address
P:1061A::get buffer offset
P:1061D:AttribLoop
P:1061F::store high byte of attribute table address
P:10624::get low byte, add 8 because we want to start
P:10625::below the status bar, and store
P:1062A::also store in temp again
P:1062C::fetch current attribute table byte and store
P:1062F::in the buffer
P:10634::store length of 1 in buffer
P:10638::clear current byte in attribute buffer
P:1063B::increment buffer offset by 4 bytes
P:1063F::increment attribute offset and check to see
P:10640::if we're at the end yet
P:10644::put null terminator at the end
P:10647::store offset in case we want to do any more
P:1064A:SetVRAMCtrl
P:1064C::set buffer to $0341 and leave
P:10650::-------------------------------------------------------------------------------------
P:1066E:IncrementColumnPosS:increment column where we're at
P:10674::mask out higher nybble
P:10678::if no bits left set, wrap back to zero (0-f)
P:1067B::and increment page number where we're at
P:1067E::increment column offset where we're at
P:10682:IncrementColumnPos
P:1069F:oke1
P:106BA::inc CurrentColumnPos\nlda temp9\nbne +
P:106D9:DecrementColumnPos:inc ColumnSets\ndec CurrentNTAddr_Low
P:106E6::cmp #$00
P:106ED:oke
P:106F7:eadoek
P:1070A::cmp #$00
P:1070C:aeujh
P:10713::increment column where we're at
P:10726:BSceneDataOffsets:-------------------------------------------------------------------------------------\n$00 - used as counter, store for low nybble for background, ceiling byte for terrain\n$01 - used to store floor byte for terrain\n$07 - used to store terrain metatile\n$06-$07 - used to store block buffer address
P:10726:BackSceneryData
P:10726:BackSceneryMetatiles
P:10726:FSceneDataOffsets
P:10726:ForeSceneryData
P:10726:TerrainMetatiles
P:10726:TerrainRenderBits
P:10730:AreaParserCore
P:10741:AreaParserCoreS
P:10747::check to see if we are starting right of start
P:1074A::if not, go ahead and render background, foreground and terrain
P:1074C::otherwise skip ahead and load level data
P:1074F:RenderSceneryTerrain
P:10752:BlockBuffLowBounds:		  ldx #$0c\n          lda #$00\nClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer\n          dex\n          bpl ClrMTBuf\n          ldy BackgroundScenery      ;do we need to render the background scenery?\n          beq RendFore               ;if not, skip to check the foreground\n          lda CurrentPageLoc         ;otherwise check for every third page\nThirdP:   cmp #$03\n          bmi RendBack               ;if less than three we're there\n          sec\n          sbc #$03                   ;if 3 or more, subtract 3 and \n          bpl ThirdP                 ;do an unconditional branch\nRendBack: asl                        ;move results to higher nybble\n          asl\n          asl\n          asl\n          adc BSceneDataOffsets-1,y  ;add to it offset loaded from here\n          adc CurrentColumnPos       ;add to the result our current column position\n          tax\n          lda BackSceneryData,x      ;load data from sum of offsets\n          beq RendFore               ;if zero, no scenery for that part\n          pha\n          and #$0f                   ;save to stack and clear high nybble\n          sec\n          sbc #$01                   ;subtract one (because low nybble is $01-$0c)\n          sta $00                    ;save low nybble\n          asl                        ;multiply by three (shift to left and add result to old one)\n          adc $00                    ;note that since d7 was nulled, the carry flag is always clear\n          tax                        ;save as offset for background scenery metatile data\n          pla                        ;get high nybble from stack, move low\n          lsr\n          lsr\n          lsr\n          lsr\n          tay                        ;use as second offset (used to determine height)\n          lda #$03                   ;use previously saved memory location for counter\n          sta $00\nSceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3\n		  ;lda #$71\n          sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)\n          inx\n          iny\n          cpy #$0b                   ;if at this location, leave loop\n          beq RendFore\n          dec $00                    ;decrement until counter expires, barring exception\n          bne SceLoop1\nRendFore: ldx ForegroundScenery      ;check for foreground data needed or not\n          beq RendTerr               ;if not, skip this part\n          ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then\n          ldx #$00                   ;reinit X\nSceLoop2: lda ForeSceneryData,y      ;load data until counter expires\n          beq NoFore                 ;do not store if zero found\n          sta MetatileBuffer,x\nNoFore:   iny\n          inx\n          cpx #$0d                   ;store up to end of metatile buffer\n          bne SceLoop2\nRendTerr: ldy AreaType               ;check world type for water level\n          bne TerMTile               ;if not water level, skip this part\n          lda WorldNumber            ;check world number, if not world number eight\n          cmp #FinalWorld            ;then skip this part\n          bne TerMTile\n          lda #$6e                   ;if set as water level and world number eight,\n          jmp StoreMT                ;use castle wall metatile as terrain type\nTerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type\n          ldy CloudTypeOverride      ;check for cloud type override\n          beq StoreMT                ;if not set, keep value otherwise\n          lda #$88                   ;use cloud block terrain\nStoreMT:  sta $07                    ;store value here\n          ldx #$00                   ;initialize X, use as metatile buffer offset\n          lda TerrainControl         ;use yet another value from the header\n          asl                        ;multiply by 2 and use as yet another offset\n          tay\nTerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data\n          sta $00\n          iny                        ;increment Y and use as offset next time around\n          sty $01\n          lda CloudTypeOverride      ;skip if value here is zero\n          beq NoCloud2\n          cpx #$00                   ;otherwise, check if we're doing the ceiling byte\n          beq NoCloud2\n          lda $00                    ;if not, mask out all but d3\n          and #%00001000\n          sta $00\nNoCloud2: ldy #$00                   ;start at beginning of bitmasks\nTerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte\n          bit $00\n          beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)\n          lda $07\n          sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here\nNextTBit: inx                        ;continue until end of buffer\n          cpx #$0d\n          beq RendBBuf               ;if we're at the end, break out of this loop\n          lda AreaType               ;check world type for underground area\n          cmp #$02\n          bne EndUChk                ;if not underground, skip this part\n          cpx #$0b\n          bne EndUChk                ;if we're at the bottom of the screen, override\n          lda #$54                   ;old terrain type with ground level terrain type\n          sta $07\nEndUChk:  iny                        ;increment bitmasks offset in Y\n          cpy #$08\n          bne TerrBChk               ;if not all bits checked, loop back    \n          ldy $01\n          bne TerrLoop               ;unconditional branch, use Y to load next byte\nRendBBuf: jsr ProcessAreaData        ;do the area data loading routine now\n		  ldx #$00\n          ldy #$00                   ;init index regs and start at beginning of smaller buffer\nChkMTLow: sty $00\n          ;lda MetatileBuffer,x       ;load stored metatile number\n          ;and #%11000000             ;mask out all but 2 MSB\n          ;asl\n          ;rol                        ;make %xx000000 into %000000xx\n          ;rol\n		  ;tay\n		  rts\n          ldy MetatileBuffer,x       ;reload original unmasked value here\n		  lda MetatileThingy1,y\n		  bne +++\n		  ;lda #$c2\n		  ;bne ++++\n+++:	  lda MetatileBuffer,x\n++++:	  ldy $00                    ;get offset for block buffer\n		  sta ($fb),y                ;store value into block buffer\n+:        tya\n          clc                        ;add 16 (move down one row) to offset\n          adc #$10\n          tay\n          inx                        ;increment column value\n          cpx #$0d\n          bcc ChkMTLow               ;continue until we pass last row, then leave\n++:       rts\nnumbers lower than these with the same attribute bits\nwill not be stored in the block buffer\n.db $10, $51, $88, $c0\n-------------------------------------------------------------------------------------\n$00 - used to store area object identifier\n$07 - used as adder to find proper area object code
P:10752:RdyDecode1
P:10753:LevelBanks
P:10765:ProcessAreaData
P:10792:EndAParse
P:10793:BehindAreaIncrement:jmp ProcessAreaData \ndo things to get correct offset
P:10793:ProcessAreaData2
P:107BA::reset page select
P:107C3::reset page select
P:107C9:D3Bytes:inc AreaDataOffset\ninc AreaDataOffset
P:107C9:D4Bytes
P:107C9:IncAreaObjOffset
P:107CF::reset page select
P:107D4:XD
P:107D9:StarTable
P:107DD:DecodeAreaData
P:10855::run the object!
P:10858:StopFrenzy:s: scenery\nb: background\nj: change only background flag\n-------------------------------------------------------------------------------------\n(these apply to all area object subroutines in this section unless otherwise stated)\n$00 - used to store offset used to find object code\n$07 - starts with adder from area parser, used to store row offset
P:10860:AlterAreaAttributes:load offset for level object data saved in buffer
P:10863::load second byte
P:10866::save in stack for now
P:10869::branch if d6 is set
P:1086C::pull and push offset to copy to A
P:1086D::mask out high nybble and store as
P:1086F::new terrain height type bits
P:10873::pull and mask out all but d5 and d4
P:10875::move bits to lower nybble and store
P:10876::as new background scenery bits
P:10879::then leave
P:1087D:Alter2
P:1087E::mask out all but 3 LSB
P:10880::if four or greater, set color control bits
P:10882::and nullify foreground scenery bits
P:10889:SetFore:otherwise set new foreground scenery bits
P:1088D:ScrollLockObject_Warp:--------------------------------
P:108B1:ScrollLockObject
P:108CF:FrenzyIDData:--------------------------------\n$00 - used to store enemy identifier in KillEnemies\n--------------------------------
P:108D2:AreaFrenzy:use area object identifier bit as offset
P:108D4::note that it starts at 8, thus weird address here
P:108D9:FreCompLoop:check regular slots of enemy object buffer
P:108DA::if all slots checked and enemy object not found, branch to store
P:108DC::check for enemy object in buffer versus frenzy object
P:108E1::if enemy object already present, nullify queue and leave
P:108E3:ExitAFrenzy:store enemy into frenzy queue
P:108E7:AreaStyleObject:--------------------------------\n$06 - used by MushroomLedge to store length\nload level object style and jump to the right sub
P:108ED::also used for cloud type levels
P:108F3:TreeLedge:get row and length of green ledge
P:108F6::check length counter for expiration
P:108FE::store lower nybble into buffer flag as length of ledge
P:10904::are we at the start of the level?
P:10909::render start of tree ledge
P:1090E:MidTreeL
P:10910::render middle of tree ledge
P:10912::note that this is also used if ledge position is
P:10915::at the start of level for continuous effect
P:10917::now render the part underneath
P:1091A:EndTreeL:render end of tree ledge
P:1091F:MushroomLedge:get shroom dimensions
P:10922::store length here for now
P:10926::divide length by 2 and store elsewhere
P:1092D::render start of mushroom
P:10932:EndMushL:if at the end, render end of mushroom
P:10939::get divided length and store where length
P:1093C::was stored originally
P:10942::render middle of mushroom
P:10945::are we smack dab in the center?
P:10947::if not, branch to leave
P:1094C::render stem top of mushroom underneath the middle
P:10951:AllUnder
P:10952::set $0f to render all way down
P:10954::now render the stem of mushroom
P:10957:NoUnder:load row of ledge
P:10959::set 0 for no bottom on this part
P:1095E:PulleyRopeMetatiles:--------------------------------\ntiles used by pulleys and rope object
P:10961:PulleyRopeObject:get length of pulley/rope object
P:10964::initialize metatile offset
P:10966::if starting, render left pulley
P:10969::if not at the end, render rope
P:1096E::otherwise render right pulley
P:1096F:RenderPul
P:10972::render at the top of the screen
P:10975:MushLExit:and leave
P:10976:CastleMetatiles:--------------------------------\n$06 - used to store upper limit of rows for CastleObject
P:109AD:CastleObject:save lower nybble as starting row
P:109B0::if starting row is above $0a, game will crash!!! ok bummer
P:109BC::load length of castle if not already loaded
P:109C0::save obj buffer offset to stack
P:109C1::use current length as offset for castle data
P:109C4::begin at starting row
P:109C8::load upper limit of number of rows to print
P:109CA:CRendLoop:load current byte using offset
P:109D0::store in buffer and increment buffer offset
P:109D3::have we reached upper limit yet?
P:109D5::if not, increment column-wise
P:109D6::to byte in next row
P:109DA::move closer to upper limit
P:109DC:ChkCFloor:have we reached the row just before floor?
P:109DE::if not, go back and do another row
P:109E1::get obj buffer offset from before
P:109E5::if we're at page 0, we do not need to do anything else
P:109E7::check length
P:109EA::if length almost about to expire, put brick at floor
P:109EE::check starting row for tall castle ($00)
P:109F2::if found, then check to see if we're at the second column
P:109F6:NotTall:if not tall castle, check to see if we're at the third column
P:109F8::if we aren't and the castle is tall, don't create flag yet
P:109FB:PlayerStop:put brick at floor to stop player at end of level
P:109FD::this is only done if we're on the second column
P:10A00:ExitCastle
P:10A01:WaterPipe:--------------------------------\nget row and lower nybble
P:10A04::get length (residual code, water pipe is 1 col thick)
P:10A07::get row
P:10A0B::draw something here and below it
P:10A14:IntroPipe:--------------------------------\n$05 - used to store length of vertical shaft in RenderSidewaysPipe\n$06 - used to store leftover horizontal length in RenderSidewaysPipe\n and vertical length in VerticalPipe and GetPipeHeight\ncheck if length set, if not set, set it
P:10A19::set fixed value and render the sideways part
P:10A1E::if carry flag set, not time to draw vertical pipe part
P:10A20::blank everything above the vertical pipe part
P:10A22:VPipeSectLoop:all the way to the top of the screen
P:10A24::because otherwise it will look like exit pipe
P:10A2A::draw the end of the vertical pipe part
P:10A30:NoBlankP
P:10A31:SidePipeShaftData:used to control whether or not vertical pipe shaft
P:10A33::is drawn, and if so, controls the metatile number
P:10A35:SidePipeTopPart:top part of sideways part of pipe
P:10A39:SidePipeBottomPart:bottom part of sideways part of pipe
P:10A3D:SidePipeBottomPartW:bottom part of sideways part of pipe
P:10A41:ExitPipe:check if length set, if not set, set it
P:10A46::get vertical length, then plow on through RenderSidewaysPipe
P:10A49:RenderSidewaysPipe:decrement twice to make room for shaft at bottom
P:10A4A::and store here for now as vertical length
P:10A4D::get length left over and store here
P:10A52::get vertical length plus one, use as buffer offset
P:10A55::check for value $00 based on horizontal offset
P:10A58::cmp #$00\nif found, do not draw the vertical pipe shaft
P:10A5C::init buffer offset and get vertical length
P:10A5E::and render vertical shaft using tile number in A
P:10A61::clear carry flag to be used by IntroPipe
P:10A62:DrawSidePart:render side pipe part at the bottom
P:10A67::note that the pipe parts are stored
P:10A76::backwards horizontally
P:10A7D:VerticalPipeData:used by pipes that lead somewhere
P:10A81::used by decoration pipes
P:10A85::used by upside-down pipes
P:10A87::used by upside-down pipes (enterable)
P:10A89:VerticalPipeDataUW:used by pipes that lead somewhere
P:10A8D::used by decoration pipes
P:10A91::used by upside-down pipes
P:10A93::used by upside-down pipes (enterable)
P:10A95:VerticalPipe
P:10A9F::check to see if value was nullified earlier
P:10AA1::(if d3, the usage control bit of second byte, was set)
P:10AA6::add four if usage control bit was not set
P:10AA7:WarpPipe:save value in stack
P:10AAC::if at world 1-1, do not add piranha plant ever
P:10AB1::lda AreaType\nbeq DrawPipe
P:10AB6::if on second column of pipe, branch
P:10AB9::(because we only need to do this once)
P:10ABB::check for an empty moving data buffer space
P:10ABE::if not found, too many enemies, thus skip
P:10AC0::get horizontal pixel coordinate
P:10AC4::add eight to put the piranha plant in the center
P:10AC6::store as enemy's horizontal coordinate
P:10AC8::add carry to current page number
P:10ACD::store as enemy's page coordinate
P:10AD3::activate enemy flag
P:10AD5::get piranha plant's vertical coordinate and store here
P:10ADA::write piranha plant's value into buffer
P:10AE1:DrawPipe:get value saved earlier and use as Y
P:10AE3::get buffer offset
P:10AE5::draw the appropriate pipe with the Y we loaded earlier
P:10AE8::render the top of the pipe
P:10AEC::render the rest of the pipe
P:10AEF::subtract one from length and render the part underneath
P:10AF5:VerticalPipeUW
P:10AF9::check to see if value was nullified earlier
P:10AFB::(if d3, the usage control bit of second byte, was set)
P:10B00::add four if usage control bit was not set
P:10B01:WarpPip1:save value in stack
P:10B06::if at world 1-1, do not add piranha plant ever
P:10B0B::lda AreaType\nbeq DrawPipe
P:10B10::if on second column of pipe, branch
P:10B13::(because we only need to do this once)
P:10B15::check for an empty moving data buffer space
P:10B18::if not found, too many enemies, thus skip
P:10B1A::get horizontal pixel coordinate
P:10B1E::add eight to put the piranha plant in the center
P:10B20::store as enemy's horizontal coordinate
P:10B22::add carry to current page number
P:10B27::store as enemy's page coordinate
P:10B2D::activate enemy flag
P:10B2F::get piranha plant's vertical coordinate and store here
P:10B34::write piranha plant's value into buffer
P:10B3B:DrawPip1:get value saved earlier and use as Y
P:10B3D::get buffer offset
P:10B3F::draw the appropriate pipe with the Y we loaded earlier
P:10B42::render the top of the pipe
P:10B46::render the rest of the pipe
P:10B49::subtract one from length and render the part underneath
P:10B4F:GetPipeHeight:check for length loaded, if not, load
P:10B51::pipe length of 2 (horizontal)
P:10B57::get saved lower nybble as height
P:10B58::save only the three lower bits as
P:10B5A::vertical length, then load Y with
P:10B5C::length left over
P:10B60:UpsideDownWarpPipe
P:10B6D:UpsideDownPipe
P:10B7D::get pipe height from object byte
P:10B81::save buffer offset temporarily
P:10B86::save pipe height temporarily
P:10B8A::if at world 1-1, do not add piranha plant ever
P:10B8F:NoUDP:lda AreaType\nbeq NoUDP
P:10B90::return tile offset
P:10B97::render the pipe shaft
P:10BA4::and render the pipe end
P:10BAB::and render the pipe end
P:10BB2:UpsideDownWarpPipeUW
P:10BBA:UpsideDownPipeUW
P:10BC5::get pipe height from object byte
P:10BC9::save buffer offset temporarily
P:10BCE::save pipe height temporarily
P:10BD2::if at world 1-1, do not add piranha plant ever
P:10BD7::lda AreaType\nbeq NoUDP\nif on second column of pipe, skip this
P:10BDC::otherwise try to insert upside-down
P:10BDF::piranha plant, if no empty slots, skip this
P:10BE1::set up upside-down piranha plant
P:10BE7::multiply height of pipe by 16
P:10BE8::and add enemy Y position previously set up
P:10BE9::then subtract 10 pixels, save as new Y position
P:10BF2::set as "down" position
P:10BF5::add 24 pixels, save as "up" position
P:10BF6::note up and down here are reversed
P:10BFB::set movement flag
P:10BFD:NoUD1
P:10BFE::return tile offset
P:10C05::render the pipe shaft
P:10C12::and render the pipe end
P:10C19::and render the pipe end
P:10C20:FindEmptyEnemySlot:start at first enemy slot
P:10C22:EmptyChkLoop:clear carry flag by default
P:10C23::check enemy buffer for nonzero
P:10C25::if zero, leave
P:10C28::if nonzero, check next value
P:10C2C:ExitEmptyChk:if all values nonzero, carry flag is set
P:10C2D:SetupPiranhaPlant
P:10C31::get horizontal pixel coordinate
P:10C35::add eight to put the piranha plant in the center
P:10C37::store as enemy's horizontal coordinate
P:10C39::add carry to current page number
P:10C3E::store as enemy's page coordinate
P:10C44::activate enemy flag
P:10C46::get piranha plant's vertical coordinate and store here
P:10C4E:Hole_Water:--------------------------------\nget low nybble and save as length
P:10C58::now render the water underneath
P:10C5F:QuestionBlockRow_High:--------------------------------\nstart on the fourth row
P:10C61::BIT instruction opcode
P:10C62:QuestionBlockRow_Low:start on the eighth row
P:10C64::save whatever row to the stack for now
P:10C65::get low nybble and save as length
P:10C69::render question boxes with coins
P:10C70:Bridge_High:--------------------------------\nstart on the seventh row from top of screen
P:10C72::BIT instruction opcode
P:10C73:Bridge_Middle:start on the eighth row
P:10C75::BIT instruction opcode
P:10C76:Bridge_Low:start on the tenth row
P:10C78::save whatever row to the stack for now
P:10C79::get low nybble and save as length
P:10C7D::render bridge railing
P:10C84::now render the bridge itself
P:10C8B:FlagpoleObject:--------------------------------\nVine:\n	  jsr GetLrgObjAttrib  ;get low nybble from object byte\n      lda ExtendedLength,x   ;render flag balls on third row from top\n	  tax\n      lda #$26             ;of screen downwards based on low nybble\n     jmp RenderUnderPart\n--------------------------------\nrender flagpole ball on top
P:10C90::now render the flagpole shaft
P:10C99::render solid block at the bottom
P:10CA2::apparently this sometimes refuses to work correctly lmao
P:10CAE:EndlessRope:--------------------------------\nrender rope from the top to the bottom of screen
P:10CB5:BalancePlatRope:save object buffer offset for now
P:10CB7::blank out all from second row to the bottom
P:10CB9::with blank used for balance platform rope
P:10CC0::get back object buffer offset
P:10CC2::get vertical length from lower nybble
P:10CC7:DrawRope:render the actual rope
P:10CCC:RowOfCoins:--------------------------------\nget area type
P:10CCF::load appropriate coin metatile
P:10CD4:C_ObjectRow:--------------------------------
P:10CD7:C_ObjectMetatile
P:10CDA:CastleBridgeObj:load length of 13 columns
P:10CE2:AxeObj:load bowser's palette into sprite portion of palette
P:10CE7:ChainObj:get value loaded earlier from decoder
P:10CE9::get appropriate row and metatile for object
P:10CF2:EmptyBlock:get row location
P:10CF9:ColObj:column length of 1
P:10CFE:SolidBlockMetatiles:--------------------------------
P:10D02:BrickMetatiles
P:10D06::used only by row of bricks object
P:10D07:CustomMTObject
P:10D13::get row number, load length
P:10D2B:SidewayPipeShaft
P:10D31::lda AreaType\nbne +
P:10D36:WaterXD
P:10D42:SidewayPipeRight
P:10D72::dec AreaObjectLength,x
P:10D73:webos
P:10D77:webos2
P:10D7B:SidewayPipeLeft
P:10DAB::dec AreaObjectLength,x
P:10DAC:RowOfBricks:load area type obtained from area offset pointer
P:10DAF::check for cloud type override
P:10DB4::if cloud type, override area type
P:10DB6:DrawBricks:get appropriate metatile
P:10DB9::and go render it
P:10DBC:RowOfSolidBlocks:load area type obtained from area offset pointer
P:10DBF::get metatile
P:10DC2:GetRow:store metatile here
P:10DC3::get row number, load length
P:10DC6:DrawRow
P:10DC8::set vertical height of 1
P:10DCB::render object
P:10DCE:ColumnOfBricks:ldy AreaType          ;load area type obtained from area offset\nlda BrickMetatiles,y  ;get metatile (no cloud override as for row)\njmp GetRow2
P:10DF0:ColumnOfSolidBlocks:load area type obtained from area offset
P:10DF3::get metatile
P:10DF6:GetRow2:save metatile to stack for now
P:10DF7::get length and row
P:10DFA::restore metatile
P:10DFB::get starting row
P:10DFD::now render the column
P:10E00:BulletBillCannon:--------------------------------\nget row and length of bullet bill cannon
P:10E03::start at first row
P:10E05::render bullet bill cannon
P:10E0B::done yet?
P:10E0E::if not, render middle part
P:10E14::done yet?
P:10E17::if not, render bottom until length expires
P:10E1C:SetupCannon:get offset for data used by cannons and whirlpools
P:10E1F::get proper vertical coordinate for cannon
P:10E22::and store it here
P:10E28::store page number for cannon here
P:10E2B::get proper horizontal coordinate for cannon
P:10E2E::and store it here
P:10E32::increment and check offset
P:10E34::if not yet reached sixth cannon, branch to save offset
P:10E36::otherwise initialize it
P:10E38:StrCOffset:save new offset and leave
P:10E3C:StaircaseHeightData:--------------------------------
P:10E45:StaircaseRowData
P:10E4E:StaircaseObject:check and load length
P:10E51::if length already loaded, skip init part
P:10E53::start past the end for the bottom
P:10E55::of the staircase
P:10E58:NextStair:move onto next step (or first if starting)
P:10E5E::get starting row and height to render
P:10E65::now render solid block staircase
P:10E6A:Jumpspring:--------------------------------
P:10E71::load third byte and store here
P:10E7D:ExitJumpspring
P:10E7E:QuestionBlock:--------------------------------\n$07 - used to save ID of brick object\nget value saved from area parser routine ;get value from level decoder routine
P:10E8D::go to render it
P:10E90:HiddenCoin
P:10EA4:HiddenMushRoom
P:10EB8:Hidden1UpBlock
P:10EC9:DHB
P:10ECF:QuestionBlock1Up
P:10ED4:QuestionBlockStar
P:10ED9:HiddenStar
P:10EED:BrickWithCoins:initialize multi-coin timer flag
P:10EF5:BrickWithItem:get value saved from area parser routine         ;save area object ID
P:10EF9::load default adder for bricks with lines
P:10EFB::check level type for ground level
P:10EFF::if ground type, do not start with 5
P:10F01::otherwise use adder for bricks without lines
P:10F03:BWithL:add object ID to adder
P:10F06::use as offset for metatile
P:10F07:DrawQBlk:get appropriate metatile for brick (question block)
P:10F0A::if branched to here from question block routine)
P:10F0B::get row from location byte
P:10F0E::now render the object
P:10F11:BrickPowerUp:GetAreaObjectID:\nldy $00    ;get value saved from area parser routine\ntay        ;save to Y\nExitDecBlock: rts
P:10F11:Bricks
P:10F15:BrickVine
P:10F19:BrickStar
P:10F1D:BrickCoins
P:10F21:Brick1up
P:10F25:BrickWithVine
P:10F2A:BrickWithStar
P:10F2F:BrickWithCoins2
P:10F34:BrickWith1up
P:10F39:BrickWithPowerUp
P:10F3D::apparently this sometimes refuses to work correctly lmao
P:10F48:HoleMetatiles:--------------------------------
P:10F4C:Hole_Empty:get lower nybble and save as length
P:10F4F::skip this part if length already loaded
P:10F51::check for water type level
P:10F54::if not water type, skip this part
P:10F5B::get offset for data used by cannons and whirlpools
P:10F5E::get proper vertical coordinate of where we're at
P:10F62::subtract 16 pixels
P:10F64::store as left extent of whirlpool
P:10F67::get page location of where we're at
P:10F6A::subtract borrow
P:10F6C::save as page location of whirlpool
P:10F70::increment length by 2
P:10F72::multiply by 16 to get size of whirlpool
P:10F73::note that whirlpool will always be
P:10F74::two blocks bigger than actual size of hole
P:10F75::and extend one block beyond each edge
P:10F76::save size of whirlpool here
P:10F7A::increment and check offset
P:10F7C::if not yet reached fifth whirlpool, branch to save offset
P:10F7E::otherwise initialize it
P:10F80:StrWOffset:save new offset here
P:10F83:NoWhirlP:get appropriate metatile, then
P:10F86::render the hole proper
P:10F8B::start at ninth row and go to bottom, run RenderUnderPart
P:10F8D:RenderUnderPart:--------------------------------\nstore vertical length to render
P:10F90::check current spot to see if there's something
P:10F93::we need to keep, if nothing, go ahead
P:10F97::if middle part (tree ledge), wait until next row
P:10F9B::if middle part (mushroom ledge), wait until next row
P:10F9F::if question block w/ coin, overwrite
P:10FA3::if any other metatile with palette 3, wait until next row
P:10FAB::if cracked rock terrain, overwrite
P:10FAF::if stem top of mushroom, wait until next row
P:10FB5:DrawThisRow:render contents of A from routine that called this
P:10FB8:WaitOneRow
P:10FB9::stop rendering if we're at the bottom of the screen
P:10FBD::decrement, and stop rendering if there is no more length
P:10FC3:ExitUPartR
P:10FC4:ChkLrgObjLength:--------------------------------\nget row location and size (length if branched to from here)
P:10FC7:ChkLrgObjFixedLength:check for set length counter
P:10FCA::clear carry flag for not just starting
P:10FCB::if counter not set, load it, otherwise leave alone
P:10FCD::save length into length counter
P:10FD1::set carry flag if just starting
P:10FD2:LenSet
P:10FD3:GetLrgObjAttrib:get offset saved from area obj decoding routine
P:10FD6::get first byte of level object
P:10FDA::save row location
P:10FDD::get next byte, save lower nybble (length or height)
P:10FDF::as Y, then leave
P:10FE3:GetAreaObjXPosition:--------------------------------\nmultiply current offset where we're at by 16
P:10FE6::to obtain horizontal pixel coordinate
P:10FEB:GetAreaObjYPosition:--------------------------------\nmultiply value by 16
P:10FEE::this will give us the proper vertical pixel coordinate
P:10FF2::add 32 pixels for the status bar
P:10FF5:WarpZoneNumbers1:-------------------------------------------------------------------------------------\n$06-$07 - used to store block buffer address used as indirect\nBlockBufferAddr:\n      .db <Block_Buffer_1, <Block_Buffer_2\n      .db >Block_Buffer_1, >Block_Buffer_2\nGetBlockBufferAddr:\n      pha                      ;take value of A, save\n     lsr                      ;move high nybble to low\n     lsr\n     lsr\n     lsr\n     tay                      ;use nybble as pointer to high byte\n    lda BlockBufferAddr+2,y  ;of indirect here\n    sta $07\n    pla\n    and #%00001111           ;pull from stack, mask out high nybble\n    clc\n    adc BlockBufferAddr,y    ;add to low byte\n    sta $06                  ;store here and leave\n    rts\n-------------------------------------------------------------------------------------\n world 1-2
P:10FF9:: warp zone responsible for minus world
P:10FFD:: world 4-2
P:11001:: world 4-2 to world 5
P:11005:HandlePipeEntry:check saved controller bits from earlier
P:11007::for pressing down
P:11009::if not pressing down, branch to leave
P:1100D::check right foot metatile for warp pipe right metatile
P:1100F::branch to leave if not found
P:11013::check left foot metatile for warp pipe left metatile
P:11015::branch to leave if not found
P:11019::set timer for change of area
P:11023::set to run vertical pipe entry routine on next frame
P:11027::load pipedown/injury sound
P:1102B::set background priority bit in player's attributes
P:1102E::check warp zone control
P:11031::branch to leave if none found
P:11033::mask out all but 2 LSB
P:11036::multiply by four
P:11037::save as offset to warp zone numbers (starts at left pipe)
P:11038::get player's horizontal position
P:1103C::if player at left, not near middle, use offset and skip ahead
P:1103E::otherwise increment for middle pipe
P:11041::if player at middle, but not too far right, use offset and skip
P:11043::otherwise increment for last pipe
P:11044:GetWNum:get warp zone numbers
P:11047::decrement for use as world number
P:11048::store as world number and offset
P:1104B::get offset to where this world's area offsets are
P:1104E::get area offset based on world offset
P:11051::store area offset here to be used to change areas
P:11056::silence music
P:1105A::initialize starting page number
P:1105D::initialize area number used for area address offset
P:11060::initialize level number used for world display
P:11063::initialize mode of entry
P:11066::set flag for hidden 1-up blocks
P:11069::set flag to load new game timer
P:1106C:ExPipeE
P:1106D:HandleUpPipeEntry
P:11076::check right foot metatile for warp pipe right metatile
P:11078::branch to leave if not found
P:11083::set timer for change of area
P:1108D::set to run vertical pipe entry routine on next frame
P:11091::load pipedown/injury sound
P:11095::set background priority bit in player's attributes
P:11098:ExPipeU
P:110A1:ChkEnemyFrenzy:jmp ChkEnemyFrenzy\n--------------------------------
P:110A1:ProcLoopCommand
P:110B2::check for enemy object in frenzy queue
P:110B5::if not, skip this part
P:110B7::store as enemy object identifier here
P:110BB::activate enemy object flag
P:110BF::initialize state and frenzy queue
P:110C4::and then jump to deal with this enemy
P:110C7:ProcessEnemyData:--------------------------------\n$06 - used to hold page location of extended right boundary\n$07 - used to hold high nybble of position of extended right boundary
P:110D1::get offset of enemy object data
P:110D9::load first byte
P:110DB::check for EOD terminator
P:110DF::if found, jump to check frenzy buffer, otherwise
P:110E2:CheckEndofBuffer
P:110E5::check for special row $0e
P:110E9::if found, branch, otherwise
P:110EE::check for end of buffer
P:110F0::if not at end of buffer, branch
P:110F2::get identifier back and use as offset for jump engine
P:110F3::check for specific value here
P:110F5::not sure what this was intended for, exactly
P:110F7::this part is quite possibly residual code
P:110F9::but it has the effect of keeping enemies out of
P:110FF::the sixth slot
P:11100:CheckRightBounds:add 48 to pixel coordinate of right boundary
P:11106::store high nybble
P:1110A::add carry to page location of right boundary
P:1110F::store page location + carry
P:11126::if MSB of enemy object is clear, branch to check for row $0f
P:11128::if MSB of enemy object is clear, branch to check for row $0f
P:1112A::if page select already set, do not set again
P:1112F::otherwise, if MSB is set, set page select 
P:11132::and increment page control
P:11135:CheckPageCtrlRow
P:11136::reread first byte
P:1113A::check for special row $0f
P:1113C::if not found, branch to position enemy object
P:1113E::if page select set,
P:11141::branch without reading second byte
P:11144::otherwise, get second byte, mask out 2 MSB
P:11148::store as page control for enemy object data
P:1115A::set page select for enemy object data and 
P:1115D::jump back to process loop commands again
P:11160:CheckThreeBytes2
P:11163:ParseRow0e1
P:11166:PositionEnemyObj:store page control as page location
P:11169::for enemy object
P:1116B::get first byte of enemy object
P:1116F::store column position
P:11171::without subtracting, then subtract borrow
P:1117A::check column position against right boundary
P:1117D::without subtracting, then subtract borrow
P:1117F::from page location
P:11182::if enemy object beyond or at boundary, branch
P:11186::check for special row $0e
P:11188::if found, jump elsewhere
P:1119C::lda Enemy_PageLoc,x\ncmp ScreenRight_PageLoc\nbne CheckRightExtBounds
P:1119D::if not found, unconditional jump
P:111A0:CheckRightExtBounds:check right boundary + 48 against
P:111A2::column position without subtracting,
P:111A4::then subtract borrow from page control temp
P:111A6::plus carry
P:111A8::if enemy object beyond extended boundary, branch
P:111AA::store value in vertical high byte
P:111AE::get first byte again
P:111B0::multiply by four to get the vertical
P:111B1::coordinate
P:111B6::do one last check for special row $0e
P:111B8::(necessary if branched to $c1cb)
P:111BB:CheckForEnemyGroup:lda (EnemyData),y        ;get second byte of object\nand #%01000000           ;check to see if hard mode bit is set\nbeq CheckForEnemyGroup   ;if not, branch to check for group enemy objects\nlda SecondaryHardMode    ;if set, check to see if secondary hard mode flag\nbeq Inc2B2                ;is on, and if not, branch to skip this object completely\nget second byte and mask out 2 MSB
P:111BF::check for value below $37
P:111C3::if $37 or greater, check for value
P:111C5::below $3f, branch if below $3f
P:111C7:BuzzyBeetleMutate:if below $37, check for goomba
P:111C9::value ($3f or more always fails)
P:111CB::check if primary hard mode flag is set
P:111CE::and if so, change goomba to buzzy beetle
P:111D2:StrID:store enemy object number into buffer
P:111D6::set flag for enemy in buffer
P:111E0::check to see if flag is set
P:111E2::if not, leave, otherwise branch
P:111E5:Inc2B3
P:111E8:Inc2B2
P:111EB:CheckFrenzyBuffer:if enemy object stored in frenzy buffer
P:111EE::then branch ahead to store in enemy object buffer
P:111F0::otherwise check vine flag offset
P:111F5::if other value <> 1, leave
P:111F7::otherwise put vine in enemy identifier
P:111F9:StrFre
P:11201::store contents of frenzy buffer into enemy identifier value
P:11203:InitEnemyObject:initialize enemy state
P:11207::jump ahead to run jump engine and subroutines
P:1120A:ExEPar
P:1120B::then leave
P:1120C:DoGroup:handle enemy group objects
P:1120F:ParseRow0e:increment Y to load third byte of object
P:1121B::skip world number check if >= world 9\nmove 3 MSB to the bottom, effectively
P:1121C::making %xxx00000 into %00000xxx
P:11220::is it the same world number as we're on?
P:11223::if not, do not use (this allows multiple uses
P:11225:W9Skip:of the same area, like the underground bonus areas)
P:11226::otherwise, get second byte and use as offset
P:11228::to addresses for level and enemy object data
P:1122C::get third byte again, and this time mask out
P:1122E::the 3 MSB from before, save as page number to be
P:11230::used upon entry to area, if area is entered
P:11233:NotUse
P:11236:CheckThreeBytes:load current offset for enemy object data
P:11239::get first byte
P:1123B::check for special row $0e
P:11241:Inc3B
P:11246::apparently this sometimes refuses to work correctly lmao
P:1124E:Inc2B
P:1125F::init page select for enemy objects
P:11264::reload current offset in enemy buffers
P:11266::and leave
P:11267:CheckpointEnemyID
P:112A4::add eight pixels to what will eventually be the
P:112A6::enemy object's vertical coordinate ($00-$14 only)
P:112B5::add eight pixels to what will eventually be the
P:112B7::enemy object's vertical coordinate ($00-$14 only)
P:112BF::check enemy object identifier for $15 or greater
P:112C1::and branch straight to the jump engine if found
P:112C3::save identifier in Y register for now
P:112C6::add eight pixels to what will eventually be the
P:112C8::enemy object's vertical coordinate ($00-$14 only)
P:112CC::set offscreen masked bit
P:112D0:InitEnemyRoutines2:jmp InitEnemyRoutines
P:112F3::cpy #Spiny\nbeq InitEnemyRoutines
P:112FB::cpy #GreyCheepCheep\nbeq InitEnemyRoutines\ncpy #RedCheepCheep\nbeq InitEnemyRoutines
P:11348::get identifier back and use as offset for jump engine
P:11349:InitEnemyRoutines
P:11353::jump engine table for newly loaded enemy objects\n00 for objects $00-$0f
P:11355::01
P:11357::02
P:11359::03
P:1135B::04
P:1135D::05
P:1135F::06
P:11361::07
P:11363::08
P:11365::09
P:11367::0a
P:11369::0b
P:1136B::0c
P:1136D::0d
P:1136F::0e
P:11371::0f
P:11373::10 for objects $10-$1f
P:11375::11
P:11377::12 spiny
P:11379::13
P:1137B::14 flying cheep-cheeps zone
P:1137D::15 bowser's fire
P:1137F::16 fireworks (unstable)
P:11381::17 bullet bills / underwater cheep-cheeps
P:11383::18 enf frenzy
P:11385::19	
P:11387::1a null sprite
P:11389::1b
P:1138B::1c
P:1138D::1d
P:1138F::1e
P:11391::1f
P:11393::20 for objects $20-$2f
P:11395::21 those 3 are long firebars (malfunctions)
P:11397::22
P:11399::23 
P:1139B::24
P:1139D::25
P:1139F::26
P:113A1::27
P:113A3::28
P:113A5::29
P:113A7::2a
P:113A9::2b
P:113AB::2c
P:113AD::2d
P:113AF::2e
P:113B1::2f
P:113B3::30 for objects $30-$36, flagpole flag object
P:113B5::31 star flag object
P:113B7::32 jumpspring object
P:113B9::33 bullet bill cannon var
P:113BB::34 warp zone
P:113BD::35
P:113BF::36
P:113C1::37
P:113C3::38
P:113C5::39
P:113C7::3a
P:113C9::3b
P:113CB::3c
P:113CD::3d
P:113CF::3e
P:113D1::3f
P:113D3::40
P:113D5::41
P:113D7::42
P:113D9::43
P:113DB::expandablen't (crash entity)
P:113DD:InitScrollLock1
P:113E0:InitPlatformRem
P:113E6::sta Enemy_Flag,y\ndey\n	bpl -\n		rts
P:113F9:InitCannon
P:1142B:InitSign:$37-$3e are gruped goombas and koopas\n$3f crashes so is a potentially free slot
P:11432::set buffer flag
P:11436::set bounding box size control for sign object 
P:11440:NoInitCode
P:11441:InitScrollLock
P:1147B:InitFlag
P:1148A::sta Enemy_X_Position,x   ;coordinate for the flag
P:1148C::page location for the flag
P:11490::subtract borrow from page location and use as
P:11497::set vertical coordinate for flag
P:1149B::set initial vertical coordinate for flagpole's floatey number
P:114AA::use last space in enemy object buffer
P:114AD:DoSaveEnemyIntoSex
P:114F7::get identifier back and use as offset for jump engine
P:114F9:InitGoomba:--------------------------------\nset appropriate horizontal speed
P:114FC::set $09 as bounding box control, set other values
P:114FF:InitPowerUp
P:11501::set power-up object's state
P:11505::set buffer flag
P:11509::set bounding box size control for power-up object
P:1150D:InitFastGoomba:--------------------------------
P:11517:InitKoopaShell:--------------------------------\nload appropriate horizontal speed
P:11524:InitPodoboo:--------------------------------\nset enemy position to below
P:11526::the bottom of the screen
P:1152B::set timer for enemy
P:1152F::initialize enemy state, then jump to use
P:11531::$09 as bounding box size and set other things
P:11534:InitRetainerObj:--------------------------------\nset fixed vertical position for
P:11536::princess/mushroom retainer object
P:11539:NormalXSpdData:--------------------------------
P:1153D:InitNormalEnemy:load offset of 1 by default
P:1153F::check for primary hard mode flag set
P:1154D:GetESpd:get appropriate horizontal speed
P:11550:SetESpd
P:1155A::store as speed for enemy object
P:11566::branch to set bounding box control and other data
P:1156F:InitRedKoopa:--------------------------------\nload appropriate horizontal speed
P:11572::set enemy state for red koopa troopa $03
P:11577:HBroWalkingTimerData:--------------------------------
P:11579:InitHammerBro:init horizontal speed and timer used by hammer bro
P:1157B::apparently to time hammer throwing
P:11585::get secondary hard mode flag
P:1158B::set value as delay for hammer bro to walk left
P:1158E:NoHB:set specific value for bounding box size control
P:11593:InitHorizFlySwimEnemy:--------------------------------\ninitialize horizontal speed
P:11598:InitBloober:--------------------------------\ninitialize horizontal speed
P:1159C:SmallBBox:set specific bounding box size control
P:1159E::unconditional branch
P:115A0:SemiSmallBBox
P:115A4:InitRedPTroopa:--------------------------------\nload central position adder for 48 pixels down
P:115A6::set vertical coordinate into location to
P:115A8::be used as original vertical coordinate
P:115AB::if vertical coordinate < $80
P:115AD::if => $80, load position adder for 32 pixels up
P:115AF:GetCent:send central position adder to A
P:115B0::add to current vertical coordinate
P:115B2::store as central vertical coordinate
P:115B4:TallBBox:set specific bounding box size control
P:115B6:SetBBox:set bounding box control here
P:115BB::ldy Enemy_ID,x\ncpy #RedCheepCheep\nbeq +\ncpy #GreyCheepCheep\nbeq +
P:115C4:InitVStf:initialize vertical speed
P:115C6::and movement force
P:115CC:InitBulletBill:--------------------------------\nset moving direction for left
P:115D0::set bounding box control for $09
P:115D6:InitCheepCheep:--------------------------------\nset vertical bounding box, speed, init others
P:115D9::check one portion of LSFR
P:115DC::get d4 from it
P:115DE::save as movement flag of some sort
P:115E2::save original vertical coordinate here
P:115E6:InitLakitu:--------------------------------\ncheck to see if an enemy is already in
P:115E9::the frenzy buffer, and branch to kill lakitu if so
P:115EB:SetupLakitu:erase counter for lakitu's reappearance
P:115F3::set $03 as bounding box, set other attributes
P:115F6:KillLakitu:jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
P:115F9:PRDiffAdjustData:--------------------------------\n$01-$03 - used to hold pseudorandom difference adjusters
P:11605:LakituSpinyTimer
P:11607:LakituAndSpinyHandler
P:11609::if timer here not expired, leave
P:1160E::if we are on the special use slot, leave
P:1161B::start with the last enemy slot
P:1161D:ChkLak:check all enemy slots to see
P:11620::if lakitu is on one of them
P:11622::if so, branch out of this loop
P:11624::otherwise check another slot
P:11625::loop until all slots are checked
P:1162F::increment reappearance timer
P:11635::check to see if we're up to a certain value yet
P:11637::if not, leave
P:11639::start with the last enemy slot again
P:1163B:ChkNoEn:check enemy buffer flag for non-active enemy slot
P:1163D::branch out of loop if found
P:1163F::otherwise check next slot
P:11640::branch until all slots are checked
P:11642::if no empty slots were found, branch to leave
P:11644:CreateL:initialize enemy state
P:11648::create lakitu enemy object
P:1164C::do a sub to set up lakitu
P:11651::finish setting up lakitu
P:11654:RetEOfs:get enemy object buffer offset again and leave
P:11656:ExLSHand
P:11657:CreateSpiny:--------------------------------\nif player above a certain point, branch to leave
P:1165D::if lakitu is not in normal state, branch to leave
P:11662::store horizontal coordinates (high and low) of lakitu
P:11665::into the coordinates of the spiny we're going to create
P:1166C::put spiny within vertical screen unit
P:11670::put spiny eight pixels above where lakitu is
P:11678::get 2 LSB of LSFR and save to Y
P:11680:DifLoop:get three values and save them
P:11683::to $01-$03
P:11686::increment Y four bytes for each value
P:11689::decrement X for each one
P:1168A::loop until all three are written
P:1168C::get enemy object buffer offset
P:1168E::move enemy, change direction, get value - difference
P:11691::check player's horizontal speed
P:11695::if moving faster than a certain amount, branch elsewhere
P:11697::otherwise save value in A to Y for now
P:1169B::get one of the LSFR parts and save the 2 LSB
P:1169D::branch if neither bits are set
P:116A0::otherwise get two's compliment of Y
P:116A4:UsePosv:put value from A in Y back to A (they will be lost anyway)
P:116A5:SetSpSpd:set bounding box control, init attributes, lose contents of A
P:116B0::set horizontal speed to zero because previous contents
P:116B2::cmp #$00                   ;of A were lost...branch here will never be taken for\nthe same reason
P:116B5::set bounding box control, init attributes
P:116BA:SpinyRte:set moving direction to the right
P:116BE::set vertical speed to move upwards
P:116C6::enable enemy object by setting flag
P:116C8::lda #$05
P:116CA::put spiny in egg state and leave
P:116CC:ChpChpEx
P:116CD:FirebarSpinSpdData:--------------------------------
P:116D2:FirebarSpinDirData
P:116D7:InitLongFirebar:create enemy object for long firebar
P:116DA:InitShortFirebar:initialize low byte of spin state
P:116DE::subtract $1b from enemy identifier
P:116E0::to get proper offset for firebar data
P:116E4::get spinning speed of firebar
P:116EA::get spinning direction of firebar
P:116F1::add four pixels to vertical coordinate
P:116F8::add four pixels to horizontal coordinate
P:116FF::add carry to page location
P:11704:FlyCCXPositionData:jmp TallBBox2               ;set bounding box control (not used) and leave\n--------------------------------\n$00-$01 - used to hold pseudorandom bits
P:11714:FlyCCXSpeedData
P:11720:FlyCCTimerData
P:11724:ChpChpEx2
P:11725:InitFlyingCheepCheep:if timer here not expired yet, branch to leave
P:1172A::jump to set bounding box size $09 and init other values
P:11730::set pseudorandom offset here
P:11733::load timer with pseudorandom offset
P:1173B::load Y with default value
P:11740::if secondary hard mode flag not set, do not increment Y
P:11742::otherwise, increment Y to allow as many as four onscreen
P:11743:MaxCC:store whatever pseudorandom bits are in Y
P:11745::compare enemy object buffer offset with Y
P:11747::if X => Y, branch to leave
P:1174C::get last two bits of LSFR, first part
P:1174E::and store in two places
P:11752::set vertical speed for cheep-cheep
P:11756::load default value
P:11758::check player's horizontal speed
P:1175A::if player not moving left or right, skip this part
P:1175E::if moving to the right but not very quickly,
P:11760::do not change A
P:11762::otherwise, multiply A by 2
P:11763:GSeed:save to stack
P:11765::add to last two bits of LSFR we saved earlier
P:11767::save it there
P:1176C::if neither of the last two bits of second LSFR set,
P:1176E::skip this part and save contents of $00
P:11773::otherwise overwrite with lower nybble of
P:11775::third LSFR part
P:11777:RSeed:get value from stack we saved earlier
P:11779::add to last two bits of LSFR we saved in other place
P:1177B::use as pseudorandom offset here
P:1177C::get horizontal speed using pseudorandom offset
P:11781::set to move towards the right
P:11785::if player moving left or right, branch ahead of this part
P:11789::get first LSFR or third LSFR lower nybble
P:1178B::and check for d1 set
P:1178E::if d1 not set, branch
P:11792::if d1 set, change horizontal speed
P:11794::into two's compliment, thus moving in the opposite
P:11795::direction
P:11799::increment to move towards the left
P:1179B:D2XPos1:get first LSFR or third LSFR lower nybble again
P:1179E::check for d1 set again, branch again if not set
P:117A0::get player's horizontal position
P:117A3::if d1 set, add value obtained from pseudorandom offset
P:117A6::and save as enemy's horizontal position
P:117A8::get player's page location
P:117AA::add carry and jump past this part
P:117AF:D2XPos2:get player's horizontal position
P:117B2::if d1 not set, subtract value obtained from pseudorandom
P:117B5::offset and save as enemy's horizontal position
P:117B7::get player's page location
P:117B9::subtract borrow
P:117BB:FinCCSt:save as enemy's page location
P:117BF::set enemy's buffer flag
P:117C1::set enemy's high vertical byte
P:117C5::put enemy below the screen, and we are done
P:117C8:BowserPoints:--------------------------------
P:117D0:InitBowser
P:117DF::jump to create another bowser object
P:117E2::save offset of first here
P:117EA::initialize bowser's body controls
P:117ED::and bridge collapse offset
P:117F2::store original horizontal position here
P:117F7::store something here
P:117FA::and in moving direction
P:1182E::otherwise, check number of pts
P:11832::more than 9 pts?
P:11836::if so, subtract 10 and add one to the 10s digit
P:11839::instead of showing 100 pts, A0 will show, etc.
P:1185A::apparently this sometimes refuses to work correctly lmao
P:11864::set bowser's feet timer and in enemy timer
P:1186A::set default movement speed here
P:1186E:Setup_Vine:--------------------------------\nload identifier for vine object
P:11870::store in buffer
P:11874::set flag for enemy object buffer
P:11879::copy page location from previous object
P:1187E::copy horizontal coordinate from previous object
P:11883::copy vertical coordinate from previous object
P:11885::load vine flag/offset to next available vine slot
P:11888::if set at all, don't bother to store vertical
P:1188A::otherwise store vertical coordinate here
P:1188D:NextVO1:store object offset to next available vine slot
P:1188E::using vine flag as offset
P:11891::increment vine flag offset
P:11896::load vine grow sound
P:11899:DuplicateEnemyObj:start at beginning of enemy slots
P:1189B:FSLoop
P:1189F::increment one slot
P:118A0::check enemy buffer flag for empty slot
P:118A3::if set, branch and keep checking
P:118A5::otherwise set offset here
P:118A8::transfer original enemy buffer offset
P:118A9::store with d7 set as flag in new enemy
P:118AB::slot as well as enemy offset
P:118B0::copy page location and horizontal coordinates
P:118B3::from original enemy to new enemy
P:118BA::set flag as normal for original enemy
P:118BC::set high vertical byte for new enemy
P:118C1::copy vertical coordinate from original to new
P:118C4:FlmEx:and then leave
P:118C5:FlameYPosData:--------------------------------
P:118C9:FlameYMFAdderData
P:118CB:FW
P:118D1:InitBowserFlame:if timer not expired yet, branch to leave
P:118D6::reset something here
P:118DB::load bowser's flame sound into queue
P:118DF::get bowser's buffer offset
P:118E2::check for bowser
P:118E7::branch if found
P:118E9::get timer data based on flame counter
P:118ED::add 32 frames by default
P:118F9::if secondary mode flag not set, use as timer setting
P:118FC::otherwise subtract 16 frames for secondary hard mode
P:118FE:SetFrT:set timer accordingly
P:11904::get 2 LSB from first part of LSFR
P:11906::set here
P:11909::use as offset
P:1190A::load vertical position based on pseudorandom offset
P:1190D:PutAtRightExtent:set vertical position
P:11913::place enemy 32 pixels beyond right side of screen
P:1191A::add carry
P:1191E::skip this part to finish setting values
P:11921:SpawnFromMouth:get bowser's horizontal position
P:11925::subtract 14 pixels
P:11927::save as flame's horizontal position
P:1192C::copy page location from bowser to flame
P:11931::add 8 pixels to bowser's vertical position
P:11934::save as flame's vertical position
P:11939::get 2 LSB from first part of LSFR
P:1193B::save here
P:1193E::use as offset
P:1193F::get value here using bits as offset
P:11942::load default offset
P:11944::compare value to flame's current vertical position
P:11946::if less, do not increment offset
P:11948::otherwise increment now
P:11949:SetMF:get value here and save
P:1194C::to vertical movement force
P:11951::clear enemy frenzy buffer
P:11954:FinishFlame:set $08 for bounding box control
P:11959::set high byte of vertical and
P:1195B::enemy buffer flag
P:11960::initialize horizontal movement force, and
P:11963::enemy state
P:11966:FireworksXPosData:--------------------------------
P:1196C:FireworksYPosData
P:11972:ExitFWk
P:11973:InitFireworks:if timer not expired yet, branch to leave
P:11978::otherwise reset timer
P:1197D::decrement for each explosion
P:11980::start at last slot
P:11982:StarFChk
P:11983::lda Enemy_ID,y               ;check for presence of star flag object\ncmp #StarFlagObject          ;if there isn't a star flag object,\nbne StarFChk                 ;routine goes into infinite loop = crash (fixed)
P:11986::get horizontal coordinate of star flag object, then
P:11987::subtract 48 pixels from it and save to
P:11989::the stack
P:1198D::subtract the carry from the page location
P:1198F::of the star flag object
P:11991::get fireworks counter
P:11995::add state of star flag object (possibly not necessary)
P:11998::use as offset
P:11999::get saved horizontal coordinate of star flag - 48 pixels
P:1199B::add number based on offset of fireworks counter
P:1199E::store as the fireworks object horizontal coordinate
P:119A2::add carry and store as page location for
P:119A4::the fireworks object
P:119A6::get vertical position using same offset
P:119A9::and store as vertical coordinate for fireworks object
P:119AD::store in vertical high byte
P:119AF::and activate enemy buffer flag
P:119B2::initialize explosion counter
P:119B6::set explosion timing counter
P:119BA:Bitmasks:--------------------------------
P:119C2:Enemy17YPosData
P:119CA:SwimCC_IDData
P:119CC:BulletBillCheepCheep:if timer not expired yet, branch to leave
P:119D1::are we in a water-type level?
P:119D4::if not, branch elsewhere
P:119D6::are we past third enemy slot?
P:119D8::if so, branch to leave
P:119DA::load default offset
P:119DF::check first part of LSFR against preset value
P:119E1::if less than preset, do not increment offset
P:119E3::otherwise increment
P:119E4:ChkW2:check world number
P:119E9::if we're on world 2, do not increment offset
P:119EB::otherwise increment
P:119EC:Get17ID
P:119ED::mask out all but last bit of offset
P:119F0::load identifier for cheep-cheeps
P:119F3:Set17ID:store whatever's in A as enemy identifier
P:119F8::if not all bits set, skip init part and compare bits
P:119FC::initialize vertical position filter
P:11A01:GetRBit:get first part of LSFR
P:11A04::mask out all but 3 LSB
P:11A06:ChkRBit:use as offset
P:11A07::load bitmask
P:11A0A::perform AND on filter without changing it
P:11A0F::increment offset
P:11A11::mask out all but 3 LSB thus keeping it 0-7
P:11A13::do another check
P:11A16:AddFBit:add bit to already set bits in filter
P:11A19::and store
P:11A1C::load vertical position using offset
P:11A1F::set vertical position and other values
P:11A22::initialize dummy variable
P:11A25::set timer
P:11A2A::process our new enemy object
P:11A2D:DoBulletBills:start at beginning of enemy slots
P:11A2F:BB_SLoop:move onto the next slot
P:11A30::branch to play sound if we've done all slots
P:11A34::if enemy buffer flag not set,
P:11A37::loop back and check another slot
P:11A3C::check enemy identifier for
P:11A3E::bullet bill object (frenzy variant)
P:11A40:ExF17:if found, leave
P:11A41:FireBulletBill
P:11A43::play fireworks/gunfire sound
P:11A47::load identifier for bullet bill object
P:11A49::unconditional branch
P:11A4B:HandleGroupEnemies:--------------------------------\n$00 - used to store Y position of group enemies\n$01 - used to store enemy ID\n$02 - used to store page location of right side of screen\n$03 - used to store X position of right side of screen\nload value for green koopa troopa
P:11A4E::subtract $37 from second byte read
P:11A50::save result in stack for now
P:11A51::was byte in $3b-$3e range?
P:11A53::if so, branch
P:11A55::save another copy to stack
P:11A56::load value for goomba enemy
P:11A58::if primary hard mode flag not set,
P:11A5B::branch, otherwise change to value
P:11A5D::for buzzy beetle
P:11A5F:PullID:get second copy from stack
P:11A60:SnglID:save enemy id here
P:11A62::load default y coordinate
P:11A64::check to see if d1 was set
P:11A66::if so, move y coordinate up,
P:11A68::otherwise branch and use default
P:11A6A:SetYGp:save y coordinate here
P:11A6C::get page number of right edge of screen
P:11A6F::save here
P:11A71::get pixel coordinate of right edge
P:11A74::save here
P:11A76::load two enemies by default
P:11A78::get first copy from stack
P:11A79::check to see if d0 was set
P:11A7A::if not, use default value
P:11A7C::otherwise increment to three enemies
P:11A7D:CntGrp:save number of enemies here
P:11A80:GrLoop:start at beginning of enemy buffers
P:11A82:GSltLp:increment and branch if past
P:11A83::end of buffers
P:11A87::check to see if enemy is already
P:11A89::stored in buffer, and branch if so
P:11A8D::store enemy object identifier
P:11A91::store page location for enemy object
P:11A95::store x coordinate for enemy object
P:11A98::add 24 pixels for next enemy
P:11A9C::add carry to page location for
P:11A9E::next enemy
P:11AA2::store y coordinate for enemy object
P:11AA6::activate flag for buffer, and
P:11AA8::put enemy within the screen vertically
P:11AAC::get identifier back and use as offset for jump engine\nprocess each enemy object separately
P:11AAF::do this until we run out of enemy objects
P:11AB4:NextED:jump to increment data offset and leave
P:11AB7:PPhitbox:--------------------------------
P:11AB9:InitPiranhaPlant
P:11ABC::apparently this sometimes refuses to work correctly lmao
P:11AC3::apparently this sometimes refuses to work correctly lmao
P:11AC7:InitPiranhaPlant1:set initial speed
P:11ACC::initialize enemy state and what would normally
P:11ACE::be used as vertical speed, but not in this case
P:11AD2::save original vertical coordinate here
P:11AD8::save original vertical coordinate - 24 pixels here
P:11AE1::set specific value for bounding box control
P:11AE4:InitUDPiranhaPlant
P:11AE7::apparently this sometimes refuses to work correctly lmao
P:11AEE::apparently this sometimes refuses to work correctly lmao
P:11AF2:InitUDPiranhaPlant1:set initial speed
P:11AF7::initialize enemy state and what would normally
P:11AF9::be used as vertical speed, but not in this case
P:11AFD::save original vertical coordinate here
P:11B03::save original vertical coordinate - 24 pixels here
P:11B08::set specific value for bounding box control
P:11B0B:InitEnemyFrenzy:--------------------------------\nload enemy identifier
P:11B0D::save in enemy frenzy buffer
P:11B11::subtract 12 and use as offset for jump engine
P:11B16::frenzy object jump table
P:11B22:NoFrenzyCode:--------------------------------
P:11B23:EndFrenzy:--------------------------------\nstart at last slot
P:11B25:LakituChk:check enemy identifiers
P:11B28::for lakitu
P:11B2C::if found, set state
P:11B31:NextFSlot:move onto the next slot
P:11B32::do this until all slots are checked
P:11B36::empty enemy frenzy buffer
P:11B39::disable enemy buffer flag for this object
P:11B3C:InitJumpGPTroopa:--------------------------------\nset for movement to the left
P:11B40::set horizontal speed
P:11B44:TallBBox2:set specific value for bounding box control
P:11B46:SetBBox2:set bounding box control then leave
P:11B4A:InitBalPlatform:--------------------------------\nraise vertical position by two pixels
P:11B4E::if secondary hard mode flag not set,
P:11B51::branch ahead
P:11B53::otherwise set value here
P:11B55::do a sub to add or subtract pixels
P:11B58:AlignP:set default value here for now
P:11B5A::get current balance platform alignment
P:11B5D::set platform alignment to object state here
P:11B5F::if old alignment $ff, put $ff as alignment for negative
P:11B61::if old contents already $ff, put
P:11B62::object offset as alignment to make next positive
P:11B63:SetBPA:store whatever value's in Y here
P:11B68::init moving direction
P:11B6A::init Y
P:11B6B::do a sub to add 8 pixels, then run shared code here
P:11B6E:InitDropPlatform:--------------------------------
P:11B70::set some value here
P:11B73::then jump ahead to execute more code
P:11B76:InitHoriPlatform:--------------------------------
P:11B78::init one of the moving counters
P:11B7A::jump ahead to execute more code
P:11B7D:InitVertPlatform:--------------------------------\nset default value here
P:11B7F::check vertical position
P:11B81::if above a certain point, skip this part
P:11B85::otherwise get two's compliment
P:11B88::get alternate value to add to vertical position
P:11B8A:SetYO:save as top vertical position
P:11B8E::load value from earlier, add number of pixels 
P:11B8F::to vertical position
P:11B91::save result as central vertical position
P:11B93:CommonPlatCode:--------------------------------\ninitialize vertical speed
P:11B95::and movement force
P:11B9A:SPBBox:set default bounding box size control
P:11B9F::check for castle-type level
P:11BA1::use default value if found
P:11BA3::otherwise check for secondary hard mode flag
P:11BA6::if set, use default value
P:11BA8::use alternate value if not castle or secondary not set
P:11BAA:CasPBB:set bounding box size control here and leave
P:11BAE:LargeLiftUp:--------------------------------\nexecute code for platforms going up
P:11BB1::overwrite bounding box for large platforms
P:11BB4:LargeLiftDown:execute code for platforms going down
P:11BB7:LargeLiftBBox:jump to overwrite bounding box size control
P:11BBA:PlatLiftUp:--------------------------------\nset movement amount here
P:11BBF::set moving speed for platforms going up
P:11BC3::skip ahead to part we should be executing
P:11BC6:PlatLiftDown:--------------------------------\nset movement amount here
P:11BCB::set moving speed for platforms going down
P:11BCF:CommonSmallLift:--------------------------------
P:11BD1::do a sub to add 12 pixels due to preset value  
P:11BD6::set bounding box control for small platforms
P:11BDA:PlatPosDataLow:--------------------------------
P:11BDD:PlatPosDataHigh
P:11BE0:PosPlatform:get horizontal coordinate
P:11BE3::add or subtract pixels depending on offset
P:11BE6::store as new horizontal coordinate
P:11BEA::add or subtract page location depending on offset
P:11BED::store as new page location
P:11BEF::and go back
P:11BF0:EndOfEnemyInitCode:--------------------------------
P:11BF1:GameText1:.db $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
P:11BF1:TopStatusBarLine1
P:11C02:: "WORLD"\n "WORLD  TIME"
P:11C10:: score trailing digit and coin display
P:11C18:: attribute table data, clears name table 0 to palette 2
P:11C1C:: attribute table data, used for coin icon in status bar
P:11C20:: end of data block
P:11C21:WorldLivesDisplay1: cross with spaces used on
P:11C26:: lives display
P:11C2B:: "WORLD  - " used on lives display
P:11C37:: possibly used to clear time up
P:11C3B:: attribute table data for crown if more than 9 lives
P:11C3C:OnePlayerTimeUp1:TwoPlayerTimeUp1:\n .db $21, $cd, $05, $16, $0a, $1b, $12, $18 ; "MARIO"\n "TIME UP"
P:11C47:TwoPlayerGameOver1: "MARIO"
P:11C4F:GameOver1:"GAME OVER"
P:11C4F:OnePlayerGameOver1
P:11C5B::"CONTINUE"
P:11C6A::"END"
P:11C71:WarpZoneWelcome1: "MARIO"\n "GAME OVER"\n "WELCOME TO WARP ZONE!"
P:11C89:: placeholder for left pipe
P:11C8D:: placeholder for middle pipe
P:11C91:: placeholder for right pipe
P:11C95:: attribute data
P:11C9E:GameTextOffsets1:LuigiName:\n  .db $15, $1e, $12, $10, $12    ; "LUIGI", no address or length00         ; world 4-2 to world 5
P:11CA8:WriteGameText1:save text number to stack
P:11CAA::multiply by 2 and use as offset
P:11CAB::if set to do top status bar or world/lives display,
P:11CAD::branch to use current offset as-is
P:11CAF::if set to do time-up or game over,
P:11CB1::branch to check players
P:11CB3::otherwise warp zone, therefore set offset
P:11CB5:Chk2Players1:lda NumberOfPlayers     ;check for number of players\nbne LdGameText          ;if there are two, use current offset to also print name\notherwise increment offset by one to not print name
P:11CB6:LdGameText1:get offset to message we want to print
P:11CBB:GameTextLoop1:load message data
P:11CBE::check for terminator
P:11CC0::branch to end text if found
P:11CC2::otherwise write data to buffer
P:11CC5::and increment increment
P:11CC7::do this for 256 bytes if no terminator found
P:11CC9:EndGameText1:put null terminator at end
P:11CCE::pull original text number from stack
P:11CD0::are we printing warp zone?
P:11CD2::subtract 4 and then shift to the left
P:11CD4::twice to get proper warp zone number
P:11CD5::offset
P:11CD9:WarpNumLoop1:print warp zone numbers into the
P:11CDC::placeholders from earlier
P:11CE0::put a number in every fourth space
P:11CE8::load new buffer pointer at end of message
P:11CEE:PaletteMTtable
P:11DEE:WorldAddrOffsets
P:11DF6::world 9
P:11DF7:AreaAddrOffsets: Why is it $c0 and not $40?  Does it matter?
P:11DF7:World1Areas
P:11DFC:World2Areas
P:11E01:World3Areas
P:11E05:World4Areas
P:11E09:World5Areas
P:11E0D:World6Areas
P:11E11:World7Areas
P:11E16:World8Areas
P:11E1A:World9Areas
P:11E1E:EnemyAddrHOffsets:AreaAddrOffsets:\nWorld1Areas: .db $25, $29, $40, $26, $60 ; Why is it $c0 and not $40?  Does it matter?\nWorld2Areas: .db $28, $29, $01, $27, $62\nWorld3Areas: .db $24, $35, $20, $63\nWorld4Areas: .db $22, $29, $41, $2c, $61\nWorld5Areas: .db $2a, $31, $26, $62\nWorld6Areas: .db $2e, $23, $2d, $60\nWorld7Areas: .db $33, $29, $01, $27, $64\nWorld8Areas: .db $30, $32, $21, $65\nWorld9Areas: .db $27, $66\nbonus area data offsets, included here for comparison purposes\nunderground bonus area  - c2\ncloud area 1 (day)      - 2b\ncloud area 2 (night)    - 34\nwater area (5-2/6-2)    - 00\nwater area (8-4)        - 02\nwarp zone area (4-2)    - 2f\nEnemyAddrHOffsets:\n      .db $1f, $06, $1c, $00\nEnemyDataAddrLow:\n      .db <E_CastleArea1, <E_CastleArea2, <E_CastleArea3, <E_CastleArea4, <E_CastleArea5, <E_CastleArea6\n      .db <E_GroundArea1, <E_GroundArea2, <E_GroundArea3, <E_GroundArea4, <E_GroundArea5, <E_GroundArea6\n      .db <E_GroundArea7, <E_GroundArea8, <E_GroundArea9, <E_GroundArea10, <E_GroundArea11, <E_GroundArea12\n      .db <E_GroundArea13, <E_GroundArea14, <E_GroundArea15, <E_GroundArea16, <E_GroundArea17, <E_GroundArea18\n      .db <E_GroundArea19, <E_GroundArea20, <E_GroundArea21, <E_GroundArea22, <E_UndergroundArea1\n      .db <E_UndergroundArea2, <E_UndergroundArea3, <E_WaterArea1, <E_WaterArea2, <E_WaterArea3\n Water
P:11E1F:: Ground
P:11E20:: Underground
P:11E21:: castle
P:11E22:EnemyDataAddrLow:.db "98uj3urh3q2nwfyw3q2ghf276"\n Castle
P:11E22:EnemyDataAddrLow_CastleStart
P:11E2A:EnemyDataAddrLow_GroundStart: Ground
P:11E45:EnemyDataAddrLow_UndergroundStart: UnderGround
P:11E48:EnemyDataAddrLow_WaterStart: Water
P:11E4B:EnemyDataAddrHigh: Castle
P:11E53:: Ground
P:11E6E:: Underground
P:11E71:: Water
P:11E74:AreaDataHOffsets:AreaDataHOffsets:\n      .db $00, $03, $19, $1c\n.db "AreaDataHOffsets"\n Water
P:11E75:: Ground
P:11E76:: Underground
P:11E77:: castle
P:11E78:AreaDataAddrLow: Water
P:11E78:AreaDataAddrLow_WaterStart
P:11E7B:AreaDataAddrLow_GroundStart: Ground
P:11E96:AreaDataAddrLow_UndergroundStart: Underground
P:11E99:AreaDataAddrLow_CastleStart: Castle
P:11EA1:AreaDataAddrHigh: Water
P:11EA4:: Ground
P:11EBF:: Underground
P:11EC2:: Castle
P:11ECA::ENEMY OBJECT DATA
P:14000:E_CastleArea1: bank 05 -- level banks\n bank identifier\n -----------\n LEVEL BANKS\n -----------\n07\n [e] used in enemy data\n [l] used in level data\n [e] Two Goombas\n [e] Three Goombas\n [e] Use on first byte to skip a number of pages specified by the second byte.\n [e,l] Add to second byte to skip to the next page\n [l] Tree ledge to Vertical pipe.  Add to second byte\n [l] Hole to low ? blocks.  Add to first byte\n [l] Intro pipe to loop keeper.  Add to first byte.  use this for flagpole\n [l] Intro pipe to loop keeper.  Add to first byte\n [l] Add this to a pipe to make it a warp pipe\nGAME LEVELS DATA\n.db "GAMELEVELSDATA"\n.db "ENEMYOBJECTDATA"\nlevel 1-4
P:14036:E_CastleArea5:level 7-4
P:14037:E_CastleArea6:level 8-4
P:14038:E_CastleArea7:level 9-2
P:14039:E_GroundArea2:level 8-3
P:1403A:E_GroundArea6:level 1-1\n      .db $1e, $c2, $00, $6b, $06, $8b, $86, $63, $b7, $0f, $05\n      .db $03, $06, $23, $06, $4b, $b7, $bb, $00, $5b, $b7\n      .db $fb, $37, $3b, $b7, $0f, $0b, $1b, $37\n      .db $ff\nTwoGoombas = $37\nPageFlag = $80\nPageSkip = $0f\n.db $55, $16 + $80\n.db $55, $1b + $80 ; clockwise firebar\n.db $55, $1c + $80 ; fast clockwise firebar\n.db $55, $1d + $80 ; counterclockwise firebar\n.db $55, $1e + $80 ; fast counterclockwise firebar\n.db $55, $1f + $80 ; clockwise long firebar\n      .db $55, $20 + $80 ; glitchy firebar (counterclockwise long firebar)\n      .db $55, $21 + $80 ; glitchy firebar (clockwise fast long firebar)\n      .db $55, $22 + $80 ; glitchy firebar (counterclockwise fast long firebar)\n      .db $ff\n.db $00, $b5 ; Mushroom Retainer\n.db $8b, PageFlag+Spiny\n.db $1e, PageFlag+$42, $00\n.db $4a, HammerBro + PageFlag\n.db $5a, HammerBro\n.db $6a, HammerBro\n.db $7a, HammerBro\n.db $8a, HammerBro\n.db $9a, HammerBro
P:1403F::.db $94, PowerUpObject, $00
P:14060:E_GroundArea7:level 1-3
P:1406A::.db $aa, $14 ;fish
P:140A1:E_GroundArea9:level 2-1
P:140DC:E_GroundArea10:end of data terminator here is also used by pipe intro area
P:140DF:E_GroundArea12:cloud level used in levels 2-1 and 5-2
P:140E0:E_GroundArea16:warp zone area used in level 4-2
P:140E1:E_GroundArea17:level 8-1
P:140E2:E_GroundArea19:level 8-2
P:140E3:E_GroundArea21:cloud level used in levels 3-1 and 6-2
P:140E4:E_UndergroundArea1:level 1-2
P:1412E:E_UndergroundArea2:level 9-2
P:1412F:E_UndergroundArea3:underground bonus rooms area used in many levels
P:14130:E_WaterArea1:water area used in levels 5-2 and 6-2
P:14131:E_WaterArea3:level 7-2
P:14132:L_CastleArea1:AREA OBJECT DATA\n.db "AREAOBJECTDATA"\nlevel 1-4/6-4
P:146D5:L_CastleArea5:level 7-4
P:146D8:L_CastleArea6:level 8-4
P:146DB:L_CastleArea7:level 9-2
P:146DE:L_GroundArea2:level 8-3
P:146E1:L_GroundArea6:level 1-1\nL_GroundArea6:\n header (first byte)
P:146E3:: .db $24, $00, $01, $8C, $02, $00, $01, $8C, $01, $00, $01, $8C, $0A, $00, $01, $88, $02, $00, $01, $88, $01, $00, $01, $88, $0D, $00, $01, $88, $01, $00, $01, $88, $0D, $00, $01, $88, $01, $00, $01, $88, $0A, $00, $01, $88, $03, $00, $01, $88, $05, $00, $02, $C2, $0E, $00, $02, $C2, $0E, $00, $02, $C2, $0E, $00, $02, $C2, $0D, $00, $03, $C2, $20, $54, $A0, $00, $01, $C2, $0F, $00, $02, $54, $0E, $00, $02, $54, $AE, $00\n.db $00 + $02*$08 + $01*$40                               ; header (first byte)\n.db $01 + $02*$10 + $00*$40                               ; header (second byte)\n.db Objects3Flag + $06 * $10, $40 + $01 + PageFlag        ; (6,) flagpole\n x=10, id=02, y=06\n.db Objects4Flag + $0a * $10, $02 * $10 + $06             ; (10,6) castle\n.db $fd\nL_GroundArea6a:\n Still needs work; have to see how castle terrain and water levels work.\n PageFlag = $80      ; Add to second byte to skip to the next page\n Objects1Flag = $10  ; Tree ledge to Vertical pipe.  Add to second byte\n Objects2Flag = $0c  ; Hole to low ? blocks.  Add to first byte\n Objects3Flag = $0d  ; Intro pipe to loop keeper.  Add to first byte.  use this for flagpole\n Objects4Flag = $0f  ; Intro pipe to loop keeper.  Add to first byte\n WarpFlag = $08      ; Add this to a pipe to make it a warp pipe\n ----------------------------------------------------------------------------------------------------\n Header (first byte): scenery/bg color + player entrance control * $08 + timer setting * $40\n Scenery/bg color (3 bits 00000xxx)\n 00 = green bushes\n 01 = water\n 02 = castle wall\n 03 = green bushes\n 04 = night sky, green bushes\n 05 = snow bushes, pipes\n 06 = night sky, snow bushes, pipes\n 07 = night sky, snow bushes, pipes, terrain, enemies\n Player entrance control (3 bits 00xxx000)\n 00 = drop in from top of screen on the left\n 01 = drop in from near top of screen on the left\n 02 = start standing to the left\n 03 = drop in from middle height on the left\n 04 = drop in from top of screen on the left\n 05 = drop in from top of screen on the left\n 06 = start to the left, auto walk to right\n 07 = start to the left, auto walk to right\n Timer setting (2 bits xx000000)\n 00 = 0\n 01 = 300\n 02 = 200\n 03 = 100\n ----------------------------------------------------------------------------------------------------\n ----------------------------------------------------------------------------------------------------\n Header (second byte): terrain control + background scenery type * $10 + background scenery * $40\n terrain control (4 bits xxxx0000)\n 00 = (no terrain)\n 01 = ground (1 block height)\n 02 = ground (1 block height) + ceiling (1 block height)\n 03 = ground (1 block height) + ceiling (3 block height)\n 04 = ground (1 block height) + ceiling (4 block height)\n 05 = ground (1 block height) + ceiling (8 block height)\n 06 = ground (5 block height) + ceiling (1 block height)\n 07 = ground (5 block height) + ceiling (3 block height)\n 08 = ground (5 block height) + ceiling (4 block height)\n 09 = ground (6 block height) + ceiling (1 block height)\n 0a = ceiling (1 block height)\n 0b = ground (6 block height) + ceiling (4 block height)\n 0c = ground (9 block height) + ceiling (1 block height)\n 0d = ground (2 block height) + ceiling (1 block height), middle section (y=03, 5 block height)\n 0e = ground (2 block height) + ceiling (1 block height), middle section (y=04, 5 block height)\n 0f = full of blocks (13 block height)\n background scenery type (2 bits 0000xx00)\n 00 = no scenery\n 01 = clouds\n 02 = hills, bushes, clouds\n 03 = fences\n background scenery (2 bits 000000xx)\n 00 = green pipes and bushes\n 01 = copper color pipes and bushes\n 02 = green pipes and bushes\n 03 = cloud type override\n ----------------------------------------------------------------------------------------------------\n.db $4a, custom, $71\n.db $59, custom, $71\n.db $5a, coin\n.db $69, coin
P:14AC6:L_UndergroundArea1:level 1-2
P:14F1D:L_GroundArea7:	  .db $17, $0c\n	  .db $37, $0d\n	  .db $57, $0e\n	  .db $77, $0f\n	  ;.db $07, $01 + PageFlag                                   ; (0,7) ? block with coin (+0x80 for page skip)\n	  ;.db $00, Objects1Flag + $05 * $10 + $02 - $01             ; (14,10) column of 3D blocks (1 high)\n	  ;.db $09, Objects1Flag + $05 * $10 + $02 - $01             ; (14,10) column of 3D blocks (1 high)\n	  .db Objects4Flag + $01 * $10, $06 * $10 + $06 - $01 + PageFlag, $00  ; (6,1) upside down pipe\n	  .db Objects4Flag + 1*$10, $07 * $10 + 4 - $01, (1-$01)*$10+ 9, $36 ;1,9,4,1,$36 ;x,y,w,h,mt\n	  ;customobj 3,2,3,1,$20 ;x,y,w,h,mt\n	  .db Objects4Flag + 3*$10, $07 * $10 + 3 - $01, (1-$01)*$10+ 2, $20\n	  .db $57, Objects1Flag + $06 * $10 + $02 - $01             ; (12,9) Vertical pipe (2 blocks height)\n	  ;customobj 5,9,2,2,$61\n	  .db Objects4Flag + 5*$10, $07 * $10 + 2 - $01, (2-$01)*$10+ 9, $61\n	  .db Objects4Flag + 7*$10, $07 * $10 + 5 - $01, (3-$01)*$10+ 8, $90\n	  ;customobj 7,8,5,3,$90 ;x,y,w,h,mt\n	  .db Objects4Flag + 7*$10, $07 * $10 + 3 - $01, (1-$01)*$10+ 9, $20\n	  ;customobj 7,9,3,1,$20 ;x,y,w,h,mt\n	  .db $c6, Objects1Flag + $06 * $10 + $05 - $01\n	  .db Objects4Flag + $d*$10, $07 * $10 + 1 - $01, (1-$01)*$10+ 2, $8d\n	  ;customobj $d,2,1,1,$8d ;x,y,w,h,mt\n	  \n	  \n	  ;.db Objects4Flag + $01 * $10, $07 * $10 + $09 - $01, $05	; (12,6) bridge\n      ;.db $47, Objects1Flag + $01 * $10 + $05 - $01             ; (4,7) row of 5 bricks\n      ;.db $57, $00                                              ; (5,7) ? block with power-up\n	  \n	  ;customobj 5,6,1,1,$71									;commented this until i fix those fucking slopes\n	  ;customobj 6,5,1,1,$71\n	  \n      ;.db $66, Objects1Flag + $02 * $10 + $01 - $01\n	  ;.db $75, Objects1Flag + $02 * $10 + $01 - $01\n	  \n	  ;.db $63, $01                                               ; (6,3) ? block with coin\n	  ;.db Objects4Flag + 7*$10, $07 * $10 + 1 - $01 +$80, (1-$01)*$10+ 6, $8c\n	  ;customobj 7,6,1,1,$8c ;x,y,w,h,mt\n	  ;customobj 7,6,1,1,$8c ;x,y,w,h,mt\n\n	  ;.db Objects4Flag + $07 * $10, $07 * $10 + $01 - $01, $06, $8c\n      ;.db $77, $01                                              ; (7,7) ? block with coin\n	  ;.db $d0, Objects1Flag + $05 * $10 + $02 - $01             ; (14,10) column of 3D blocks (1 high)\n	  .db Objects4Flag + $e*$10, $07 * $10 + 8 - $01, (1-$01)*$10+ $b, $8a\n	  ;customobj $e,$b,8,1,$8a ;x,y,w,h,mt\n	  .db Objects4Flag + $e*$10, $07 * $10 + 8 - $01, (1-$01)*$10+ 8, $8e\n	  ;customobj $e,8,8,1,$8e ;x,y,w,h,mt\n	  ;customobjp $5,11,1,2,$00 ;x,y,w,h,mt\n	  .db Objects4Flag + 6*$10, $07 * $10 + 1 - $01 + $80, (6-$01)*$10 + 2, $8f\n	  ;customobjp 6,2,1,6,$8f ;x,y,w,h,mt\n	  \n      .db $68, Objects1Flag + $06 * $10 + $03 - $01; + PageFlag  ; (6,8) Vertical pipe (3 blocks height)\n	  \n      .db $e7, Objects1Flag + $06 * $10 + $04 - $01             ; (14,7) Vertical pipe (4 blocks height)\n      .db $97, Objects1Flag + $06 * $10 + WarpFlag + $04 - $01 + PageFlag ; (9,7) Vertical warp pipe (4 blocks height)\n	  .db Objects4Flag + $b*$10, $07 * $10 + 1 - $01, (1-$01)*$10+ $a, $8c\n      .db $06, $03 + PageFlag                                   ; (0,6) invisible block with 1-up\n	  customobj 0,4,6,1,$72 ;x,y,w,h,mt\n	  ;customobj 0,10,1,1,$8c ;x,y,w,h,mt\n	  \n	  .db $60, Objects1Flag + $02 * $10 + $02 - $01				; (6,0) row of blocks\n	  .db Objects4Flag + $06 * $10, $06 * $10 + $08 - $01, $01  ; (6,1) upside down pipe\n	  ;.db $83, Objects1Flag + $02 * $10 + $03 - $01\n	  .db $90, Objects1Flag + $02 * $10 + $02 - $01				; (9,0) row of blocks\n	  .db Objects4Flag + $09 * $10, $05 * $10 + $06 - $01, $01  ; (9,1) upside down pipe (enterable)\n	  \n	  ;.db Objects4Flag + $0b * $10, $07 * $10 + $05 - $01, $27, $8b	; (11,7) custom object with customizable lenght and height\n	  customobj 11,3,5,1,$72  ;x,y,w,h,mt\n	  customobj 12,7,5,3,$8b ;x,y,w,h,mt\n      ; x = 5, id = 0, width = 2\n      .db Objects2Flag + $05 * $10, $00 * $10 + $02 - $01       ; (5,) pit (2 blocks wide)\n      ; x = 13, y=7, id = 1, width = 3\n      .db $d7, Objects1Flag + $01 * $10 + $03 - $01             ; (13,7) row of 3 bricks\n      .db $e7, $00                                              ; (14,7) ? block with power-up\n      .db $03, Objects1Flag + $01 * $10 + $08 - $01 + PageFlag  ; (0,3) row of 8 bricks\n      ; x = 6, id = 0, width = 3\n      .db Objects2Flag + $06 * $10, $00 * $10 + $03 - $01       ; (6,) pit (3 blocks wide)\n\n      .db $b3, Objects1Flag + $01 * $10 + $03 - $01             ; (11,3) row of 3 bricks\n      .db $e3, $01                                              ; (14,3) ? block with coin\n      .db $e7, $07                                              ; (14,7) brick with multi-coin\n      .db $47, Objects1Flag + $01 * $10 + $01 - $01 + PageFlag  ; (4,7) single brick\n      .db $57, $06                                              ; (5,7) brick with starman\n      .db $a7, $01                                              ; (10,7) ? block with coin\n      .db $d3, $00                                              ; (13,3) ? block with power-up\n      .db $d7, $01                                              ; (13,7) ? block with coin\n      .db $07, $01 + PageFlag                                   ; (0,7) ? block with coin\n      .db $67, Objects1Flag + $01 * $10 + $01 - $01             ; (6,7) single brick\n\n      .db $93, Objects1Flag + $01 * $10 + $03 - $01             ; (9,3) row of 3 bricks\n      .db $03, Objects1Flag + $01 * $10 + $04 - $01 + PageFlag  ; (0,3) row of 4 bricks\n      ; x=1, id = 6, width = 2\n      .db Objects2Flag + $01 * $10, $06 * $10 + $02 - $01       ; (0,3) high ?-block row (2 wide)\n      .db $17, Objects1Flag + $01 * $10 + $02 - $01             ; (1,7) row of 2 bricks\n      ; x=6, id=3, width = 4\n      .db Objects4Flag + $06 * $10, $03 * $10 + $04 - $01       ; (6,) 3D block stairs ascending (4 width)\n      \n      ; x=12, y=7, id=5, height = 4\n      .db $c7, Objects1Flag + $05 * $10 + $04 - $01             ; (12,7) column of 3D blocks (4 high)\n      .db $d8, Objects1Flag + $05 * $10 + $03 - $01             ; (13,8) column of 3D blocks (3 high)\n      .db $e9, Objects1Flag + $05 * $10 + $02 - $01             ; (14,9) column of 3D blocks (2 high)\n      .db $fa, Objects1Flag + $05 * $10 + $01 - $01             ; (15,10) column of 3D blocks (1 high)\n      .db Objects4Flag + $04 * $10, $03 * $10 + $03 + PageFlag  ; (6,) 3D block stairs ascending (4 width)\n      \n      .db $87, Objects1Flag + $05 * $10 + $04 - $01             ; (8,7) column of 3D blocks (4 high)\n      .db Objects2Flag + $09 * $10, $00 * $10 + $02 - $01       ; (9,) pit (2 blocks wide)\n      .db $b7, Objects1Flag + $05 * $10 + $04 - $01             ; (11,7) column of 3D blocks (4 high)\n      .db $c8, Objects1Flag + $05 * $10 + $03 - $01             ; (12,8) column of 3D blocks (3 high)\n      .db $d9, Objects1Flag + $05 * $10 + $02 - $01             ; (13,9) column of 3D blocks (2 high)\n\n      .db $ea, Objects1Flag + $05 * $10 + $01 - $01             ; (14,10) column of 3D blocks (1 high)\n      .db $39, Objects1Flag + $06 * $10 + $02 - $01 + PageFlag  ; (3,9) Vertical pipe (2 blocks height)\n      .db $87, Objects1Flag + $01 * $10 + $02 - $01             ; (8,7) row of 2 bricks\n      .db $a7, $01                                              ; (10,7) ? block with coin\n      .db $b7, Objects1Flag + $01 * $10 + $01 - $01             ; (11,7) single brick\n      \n      .db $39, Objects1Flag + $06 * $10 + $02 - $01 + PageFlag  ; (3,9) Vertical pipe (2 blocks height)\n      ; x=5, id=3, width = 9\n      .db Objects4Flag + $05 * $10, $03 * $10 + $09 - $01       ; (5,) 3D block stairs ascending (9 width)\n      ; x=6, ?=$40, id = 1 \n      .db Objects3Flag + $06 * $10, $40 + $01 + PageFlag        ; (6,) flagpole\n      ; x=10, id=02, y=06\n      .db Objects4Flag + $0a * $10, $02 * $10 + $06             ; (10,6) castle\n\n      .db $fd                                                   ; end of level data marker\n.db $50, $21, $98, $72, $c6, $00, $d7, $00, $e7, $14\n.db $e8, $00, $f6, $15, $f9, $00, $0a, $80, $18, $11\n.db $29, $00, $38, $00, $47, $00, $56, $00, $68, $f2\n.db $e7, $73, $97, $fb, $06, $83, $5c, $01, $d7, $22\n.db $e7, $00, $03, $a7, $6c, $02, $b3, $22, $e3, $01\n.db $e7, $07, $47, $a0, $57, $06, $a7, $01, $d3, $00\n.db $d7, $01, $07, $81, $67, $20, $93, $22, $03, $a3\n.db $17, $21, $1c, $61, $6f, $33, $c7, $63, $d8, $62\n.db $e9, $61, $fa, $60, $4f, $b3, $87, $63, $9c, $01\n.db $b7, $63, $c8, $62, $d9, $61, $ea, $60, $39, $f1\n.db $87, $21, $a7, $01, $b7, $20, $39, $f1, $5f, $38\n.db $6d, $c1, $af, $26, $fd\nlevel 1-3/5-3
P:14F1D:TestLevel
P:155C0:L_GroundArea9:level 2-1
P:15CCD:L_GroundArea10:pipe intro area
P:15D42:L_GroundArea12:cloud level used in levels 2-1 and 5-2
P:15D57:L_GroundArea16:warp zone area used in level 4-2
P:15D5A:L_GroundArea17:level 8-1
P:15D5D:L_GroundArea19:level 8-2
P:15D60:L_GroundArea21:cloud level used in levels 3-1 and 6-2
P:15D63:L_UndergroundArea2:level 4-2
P:15D66:L_UndergroundArea3:underground bonus rooms area used in many levels
P:15D69:L_WaterArea1:water area used in levels 5-2 and 6-2
P:15D6C:L_WaterArea3:level 2-2/7-2\nlevel 7-2
P:15D6F:E73
P:15D6F:E91
P:15D6F:E93
P:15D70:L73
P:15D70:L91
P:15D70:L93
P:15D73::-------------------------------------------------------------------------------------
P:16000:E_CastleArea3:level 2-4
P:1603D:E_GroundArea8:level 2-3
P:16072:E_WaterArea2:level 2-2
P:160B1:E_GroundArea5:level 3-1
P:160E4:E_GroundArea22:level 3-2
P:1611B:L_CastleArea3:level 2-4
P:1664E:L_GroundArea5:level 3-1
P:16A53:L_GroundArea8:level 2-3
P:170A0:L_GroundArea22:level 3-2
P:17545:L_WaterArea2:level 2-2
P:18000:E_CastleArea4:08\nlevel 3-4
P:18039:E_GroundArea1:level 3-3
P:18076:E_GroundArea3:level 4-1
P:180BC:E42
P:1810B:E_GroundArea13:level 4-3
P:1813E:L_CastleArea4:level 3-4
P:18533:L_GroundArea1:level 3-3
P:189E6:L_GroundArea3:level 4-1
P:18F7D:L_GroundArea13:level 4-3
P:196A8:L42
P:1A000:E_CastleArea2:level 4-4
P:1A045:E_GroundArea18:level 5-2
P:1A07A:E_GroundArea11:level 5-1
P:1A0B1:E53:level 5-2
P:1A0EC:E54
P:1A127:L_CastleArea2:level 4-4
P:1A5CE:L_GroundArea11:level 5-1
P:1AC33:L_GroundArea18:level 5-2
P:1B252:L53:level 5-3
P:1B83B:L54
P:1C000:E_GroundArea15:09\nlevel 6-1
P:1C051:E_GroundArea4:level 6-2
P:1C088:E_GroundArea14:level 6-3
P:1C0CF:E64:level 6-4
P:1C100:E_GroundArea20:level 7-1
P:1C13B:L_GroundArea15: :--\nlevel 6-1
P:1C70C:L_GroundArea4:level 6-2
P:1CD0D:L_GroundArea14:level 6-3	  
P:1D39C:L64:level 6-4
P:1D637:L_GroundArea20:level 7-1
P:20000::fucking size inflation because fuck the nes and its fucking powers of fucking two\n0a
P:24000::0b
P:28000::0c
P:2C000::0d
P:30000::0e
P:34000::0f
P:38000::10
P:3C000:: fixed bank -- second half of original SMB code\n Relocated $c000-$ffff rom\nStart:\npretty standard 6502 type init here
P:3C002:Start:init PPU control register 1 
P:3C007::reset stack pointer
P:3C00A:VBlank1:wait two frames
P:3C00F:VBlank2
P:3C014::load default cold boot pointer
P:3C016::this is where we check for a warm boot
P:3C018:WBootCheck:check each score digit in the top score
P:3C01B::to see if we have a valid digit
P:3C01D::if not, give up and proceed with cold boot
P:3C022::second checkpoint, check to see if 
P:3C025::another location has a specific value
P:3C029::if passed both, load warm boot pointer
P:3C02B:ColdBoot:clear memory using pointer in Y
P:3C02E::reset delta counter load register
P:3C031::reset primary mode of operation
P:3C034::set warm boot flag
P:3C039::set seed for pseudorandom register
P:3C03E::enable all sound channels except dmc
P:3C043::turn off clipping for OAM and background
P:3C049::initialize both name tables
P:3C04C::set flag to disable screen output
P:3C04F::disable frame counter to make irq work
P:3C058::enable NMIs
P:3C05D:EndlessLoop:jmp EndlessLoop\njsr _FamitoneInit\nlda $00						 ;idk if this does something but literally is in smb2j\nendless loop, need I say more? -yes
P:3C088::lda #$01\nsta FramesMissed		;enable this to compensate the missed frame in the next frame logic (don't)
P:3C08A::read joypads so emulators doesn't mark this as lag frame hehe
P:3C090::perform spr-ram DMA access on $0200-$02ff
P:3C095::never disable NMI
P:3C098::save all other bits
P:3C0A4::(essentially $2000) but save other bits
P:3C0AF::set irq registers
P:3C106:NonMaskableInterrupt
P:3C12F::do sub to check if parallax level type and set if so if the textbox is not displaying
P:3C13C::(essentially $2000) but save other bits
P:3C13F::disable OAM and background display by default
P:3C144::get screen disable flag
P:3C147::if set, used bits as-is
P:3C149::otherwise reenable bits and save them
P:3C14E:ScreenOff:save bits for later but not in register at the moment
P:3C151::disable screen for now
P:3C156::reset flip-flop and reset scroll registers to zero
P:3C15B::store contents of A into scroll registers
P:3C15E::and end whatever subroutine led us here
P:3C161::reset spr-ram address register
P:3C164::perform spr-ram DMA access on $0200-$02ff
P:3C169::load control for pointer to buffer contents
P:3C16C::set indirect at $00 to pointer
P:3C176::update screen with buffer contents
P:3C17B::check for usage of $0341
P:3C182::get offset based on usage
P:3C183:InitBuffer
P:3C186::clear buffer header at last location
P:3C18E::reinit address control to $0301
P:3C191::copy mirror of $2001 to register
P:3C1AE::read joypads
P:3C1B1::handle pause
P:3C1B4::start with mario's score
P:3C1B6:TopScoreCheck:start with the lowest digit
P:3C1B9:GetScoreDiff:subtract each player digit from each high score digit
P:3C1BC::from lowest to highest, if any top score digit exceeds
P:3C1BF::any player digit, borrow will be set until a subsequent
P:3C1C0::subtraction clears it (player digit is higher than top)
P:3C1C3::check to see if borrow is still set, if so, no new high score
P:3C1C5::increment X and Y once to the start of the score
P:3C1C7:CopyScore:store player's score digits into high score memory area
P:3C1CF::do this until we have stored them all
P:3C1D3:NoTopSc
P:3C1DB::check for pause status
P:3C1E1::if master timer control not set, decrement
P:3C1E4::all frame and interval timers
P:3C1EB:DecTimers:load end offset for end of frame timers
P:3C1ED::decrement interval timer control,
P:3C1F0::if not expired, only frame timers will decrement
P:3C1F4::if control for interval timers expired,
P:3C1F7::interval timers will decrement along with frame timers
P:3C1F9:DecTimersLoop:check current timer
P:3C1FC::if current timer expired, branch to skip,
P:3C1FE::otherwise decrement the current timer
P:3C201:SkipExpTimer:ldy FramesMissed\nbeq +\nlda Timers,x\nbeq +\ndec Timers,x\nmove onto next timer
P:3C202::do this until all timers are dealt with
P:3C204:NoDecTimers:increment frame counter
P:3C206:PauseSkip
P:3C209::run the bankswitch thingy and the code of the bank 01
P:3C211::do sub to check if parallax level type and set if so 
P:3C214::if in pause mode, do not bother with sprites at all
P:3C21A::check for flag here
P:3C225:SkipThisThing:lda FinishedDemo\ncmp #$07\nbcs SkipMainOper\notherwise do one of many, many possible subroutines
P:3C228:SkipMainOper
P:3C230::lda Mirror_PPU_CTRL_REG1\nora #%10000000            ;reactivate NMIs\nsta Mirror_PPU_CTRL_REG1\nsta PPU_CTRL_REG1\nwe are done until the next frame!
P:3C231:VRAM_AddrTable_Low:-------------------------------------------------------------------------------------
P:3C245:VRAM_AddrTable_High
P:3C259:VRAM_Buffer_Offset
P:3C25B:EnemiesAndLoopsCore:check data here for MSB set
P:3C25D::if MSB set in enemy flag, branch ahead of jumps
P:3C25F::if data zero, branch
P:3C261::otherwise, jump to run enemy subroutines
P:3C264:ChkAreaTsk:check number of tasks to perform
P:3C269::if at a specific task, jump and leave
P:3C26D::otherwise, jump to process loop command/load enemies
P:3C270:ChkBowserF:mask out high nybble
P:3C273::use as pointer and load same place with different offset
P:3C278::if second enemy flag not set, also clear first one
P:3C27A:ExitELCore
P:3C27B:ChangeSizeOffsetAdder
P:3C28F:G:ColorRotatePalette:\n       .db $16, $30\nBlankPalette:\n      .db $3f, $08, $04, $ff, $ff, $ff, $ff, $00\nused based on area type\nPalette3Data:\n     .db $0f, $30, $22, $0f \n    .db $0f, $30, $21, $0f \n   .db $0f, $30, $21, $0c\n   .db $0f, $30, $16, $2d\n--------------------------------\nColorRotation:\nrts\n			  ;lda HurryUp\nbeq ExitColorRot\nldx VRAM_Buffer1_Offset  ;check vram buffer offset\ncpx #$31\nbcs ExitColorRot         ;if offset over 48 bytes, branch to leave\nldy #$00\nGetBlankPal:  ;lda BlankPalette,y       ;get blank palette for palette 3\nsta VRAM_Buffer1,x       ;store it in the vram buffer\ninx                      ;increment offsets\niny\ncpy #$08\nbcc GetBlankPal          ;do this until all bytes are copied\nldx VRAM_Buffer1_Offset  ;get current vram buffer offset\nlda #$03\nsta $00                  ;set counter here\nlda AreaType             ;get area type\nasl                      ;multiply by 4 to get proper offset\nasl\ntay                      ;save as offset here\netAreaPal:   ;lda Palette3Data,y       ;fetch palette to be written based on area type\nsta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer\niny\n inx\n dec $00                  ;decrement counter\n bpl GetAreaPal           ;do this until the palette is all copied\n ldx VRAM_Buffer1_Offset  ;get current vram buffer offset\n ldy timerupthing   	   ;get color cycling offset\n lda ColorRotatePalette,y\n sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette\n lda VRAM_Buffer1_Offset\n clc                      ;add seven bytes to vram buffer offset\n adc #$07\n sta VRAM_Buffer1_Offset\nExitColorRot:; rts                      ;leave\nloop command data\n-------------------------------------------------------------------------------------\n	   lda GameEngineSubroutine\n	   cmp #$05\n	   bne +\n	   ldx ObjectOffset\n	   lda Enemy_ID,x\n	   cmp #Fireworks\n	   beq +\n	   jmp RunStarFlagObj\nget offset for enemy object buffer
P:3C28F:RunEnemyObjectsCore
P:3C291::load value 0 for jump engine by default
P:3C295::if enemy object < $15, use default value
P:3C299::otherwise subtract $14 from the value and use
P:3C29A::as value for jump engine
P:3C29C:JmpEO
P:3C2A3::for objects $00-$14
P:3C2A5::15 for objects $15-$1f
P:3C2A7::16
P:3C2A9::17
P:3C2AB::18
P:3C2AD::19
P:3C2AF::1a
P:3C2B1::1b
P:3C2B3::1c
P:3C2B5::1d
P:3C2B7::1e
P:3C2B9::1f
P:3C2BB::20 for objects $20-$2f
P:3C2BD::21
P:3C2BF::22
P:3C2C1::23
P:3C2C3::24
P:3C2C5::25
P:3C2C7::26
P:3C2C9::27
P:3C2CB::28
P:3C2CD::29
P:3C2CF::2a
P:3C2D1::2b
P:3C2D3::2c
P:3C2D5::2d
P:3C2D7::2e
P:3C2D9::2f
P:3C2DB::30 for objects $30-$35
P:3C2DD::31
P:3C2DF::32
P:3C2E1::33
P:3C2E3::34
P:3C2E5::35
P:3C2E7::36
P:3C2E9::37
P:3C2EB::38
P:3C2ED::39
P:3C2EF::3a
P:3C2F1::3b
P:3C2F3::3c
P:3C2F5::3d
P:3C2F7::3e
P:3C2F9::3f
P:3C2FB::40
P:3C2FD::41
P:3C2FF::42
P:3C301::43
P:3C303:NoRunCode:--------------------------------
P:3C304:SignDo
P:3C310:RunRetainerObj:--------------------------------
P:3C319:RunNormalEnemies:--------------------------------\ninit sprite attributes
P:3C31E::set A to add 1 byte in order to get enemy offset
P:3C320::set Y to put offscreen bits in Enemy_OffscreenBits
P:3C323::add contents of X to A to get
P:3C324::appropriate offset, then give back to X
P:3C327::save offscreen bits offset to stack for now
P:3C329::do subroutine here
P:3C330::store here
P:3C339::mask together with previously saved low nybble
P:3C33B::store both here
P:3C33D::get offscreen bits offset from stack
P:3C33F::get value here and store elsewhere
P:3C346::get coordinates of enemy object 
P:3C348::relative to the screen
P:3C349::store value to add to A here
P:3C34C::add A to value stored
P:3C34E::use as enemy offset
P:3C34F::load vertical coordinate low
P:3C351::store here
P:3C354::load horizontal coordinate
P:3C356::subtract left edge coordinate
P:3C35A::store result here
P:3C362::store bitmask here for now
P:3C366::store another bitmask here for now and jump
P:3C368::get enemy object position relative
P:3C36A::to the left side of the screen
P:3C36E::store here
P:3C370::subtract borrow from current page location
P:3C372::of left side
P:3C375::if enemy object is beyond left edge, branch
P:3C379::if precisely at the left edge, branch
P:3C37B::if to the right of left edge, use value in $00 for A
P:3C37D:CMBit1:otherwise use contents of Y
P:3C37E::preserve bitwise whatever's in here
P:3C381::save masked offscreen bits here
P:3C384::if anything set here, branch
P:3C386::otherwise, do something else
P:3C38C:MoveBoundBoxOffscreen1:multiply offset by 4
P:3C38F::use as offset here
P:3C392::load value into four locations here and leave
P:3C3A7::check counter for d0 set
P:3C3B5::if master timer control set, skip to last routine
P:3C3BF:SkipMove
P:3C3C2:MovePiranhaPlant1
P:3C3C5:MoveUpsideDownPiranhaP1
P:3C3C8:EnemyMovementSubs
P:3C3D3::00 only objects $00-$14 use this table
P:3C3D5::01
P:3C3D7::02
P:3C3D9::03
P:3C3DB::04
P:3C3DD::05
P:3C3DF::06
P:3C3E1::07
P:3C3E3::08
P:3C3E5::09
P:3C3E7::0a
P:3C3E9::0b
P:3C3EB::0c
P:3C3ED::0d
P:3C3EF::0e
P:3C3F1::0f
P:3C3F3::10
P:3C3F5::11
P:3C3F7::12
P:3C3F9::dummy     ;13
P:3C3FB::14
P:3C3FD::15
P:3C3FF::16
P:3C401::17
P:3C403::18
P:3C405::19
P:3C407::1a
P:3C409::1b
P:3C40B::1c
P:3C40D::1d
P:3C40F::1e
P:3C411::1f
P:3C413::20
P:3C415::21
P:3C417::22
P:3C419:NoMoveCode:--------------------------------
P:3C41A:RunBowserFlame:--------------------------------
P:3C42C:RunFirebarObj:--------------------------------
P:3C432:RunSmallPlatform:--------------------------------
P:3C441::get OAM data offset
P:3C444::load tile number for small platforms
P:3C446::increment offset for tile numbers
P:3C447::dump A contents
P:3C44A::into third row sprites
P:3C44D::into second row sprites
P:3C453::and into first row sprites
P:3C456::dump tile number into all six sprites
P:3C459::increment offset for attributes
P:3C45A::load palette controls
P:3C45C::dump A contents
P:3C45F::into third row sprites
P:3C462::into second row sprites
P:3C468::and into first row sprites
P:3C46B::dump attributes into all six sprites
P:3C46E::decrement for original offset
P:3C470::get relative horizontal coordinate
P:3C476::dump as X coordinate into first and fourth sprites
P:3C47A::add eight pixels
P:3C47C::dump into second and fifth sprites
P:3C483::add eight more pixels
P:3C485::dump into third and sixth sprites
P:3C48B::get vertical coordinate
P:3C48E::save to stack
P:3C48F::if vertical coordinate below status bar,
P:3C491::do not mess with it
P:3C493::otherwise move first three sprites offscreen
P:3C495:TopSP
P:3C498::and into first row sprites
P:3C49B::dump vertical coordinate into Y coordinates
P:3C49E::pull from stack
P:3C4A0::add 128 pixels
P:3C4A3::if below status bar (taking wrap into account)
P:3C4A5::then do not change altered coordinate
P:3C4A7::otherwise move last three sprites offscreen
P:3C4A9:BotSP:dump vertical coordinate + 128 pixels
P:3C4AC::into Y coordinates
P:3C4B2::get offscreen bits
P:3C4B5::save to stack
P:3C4B6::check d3
P:3C4BA::if d3 was set, move first and
P:3C4BC::fourth sprites offscreen
P:3C4C2:SOfs:move out and back into stack
P:3C4C4::check d2
P:3C4C8::if d2 was set, move second and
P:3C4CA::fifth sprites offscreen
P:3C4D0:SOfs2:get from stack
P:3C4D1::check d1
P:3C4D5::if d1 was set, move third and
P:3C4D7::sixth sprites offscreen
P:3C4DD:ExSPl:get enemy object offset and leave
P:3C4E5:RunLargePlatform:--------------------------------
P:3C4F1::if master timer control set,
P:3C4F4::skip subroutine tree
P:3C4F9:SkipPT
P:3C502:LargePlatformSubroutines:--------------------------------
P:3C504::subtract $24 to get proper offset for jump table
P:3C50C::table used by objects $24-$2a
P:3C51A:EraseEnemyObject:-------------------------------------------------------------------------------------\nclear all enemy object variables
P:3C522::sta FloateyNum_Control,x
P:3C53A:MovePodoboo:-------------------------------------------------------------------------------------
P:3C540::check enemy timer
P:3C543::branch to move enemy if not expired
P:3C545::otherwise set up podoboo again
P:3C548::get part of LSFR
P:3C54B::set d7
P:3C54D::store as movement force
P:3C550::mask out high nybble
P:3C552::set for at least six intervals
P:3C554::store as new enemy timer
P:3C559::set vertical speed to move podoboo upwards
P:3C55B:PdbM:branch to impose gravity on podoboo
P:3C55E:ProcHammerBro:--------------------------------\n$00 - used in HammerBroJumpCode as bitmask\ncheck hammer bro's enemy state for d5 set
P:3C562::if not set, go ahead with code
P:3C564::otherwise jump to something else
P:3C567:ChkJH:check jump timer
P:3C569::if expired, branch to jump
P:3C56B::otherwise decrement jump timer
P:3C570::check offscreen bits
P:3C572::if hammer bro a little offscreen, skip to movement code
P:3C574::check hammer throwing timer
P:3C577::if not expired, skip ahead, do not throw hammer
P:3C579::otherwise get secondary hard mode flag
P:3C57C::get timer data using flag as offset
P:3C57F::set as new timer
P:3C582::do a sub here to spawn hammer object
P:3C585::if carry clear, hammer not spawned, skip to decrement timer
P:3C589::set d3 in enemy state for hammer throw
P:3C58D::jump to move hammer bro
P:3C590:DecHT:decrement timer
P:3C593::jump to move hammer bro
P:3C596:HammerBroJumpLData
P:3C598:HammerBroJumpCode:get hammer bro's enemy state
P:3C59A::mask out all but 3 LSB
P:3C59C::check for d0 set (for jumping)
P:3C59E::if set, branch ahead to moving code
P:3C5A0::load default value here
P:3C5A2::save into temp variable for now
P:3C5A4::set default vertical speed
P:3C5A6::check hammer bro's vertical coordinate
P:3C5A8::if on the bottom half of the screen, use current speed
P:3C5AA::otherwise set alternate vertical speed
P:3C5AC::check to see if hammer bro is above the middle of screen
P:3C5AE::increment preset value to $01
P:3C5B0::if above the middle of the screen, use current speed and $01
P:3C5B2::otherwise return value to $00
P:3C5B4::get part of LSFR, mask out all but LSB
P:3C5B9::if d0 of LSFR set, branch and use current speed and $00
P:3C5BB::otherwise reset to default vertical speed
P:3C5BD:SetHJ:set vertical speed for jumping
P:3C5BF::set d0 in enemy state for jumping
P:3C5C5::load preset value here to use as bitmask
P:3C5C7::and do bit-wise comparison with part of LSFR
P:3C5CA::then use as offset
P:3C5CB::check secondary hard mode flag
P:3C5D0::if secondary hard mode flag clear, set offset to 0
P:3C5D1:HJump:get jump length timer data using offset from before
P:3C5D4::save in enemy timer
P:3C5DA::get contents of part of LSFR, set d7 and d6, then
P:3C5DC::store in jump timer
P:3C5DE:MoveHammerBroXDir:move hammer bro a little to the left
P:3C5E2::change hammer bro's direction every 64 frames
P:3C5E6::if d6 set in counter, move him a little to the right
P:3C5E8:Shimmy:store horizontal speed
P:3C5EA::set to face right by default
P:3C5EC::get horizontal difference between player and hammer bro
P:3C5EF::if enemy to the left of player, skip this part
P:3C5F1::set to face left
P:3C5F2::check walking timer
P:3C5F5::if not yet expired, skip to set moving direction
P:3C5F9::otherwise, make the hammer bro walk left towards player
P:3C5FB:SetShim:set moving direction
P:3C5FD:MoveNormalEnemy:init Y to leave horizontal movement as-is 
P:3C601::check enemy state for d6 set, if set skip
P:3C603::to move enemy vertically, then horizontally if necessary
P:3C607::if set, branch to move enemy horizontally
P:3C60B::check enemy state for d5 set
P:3C60F::if set, branch to move defeated enemy object
P:3C614::check d2-d0 of enemy state for any set bits
P:3C616::if enemy in normal state, branch to move enemy horizontally
P:3C61A::if enemy in state used by spiny's egg, go ahead here
P:3C61E::if enemy in states $03 or $04, skip ahead to yet another part
P:3C620:FallE:set quick movement amount downwards
P:3C622::then check enemy state
P:3C624::if not set to unique state for spiny's egg, go ahead
P:3C626::and use, otherwise set different movement amount, continue on
P:3C628::set movement amount
P:3C62A::set maximum speed in A
P:3C62C::set movement amount here
P:3C62E::increment X for enemy offset
P:3C62F::set maximum speed here
P:3C631::set value to move downwards
P:3C633::jump to the code that actually moves it
P:3C636::get enemy object buffer offset and leave
P:3C63A::check for enemy state $02
P:3C63E::if found, branch to move enemy horizontally
P:3C640::check for d6 set
P:3C642::if not set, branch to something else
P:3C646::check for power-up object
P:3C64A::if any other object where d6 set, jump to set Y
P:3C64C:MEHor:increment offset for enemy offset
P:3C64D::position object horizontally according to
P:3C650:SlowM:ldx ObjectOffset            ;counters, return with saved value in A,\nrts
P:3C652:SteadM:get current horizontal speed
P:3C654::save to stack
P:3C655::if not moving or moving right, skip, leave Y alone    
P:3C659:AddHS
P:3C65A::add value here to slow enemy down if necessary
P:3C65D::save as horizontal speed temporarily
P:3C65F::increment offset for enemy offset
P:3C660::position object horizontally according to
P:3C663::counters, return with saved value in A, ;then do a sub to move horizontally
P:3C666::get old horizontal speed from stack and return to
P:3C668::original memory location, then leave
P:3C669:PlayerEnemyDiff:get distance between enemy object's
P:3C66B::horizontal coordinate and the player's
P:3C66C::horizontal coordinate
P:3C66E::and store here
P:3C672::subtract borrow, then leave
P:3C675:ReviveStunned
P:3C67F::if enemy timer not expired yet,
P:3C682::skip ahead to something else
P:3C684::otherwise initialize enemy state to normal
P:3C688::get d0 of frame counter
P:3C68A::use as Y and increment for movement direction
P:3C68C::store as pseudorandom movement direction
P:3C68E::decrement for use as pointer
P:3C68F::check primary hard mode flag
P:3C692::if not set, use pointer as-is
P:3C695::otherwise increment 2 bytes to next data
P:3C696:SetRSpd:load and store new horizontal speed
P:3C699::and leave
P:3C69C:MoveDefeatedEnemy:set quick movement amount downwards
P:3C69E::then check enemy state
P:3C6A0::if not set to unique state for spiny's egg, go ahead
P:3C6A2::and use, otherwise set different movement amount, continue on
P:3C6A4::set movement amount
P:3C6A6::set maximum speed in A
P:3C6A8::set movement amount here
P:3C6AA::increment X for enemy offset
P:3C6AB::set maximum speed here
P:3C6AD::set value to move downwards
P:3C6AF::jump to the code that actually moves it
P:3C6B2::get enemy object buffer offset and leave
P:3C6B4::increment offset for enemy offset
P:3C6B5::position object horizontally according to
P:3C6B8::counters, return with saved value in A,rai
P:3C6BB:ChkKillGoomba:check to see if enemy timer has reached
P:3C6BD::a certain point, and branch to leave if not
P:3C6C1::check for goomba object
P:3C6C7::branch if not found
P:3C6C9::clear all enemy object variables
P:3C6E8:NKGmba:leave!
P:3C6E9:ProcMoveRedPTroopa:--------------------------------\n--------------------------------
P:3C6EB::check for any vertical force or speed
P:3C6EE::branch if any found
P:3C6F0::initialize something here
P:3C6F3::check current vs. original vertical coordinate
P:3C6F8::if current => original, skip ahead to more code
P:3C6FA::get frame counter
P:3C6FC::mask out all but 3 LSB
P:3C6FE::if any bits set, branch to leave
P:3C700::otherwise increment red paratroopa's vertical position
P:3C702:NoIncPT:leave
P:3C703:MoveRedPTUpOrDown:check current vs. central vertical coordinate
P:3C707::if current < central, jump to move downwards
P:3C709::otherwise jump to move upwards
P:3C70C:MovPTDwn:move downwards
P:3C70F:MoveFlyGreenPTroopa:--------------------------------\n$00 - used to store adder for movement, also used as adder for platform\n$01 - used to store maximum value for secondary counter\ndo sub to increment primary and secondary counters
P:3C712::do sub to move green paratroopa accordingly, and horizontally
P:3C715::set Y to move green paratroopa down
P:3C719::check frame counter 2 LSB for any bits set
P:3C71B::branch to leave if set to move up/down every fourth frame
P:3C71F::check frame counter for d6 set
P:3C721::branch to move green paratroopa down if set
P:3C723::otherwise set Y to move green paratroopa up
P:3C725:YSway:store adder here
P:3C729::add or subtract from vertical position
P:3C72A::to give green paratroopa a wavy flight
P:3C72E:NoMGPT:leave!
P:3C72F:XMoveCntr_GreenPTroopa:load preset maximum value for secondary counter
P:3C731:XMoveCntr_Platform:store value here
P:3C735::branch to leave if not on
P:3C737::every fourth frame
P:3C739::get secondary counter
P:3C73B::get primary counter
P:3C73E::if d0 of primary counter set, branch elsewhere
P:3C740::compare secondary counter to preset maximum value
P:3C742::if equal, branch ahead of this part
P:3C744::increment secondary counter and leave
P:3C746:NoIncXM
P:3C747:IncPXM:increment primary counter and leave
P:3C74A:DecSeXM:put secondary counter in A
P:3C74B::if secondary counter at zero, branch back
P:3C74D::otherwise decrement secondary counter and leave
P:3C750:MoveWithXMCntrs:save secondary counter to stack
P:3C753::set value here by default
P:3C757::if d1 of primary counter is
P:3C759::set, branch ahead of this part here
P:3C75D::otherwise change secondary
P:3C75F::counter to two's compliment
P:3C764::load alternate value here
P:3C766:XMRight:store as moving direction
P:3C768::increment offset for enemy offset
P:3C769::position object horizontally according to
P:3C76C::counters, return with saved value in A,
P:3C76E::save value obtained from sub here
P:3C770::get secondary counter from stack
P:3C771::and return to original place
P:3C774:BlooberBitmasks:--------------------------------
P:3C776:MoveBloober
P:3C778::check enemy state for d5 set
P:3C77A::branch if set to move defeated bloober
P:3C77C::use secondary hard mode flag as offset
P:3C77F::get LSFR
P:3C782::mask out bits in LSFR using bitmask loaded with offset
P:3C785::if any bits set, skip ahead to make swim
P:3C788::check to see if on second or fourth slot (1 or 3)
P:3C789::if not, branch to figure out moving direction
P:3C78B::otherwise, load player's moving direction and
P:3C78D::do an unconditional branch to set
P:3C78F:FBLeft:set left moving direction by default
P:3C791::get horizontal difference between player and bloober
P:3C794::if enemy to the right of player, keep left
P:3C796::otherwise decrement to set right moving direction
P:3C797:SBMDir:set moving direction of bloober, then continue on here
P:3C799:BlooberSwim:execute sub to make bloober swim characteristically
P:3C79C::get vertical coordinate
P:3C79F::subtract movement force
P:3C7A2::check to see if position is above edge of status bar
P:3C7A4::if so, don't do it
P:3C7A6::otherwise, set new vertical position, make bloober swim
P:3C7A8:SwimX:check moving direction
P:3C7AB::if moving to the left, branch to second part
P:3C7AF::add movement speed to horizontal coordinate
P:3C7B2::store result as new horizontal coordinate
P:3C7B6::add carry to page location
P:3C7B8::store as new page location and leave
P:3C7BB:LeftSwim
P:3C7BD::subtract movement speed from horizontal coordinate
P:3C7C0::store result as new horizontal coordinate
P:3C7C4::subtract borrow from page location
P:3C7C6::store as new page location and leave
P:3C7C9:MoveDefeatedBloober:jump to move defeated bloober downwards
P:3C7CC:ProcSwimmingB:get enemy's movement counter
P:3C7CE::check for d1 set
P:3C7D0::branch if set
P:3C7D4::get 3 LSB of frame counter
P:3C7D6::and save it to the stack
P:3C7D7::get enemy's movement counter
P:3C7D9::check for d0 set
P:3C7DA::branch if set
P:3C7DC::pull 3 LSB of frame counter from the stack
P:3C7DD::branch to leave, execute code only every eighth frame
P:3C7E2::add to movement force to speed up swim
P:3C7E5::set movement force
P:3C7E8::set as movement speed
P:3C7EC::if certain horizontal speed, branch to leave
P:3C7EE::otherwise increment movement counter
P:3C7F0:BSwimE
P:3C7F1:SlowSwim:pull 3 LSB of frame counter from the stack
P:3C7F2::branch to leave, execute code only every eighth frame
P:3C7F7::subtract from movement force to slow swim
P:3C7FA::set movement force
P:3C7FD::set as movement speed
P:3C7FF::if any speed, branch to leave
P:3C801::otherwise increment movement counter
P:3C805::set enemy's timer
P:3C808:NoSSw:leave
P:3C809:ChkForFloatdown:get enemy timer
P:3C80C::branch if expired
P:3C80E:Floatdown:get frame counter
P:3C810::check for d0 set
P:3C811::branch to leave on every other frame
P:3C813::otherwise increment vertical coordinate
P:3C815:NoFD:leave
P:3C816:ChkNearPlayer:get vertical coordinate
P:3C818::add sixteen pixels (NTSC) or twelve pixels (PAL).
P:3C81A::compare result with player's vertical coordinate
P:3C81C::if modified vertical less than player's, branch
P:3C820::otherwise nullify movement counter
P:3C823:SwimCCXMoveData:--------------------------------\n--------------------------------\n$02 - used to hold preset values\n$03 - used to hold enemy state
P:3C825:MoveSwimmingCheepCheep:.db $04, $04 ;residual data, not used\ncheck cheep-cheep's enemy object state
P:3C827::for d5 set
P:3C829::if not set, continue with movement code
P:3C82B::otherwise jump to move defeated cheep-cheep downwards
P:3C82E:CCSwim:save enemy state in $03
P:3C830::get enemy identifier
P:3C833::subtract ten for cheep-cheep identifiers
P:3C835::use as offset
P:3C836::load value here
P:3C841::load horizontal force
P:3C845::subtract preset value from horizontal force
P:3C847::store as new horizontal force
P:3C84A::get horizontal coordinate
P:3C84C::subtract borrow (thus moving it slowly)
P:3C84E::and save as new horizontal coordinate
P:3C852::subtract borrow again, this time from the
P:3C854::page location, then save
P:3C859::load horizontal force
P:3C85D::subtract preset value from horizontal force
P:3C85F::store as new horizontal force
P:3C862::get horizontal coordinate
P:3C864::subtract borrow (thus moving it slowly)
P:3C866::and save as new horizontal coordinate
P:3C86A::subtract borrow again, this time from the
P:3C86C::page location, then save
P:3C870::save new value here
P:3C872::check enemy object offset
P:3C874::if in first or second slot, branch to leave
P:3C876::check movement flag
P:3C878::if movement speed set to $00,
P:3C87A::branch to move upwards
P:3C880::add preset value to dummy variable to get carry
P:3C882::and save dummy
P:3C885::get vertical coordinate
P:3C887::add carry to it plus enemy state to slowly move it downwards
P:3C889::save as new vertical coordinate
P:3C88D::add carry to page location and
P:3C88F::jump to end of movement code
P:3C892:CCSwimUpwards
P:3C896::subtract preset value to dummy variable to get borrow
P:3C898::and save dummy
P:3C89B::get vertical coordinate
P:3C89D::subtract borrow to it plus enemy state to slowly move it upwards
P:3C89F::save as new vertical coordinate
P:3C8A3::subtract borrow from page location
P:3C8A5:ChkSwimYPos:save new page location here
P:3C8A7::load movement speed to upwards by default
P:3C8A9::get vertical coordinate
P:3C8AC::subtract original coordinate from current
P:3C8AF::if result positive, skip to next part
P:3C8B1::otherwise load movement speed to downwards
P:3C8B5::get two's compliment of result
P:3C8B6::to obtain total difference of original vs. current
P:3C8B8:YPDiff:if difference between original vs. current vertical
P:3C8BA::coordinates < 15 pixels, leave movement speed alone
P:3C8BD::otherwise change movement speed
P:3C8BF:ExSwCC:leave
P:3C8C0:SkipFBar1:--------------------------------\n$00 - used as counter for firebar parts\n$01 - used for oscillated high byte of spin state or to hold horizontal adder\n$02 - used for oscillated high byte of spin state or to hold vertical adder\n$03 - used for mirror data\n$04 - used to store player's sprite 1 X coordinate\n$05 - used to evaluate mirror data\n$06 - used to store either screen X coordinate or sprite data offset\n$07 - used to store screen Y coordinate\n$ed - used to hold maximum length of firebar\n$ef - used to hold high byte of spinstate\nhorizontal adder is at first byte + high byte of spinstate,\nvertical adder is same + 8 bytes, two's compliment\nif greater than $08 for proper oscillation
P:3C8C1:ProcFirebar:set A to add 1 byte in order to get enemy offset
P:3C8C3::set Y to put offscreen bits in Enemy_OffscreenBits
P:3C8C6::add contents of X to A to get
P:3C8C7::appropriate offset, then give back to X
P:3C8CA::save offscreen bits offset to stack for now
P:3C8CC::do subroutine here
P:3C8D3::store here
P:3C8DC::mask together with previously saved low nybble
P:3C8DE::store both here
P:3C8E0::get offscreen bits offset from stack
P:3C8E2::get value here and store elsewhere
P:3C8E9::check for d3 set
P:3C8EC::if so, branch to leave
P:3C8F0::if master timer control set, branch
P:3C8F3::ahead of this part
P:3C8F5::load spinning speed of firebar
P:3C8F8::save spinning speed here
P:3C8FA::check spinning direction
P:3C8FC::if moving counter-clockwise, branch to other part
P:3C900::add spinning speed to what would normally be
P:3C901::the horizontal speed
P:3C905::add carry to what would normally be the vertical speed
P:3C90E::subtract spinning speed to what would normally be
P:3C90F::the horizontal speed
P:3C913::add carry to what would normally be the vertical speed
P:3C917::mask out all but 5 LSB
P:3C919::and store as new high byte of spinstate
P:3C91B:SusFbar:get high byte of spinstate
P:3C91D::check enemy identifier
P:3C921::if < $1f (long firebar), branch
P:3C923::check high byte of spinstate
P:3C925::if eight, branch to change
P:3C929::if not at twenty-four branch to not change
P:3C92B:SkpFSte
P:3C92C::add one to spinning thing to avoid horizontal state
P:3C930:SetupGFB:save high byte of spinning thing, modified or otherwise
P:3C932::get coordinates of enemy object 
P:3C934::relative to the screen
P:3C935::store value to add to A here
P:3C938::add A to value stored
P:3C93A::use as enemy offset
P:3C93B::load vertical coordinate low
P:3C93D::store here
P:3C940::load horizontal coordinate
P:3C942::subtract left edge coordinate
P:3C946::store result here
P:3C949::reload old object offset and leave
P:3C94B::jsr GetFirebarPosition     ;do a sub here (residual, too early to be used now)\nget OAM data offset
P:3C94E::get relative vertical coordinate
P:3C951::store as Y in OAM data
P:3C954::also save here
P:3C956::get relative horizontal coordinate
P:3C959::store as X in OAM data
P:3C95C::also save here
P:3C95E::lda #$01\nsta $00                     ;set $01 value here (not necessary)\ndraw fireball part and do collision detection
P:3C961::load value for short firebars by default
P:3C965::are we doing a long firebar?
P:3C967::no, branch then
P:3C969::otherwise load value for long firebars
P:3C96B:SetMFbar:store maximum value for length of firebars
P:3C96F::initialize counter here
P:3C971:DrawFbar:load high byte of spinstate
P:3C973::save high byte of spinstate to the stack
P:3C974::mask out low nybble
P:3C978::if lower than $09, branch ahead
P:3C97A::otherwise get two's compliment to oscillate
P:3C97F::store result, modified or not, here
P:3C981::load number of firebar ball where we're at
P:3C983::load offset to firebar position data
P:3C987::add oscillated high byte of spinstate
P:3C989::to offset here and use as new offset
P:3C98A::get data here and store as horizontal adder
P:3C98F::pull whatever was in A from the stack
P:3C990::save it again because we still need it
P:3C992::add eight this time, to get vertical adder
P:3C994::mask out high nybble
P:3C996::if lower than $09, branch ahead
P:3C99A::otherwise get two's compliment
P:3C99F::store result here
P:3C9A3::load offset to firebar position data again
P:3C9A7::this time add value in $02 to offset here and use as offset
P:3C9AA::get data here and store as vertica adder
P:3C9AF::pull out whatever was in A one last time
P:3C9B0::divide by eight or shift three to the right
P:3C9B3::use as offset
P:3C9B4::load mirroring data here
P:3C9B9::position it properly, draw it and do collision detection
P:3C9BC::check which firebar part
P:3C9C2::if we arrive at fifth firebar part,
P:3C9C5::get offset from long firebar and load OAM data offset
P:3C9C8::using long firebar offset, then store as new one here
P:3C9CA:NextFbar:move onto the next firebar part
P:3C9CE::if we end up at the maximum part, go on and leave
P:3C9D0::otherwise go back and do another
P:3C9D2:SkipFBar
P:3C9D3:DrawFirebar_Collision:store mirror data elsewhere
P:3C9D7::load OAM data offset for firebar
P:3C9D9::load horizontal adder we got from position loader
P:3C9DB::shift LSB of mirror data
P:3C9DD::if carry was set, skip this part
P:3C9E1::otherwise get two's compliment of horizontal adder
P:3C9E3:AddHA:add horizontal coordinate relative to screen to
P:3C9E4::horizontal adder, modified or otherwise
P:3C9E7::store as X coordinate here
P:3C9EA::store here for now, note offset is saved in Y still
P:3C9EC::compare X coordinate of sprite to original X of firebar
P:3C9EF::if sprite coordinate => original coordinate, branch
P:3C9F4::otherwise subtract sprite X from the
P:3C9F5::original one and skip this part
P:3C9FA:NoColFB1
P:3C9FD:SubtR1:subtract original X from the
P:3C9FE::current sprite X
P:3CA01:ChkFOfs:if difference of coordinates within a certain range,
P:3CA03::continue by handling vertical adder
P:3CA05::otherwise, load offscreen Y coordinate
P:3CA07::and unconditionally branch to move sprite offscreen
P:3CA09:VAHandl:if vertical relative coordinate offscreen,
P:3CA0C::skip ahead of this part and write into sprite Y coordinate
P:3CA10::load vertical adder we got from position loader
P:3CA12::shift LSB of mirror data one more time
P:3CA14::if carry was set, skip this part
P:3CA18::otherwise get two's compliment of second part
P:3CA1A:AddVA:add vertical coordinate relative to screen to 
P:3CA1B::the second data, modified or otherwise
P:3CA1E:SetVFbr:store as Y coordinate here
P:3CA21::also store here for now
P:3CA23:FirebarCollision:get frame counter
P:3CA25::divide by four
P:3CA27::save result to stack
P:3CA28::mask out all but last bit
P:3CA2A::set either tile $64 or $65 as fireball tile
P:3CA2C::thus tile changes every four frames
P:3CA2F::get from stack
P:3CA30::divide by four again
P:3CA32::load value $02 to set palette in attrib byte
P:3CA34::if last bit shifted out was not set, skip this
P:3CA36::otherwise flip both ways every eight frames
P:3CA38::store attribute byte and leave
P:3CA3B::return OAM data offset and save
P:3CA3C::to the stack for now
P:3CA52::if star mario invincibility timer
P:3CA57::or master timer controls set
P:3CA5A::then skip all of this
P:3CA5C::otherwise initialize counter
P:3CA60::if player's vertical high byte offscreen,
P:3CA61::skip all of this
P:3CA63::get player's vertical position
P:3CA65::get player's size
P:3CA68::if player small, branch to alter variables
P:3CA6D::if player big and not crouching, jump ahead
P:3CA6F:AdjSm:if small or big but crouching, execute this part
P:3CA71::first increment our counter twice (setting $02 as flag)
P:3CA74::then add 24 pixels to the player's
P:3CA75::vertical coordinate
P:3CA78:BigJp:get vertical coordinate, altered or otherwise, from Y
P:3CA79:FBCLoop:subtract vertical position of firebar
P:3CA7A::from the vertical coordinate of the player
P:3CA7C::if player lower on the screen than firebar, 
P:3CA7E::skip two's compliment part
P:3CA80::otherwise get two's compliment
P:3CA83:ChkVFBD:if difference => 8 pixels, skip ahead of this part
P:3CA87::if firebar on far right on the screen, skip this,
P:3CA89::because, really, what's the point?
P:3CA8D::get OAM X coordinate for sprite #1
P:3CA91::add four pixels
P:3CA93::store here
P:3CA95::subtract horizontal coordinate of firebar
P:3CA96::from the X coordinate of player's sprite 1
P:3CA98::if modded X coordinate to the right of firebar
P:3CA9A::skip two's compliment part
P:3CA9C::otherwise get two's compliment
P:3CA9F:ChkFBCl:if difference < 8 pixels, collision, thus branch
P:3CAA1::to process
P:3CAA3:Chk2Ofs:if value of $02 was set earlier for whatever reason,
P:3CAA5::branch to increment OAM offset and leave, no collision
P:3CAA9::otherwise get temp here and use as offset
P:3CAAE::add value loaded with offset to player's vertical coordinate
P:3CAB1::then increment temp and jump back
P:3CAB6:ChgSDir:set movement direction by default
P:3CAB8::if OAM X coordinate of player's sprite 1
P:3CABA::is greater than horizontal coordinate of firebar
P:3CABC::then do not alter movement direction
P:3CABE::otherwise increment it
P:3CABF:SetSDir:store movement direction here
P:3CAC3::save value written to $00 to stack
P:3CAC6::perform sub to hurt or kill player
P:3CACA::get value of $00 from stack
P:3CACC:NoColFB:get OAM data offset
P:3CACD::add four to it and save
P:3CAD2::get enemy object buffer offset and leave
P:3CAD5:PRandomSubtracter:--------------------------------
P:3CADA:FlyCCBPriority
P:3CADF:SetLSpd2:--------------------------------\n$00 - used to hold horizontal difference\n$01-$03 - used to hold difference adjusters
P:3CAE2:MoveLakitu:check lakitu's enemy state
P:3CAE4::for d5 set
P:3CAE6::if not set, continue with code
P:3CAE8::otherwise jump to move defeated lakitu downwards
P:3CAEB:ChkLS:if lakitu's enemy state not set at all,
P:3CAED::go ahead and continue with code
P:3CAF1::otherwise initialize moving direction to move to left
P:3CAF3::initialize frenzy buffer
P:3CAF8::load horizontal speed and do unconditional branch
P:3CAFA:Fr12S
P:3CAFC::set spiny identifier in frenzy buffer
P:3CB01:LdLDa:load values
P:3CB04::store in zero page
P:3CB08::do this until all values are stired
P:3CB0A::execute sub to set speed and create spinys
P:3CB8A:SetLSpd:set movement speed returned from sub
P:3CB8C::set moving direction to right by default
P:3CB90::get LSB of moving direction
P:3CB92::if set, branch to the end to use moving direction
P:3CB96::get two's compliment of moving speed
P:3CB9B::store as new moving speed
P:3CB9D::increment moving direction to left
P:3CB9E:SetLMov:store moving direction
P:3CBA0::move lakitu horizontally
P:3CBA3:PlayerLakituDiff:set Y for default value
P:3CBA5::get horizontal difference between enemy and player
P:3CBA8::branch if enemy is to the right of the player
P:3CBAA::increment Y for left of player
P:3CBAE::get two's compliment of low byte of horizontal difference
P:3CBB1::store two's compliment as horizontal difference
P:3CBB5:ChkLakDif:get low byte of horizontal difference
P:3CBB7::if within a certain distance of player, branch
P:3CBBB::otherwise set maximum distance
P:3CBBF::check if lakitu is in our current enemy slot
P:3CBC3::if not, branch elsewhere
P:3CBC5::compare contents of Y, now in A
P:3CBC6::to what is being used as horizontal movement direction
P:3CBC8::if moving toward the player, branch, do not alter
P:3CBCA::if moving to the left beyond maximum distance,
P:3CBCC::branch and alter without delay
P:3CBD6::if horizontal speed not yet at zero, branch to leave
P:3CBDA:SetLMovD:set horizontal direction depending on horizontal
P:3CBDB::difference between enemy and player if necessary
P:3CBDD:ChkPSpeed
P:3CBDF::mask out all but four bits in the middle
P:3CBE1::divide masked difference by four
P:3CBE3::store as new value
P:3CBE5::init offset
P:3CBE9::if player not moving horizontally, branch
P:3CBEE::if scroll speed not set, branch to same place
P:3CBF0::otherwise increment offset
P:3CBF3::if player not running, branch
P:3CBFA::if scroll speed below a certain amount, branch
P:3CBFC::to same place
P:3CBFE::otherwise increment once more
P:3CBFF:ChkSpinyO:check for spiny object
P:3CC03::branch if not found
P:3CC05::if player not moving, skip this part
P:3CC09:ChkEmySpd:check vertical speed
P:3CC0B::branch if nonzero
P:3CC0D::otherwise reinit offset
P:3CC0F:SubDifAdj:get one of three saved values from earlier
P:3CC12::get saved horizontal difference
P:3CC14:SPixelLak:subtract one for each pixel of horizontal difference
P:3CC15::from one of three saved values
P:3CC18::branch until all pixels are subtracted, to adjust difference
P:3CC1A:ExMoveLak:leave!!!
P:3CC1B:BridgeCollapse:-------------------------------------------------------------------------------------\n$04-$05 - used to store name table address in little endian order\nget enemy offset for bowser
P:3CC1E::check enemy object identifier for bowser
P:3CC20::if not found, branch ahead,
P:3CC22::metatile removal not necessary
P:3CC24::store as enemy offset here
P:3CC26::if bowser in normal state, skip all of this
P:3CC2A::if bowser's state has d6 clear, skip to silence music
P:3CC2E::check bowser's vertical coordinate
P:3CC30::if bowser not yet low enough, skip this part ahead
P:3CC34:SetM2:silence music
P:3CC38::move onto next secondary mode in autoctrl mode
P:3CC3B::jump to empty all enemy slots and then leave  
P:3CC3E:MoveD_Bowser:do a sub to move bowser downwards
P:3CC41::jump to draw bowser's front and rear, then leave
P:3CC44:RemoveBridge:decrement timer to control bowser's feet
P:3CC47::if not expired, skip all of this
P:3CC4B::otherwise, set timer now
P:3CC51::invert bit to control bowser's feet
P:3CC56::put high byte of name table address here for now
P:3CC5A::get bridge collapse offset here
P:3CC5D::load low byte of name table address and store here
P:3CC62::increment vram buffer offset
P:3CC66::set offset for tile data for sub to draw blank metatile
P:3CC68::do sub here to remove bowser's bridge metatiles
P:3CC6B::get enemy offset
P:3CC6D::set new vram buffer offset
P:3CC70::load the fireworks/gunfire sound into the square 2 sfx
P:3CC72::queue while at the same time loading the brick
P:3CC74::shatter sound into the noise sfx queue thus
P:3CC76::producing the unique sound of the bridge collapsing 
P:3CC78::increment bridge collapse offset
P:3CC7E::if bridge collapse offset has not yet reached
P:3CC80::the end, go ahead and skip this part
P:3CC82::initialize vertical speed
P:3CC84::and movement force
P:3CC86::initialize whatever vertical speed bowser has
P:3CC8B::set bowser's state to one of defeated states (d6 set)
P:3CC8F::play bowser defeat sound
P:3CC91:NoBFall:jump to code that draws bowser
P:3CC94:PRandomRange:--------------------------------
P:3CC98:RunBowser:if d5 in enemy state is not set
P:3CC9A::then branch elsewhere to run bowser
P:3CC9E::otherwise check vertical position
P:3CCA0::if above a certain point, branch to move defeated bowser
P:3CCA2::otherwise proceed to KillAllEnemies
P:3CCA4:KillAllEnemies:start with last enemy slot
P:3CCA6:KillLoop
P:3CCB0::branch to kill enemy objects
P:3CCB3::move onto next enemy slot
P:3CCB4::do this until all slots are emptied
P:3CCB6::empty frenzy buffer
P:3CCB9::get enemy object offset and leave
P:3CCBC:KillAllEnemiesNoFlag:start with last enemy slot
P:3CCC4::branch to kill enemy objects
P:3CCC7::move onto next enemy slot
P:3CCC8::do this until all slots are emptied
P:3CCCA::empty frenzy buffer
P:3CCCD::get enemy object offset and leave
P:3CCD0:BowserControl
P:3CCD2::empty frenzy buffer
P:3CCD5::if master timer control not set,
P:3CCD8::skip jump and execute code here
P:3CCDA::otherwise, jump over a bunch of code
P:3CCDD:ChkMouth:check bowser's mouth
P:3CCE0::if bit clear, go ahead with code here
P:3CCE2::otherwise skip a whole section starting here
P:3CCE5:FeetTmr:decrement timer to control bowser's feet
P:3CCE8::if not expired, skip this part
P:3CCEA::otherwise, reset timer
P:3CCEF::and invert bit used
P:3CCF2::to control bowser's feet
P:3CCF7:ResetMDr:check frame counter
P:3CCF9::if not on every sixteenth frame, skip
P:3CCFB::ahead to continue code
P:3CCFD::otherwise reset moving/facing direction every
P:3CCFF::sixteen frames
P:3CD01:B_FaceP:if timer set here expired,
P:3CD04::branch to next section
P:3CD06::get distance between enemy object's
P:3CD08::horizontal coordinate and the player's
P:3CD09::horizontal coordinate
P:3CD0B::and store here
P:3CD0F::subtract borrow, then leave
P:3CD11::and branch if bowser to the right of the player
P:3CD15::set bowser to move and face to the right
P:3CD19::set movement speed
P:3CD1E::set timer here
P:3CD21::set timer used for bowser's flame
P:3CD26::if bowser to the right past a certain point,
P:3CD28::skip ahead to some other section
P:3CD2A:GetPRCmp:get frame counter
P:3CD2E::execute this code every fourth frame, otherwise branch
P:3CD32::if bowser not at original horizontal position,
P:3CD35::branch to skip this part
P:3CD3A::get pseudorandom offset
P:3CD3D::load value using pseudorandom offset
P:3CD40::and store here
P:3CD43:GetDToO
P:3CD4A::add movement speed to bowser's horizontal
P:3CD4B::coordinate and save as new horizontal position
P:3CD52::if bowser moving and facing to the right, skip ahead
P:3CD56::set default movement speed here (move left)
P:3CD58::get difference of current vs. original
P:3CD59::horizontal position
P:3CD5C::if current position to the right of original, skip ahead
P:3CD60::get two's compliment
P:3CD63::set alternate movement speed here (move right)
P:3CD65:CompDToO:compare difference with pseudorandom value
P:3CD68::if difference < pseudorandom value, leave speed alone
P:3CD6A::otherwise change bowser's movement speed
P:3CD6D:HammerChk:if timer set here not expired yet, skip ahead to
P:3CD70::some other section of code
P:3CD72::otherwise start by moving bowser downwards
P:3CD75::check world number
P:3CD7A::if world 1-5, skip this part (not time to throw hammers yet)
P:3CD7E::check to see if it's time to execute sub
P:3CD80::if not, skip sub, otherwise
P:3CD82::execute sub on every fourth frame to spawn misc object (hammer)
P:3CD85:SetHmrTmr
P:3CD8A::then skip to world number check for flames
P:3CDA3::ora #%00000001
P:3CDA8::get pseudorandom offset
P:3CDAB::get value using pseudorandom offset
P:3CDAE::set for timer here
P:3CDB1:SkipToFB:jump to execute flames code
P:3CDB4:MakeBJump:if timer not yet about to expire,
P:3CDB6::skip ahead to next part
P:3CDB8::otherwise decrement vertical coordinate
P:3CDBA::initialize vertical speed
P:3CDBC::and movement force
P:3CDBE::initialize movement amount
P:3CDC3::set vertical speed to move bowser upwards
P:3CDC5:ChkFireB:check world number here
P:3CDC8::world 8?
P:3CDCA::if so, execute this part here
P:3CDCC::world 6-7?
P:3CDCE::if so, skip this part here
P:3CDD0:SpawnFBr:check timer here
P:3CDD3::if not expired yet, skip all of this
P:3CDD7::set timer here
P:3CDDD::invert bowser's mouth bit to open
P:3CDDF::and close bowser's mouth
P:3CDE2::if bowser's mouth open, loop back
P:3CDE4::get timing for bowser's flame
P:3CDEA::if secondary hard mode flag not set, skip this
P:3CDED::otherwise subtract from value in A
P:3CDEF:SetFBTmr:set value as timer here
P:3CDF2::put bowser's flame identifier
P:3CDF4::in enemy frenzy buffer
P:3CDF7:BowserGfxHandler:--------------------------------\ndo a sub here to process bowser's front
P:3CDFA::load default value here to position bowser's rear
P:3CDFC::check moving direction
P:3CDFF::if moving left, use default
P:3CE01::otherwise load alternate positioning value here
P:3CE03:CopyFToR:move bowser's rear object position value to A
P:3CE05::add to bowser's front object horizontal coordinate
P:3CE0A::store A as bowser's rear horizontal coordinate
P:3CE0F::add eight pixels to bowser's front object
P:3CE10::vertical coordinate and store as vertical coordinate
P:3CE12::for bowser's rear
P:3CE17::copy enemy state directly from front to rear
P:3CE1C::copy moving direction also
P:3CE1F::save enemy object offset of front to stack
P:3CE22::put enemy object offset of rear as current
P:3CE27::set bowser's enemy identifier
P:3CE29::store in bowser's rear object
P:3CE2B::do a sub here to process bowser's rear
P:3CE2F::get original enemy object offset
P:3CE32::nullify bowser's front/rear graphics flag
P:3CE37:ExBGfxH:leave!
P:3CE38:ProcessBowserHalf:increment bowser's graphics flag, then run subroutines
P:3CE3B::to get offscreen bits, relative position and draw bowser (finally!)
P:3CE40::if either enemy object not in normal state, branch to leave
P:3CE44::set bounding box size control
P:3CE47::get bounding box coordinates
P:3CE4A::do player-to-enemy collision detection
P:3CE4D:FlameTimerData:-------------------------------------------------------------------------------------\n$00 - used to hold movement force and tile number\n$01 - used to hold sprite attribute data
P:3CE55:SetFlameTimer:load counter as offset
P:3CE58::increment
P:3CE5B::mask out all but 3 LSB
P:3CE5E::to keep in range of 0-7
P:3CE63::load value to be used then leave
P:3CE66:ExFl
P:3CE67:FlameYPosData1
P:3CE6B:ProcBowserFlame:if master timer control flag set,
P:3CE6E::skip all of this
P:3CE70::load default movement force
P:3CE75::if secondary hard mode flag not set, use default
P:3CE77::otherwise load alternate movement force to go faster
P:3CE79:SFlmX:store value here
P:3CE7E::subtract value from movement force
P:3CE81::save new value
P:3CE86::subtract one from horizontal position to move
P:3CE88::to the left
P:3CE8C::subtract borrow from page location
P:3CE90::get some value here and use as offset
P:3CE93::load vertical coordinate
P:3CE95::compare against coordinate data using $0417,x as offset
P:3CE98::if equal, branch and do not modify coordinate
P:3CE9B::otherwise add value here to coordinate and store
P:3CE9E::as new vertical coordinate
P:3CEA0:SetGfxF:get new relative coordinates
P:3CEA3::if bowser's flame not in normal state,
P:3CEA5::branch to leave
P:3CEA7::otherwise, continue
P:3CEA9::write first tile number
P:3CEAB::load attributes without vertical flip by default
P:3CEAF::invert vertical flip bit every 2 frames
P:3CEB1::if d1 not set, write default value
P:3CEB3::otherwise write value with vertical flip bit set
P:3CEB5:FlmeAt:set bowser's flame sprite attributes here
P:3CEB7::get OAM data offset
P:3CEBC:DrawFlameLoop:get Y relative coordinate of current enemy object
P:3CEBF::write into Y coordinate of OAM data
P:3CEC4::write current tile number into OAM data
P:3CEC7::increment tile number to draw more bowser's flame
P:3CECB::write saved attributes into OAM data
P:3CED1::write X relative coordinate of current enemy object
P:3CED7::then add eight to it and store
P:3CEDD::increment Y four times to move onto the next OAM
P:3CEDE::move onto the next OAM, and branch if three
P:3CEDF::have not yet been done
P:3CEE3::reload original enemy offset
P:3CEE5::get offscreen information
P:3CEE8::get OAM data offset
P:3CEEB::get enemy object offscreen bits
P:3CEEE::move d0 to carry and result to stack
P:3CEF0::branch if carry not set
P:3CEF2::otherwise move sprite offscreen, this part likely
P:3CEF4::residual since flame is only made of three sprites
P:3CEF7:M3FOfs:get bits from stack
P:3CEF8::move d1 to carry and move bits back to stack
P:3CEFA::branch if carry not set again
P:3CEFC::otherwise move third sprite offscreen
P:3CF01:M2FOfs:get bits from stack again
P:3CF02::move d2 to carry and move bits back to stack again
P:3CF04::branch if carry not set yet again
P:3CF06::otherwise move second sprite offscreen
P:3CF0B:M1FOfs:get bits from stack one last time
P:3CF0C::move d3 to carry
P:3CF0D::branch if carry not set one last time
P:3CF11::otherwise move first sprite offscreen
P:3CF14:ExFlmeD:leave
P:3CF15:RunFireworks:--------------------------------\ndecrement explosion timing counter here
P:3CF18::if not expired, skip this part
P:3CF1C::reset counter
P:3CF1F::increment explosion graphics counter
P:3CF23::check explosion graphics counter
P:3CF25::if at a certain point, branch to kill this object
P:3CF27:SetupExpl:get relative coordinates of explosion
P:3CF2A::copy relative coordinates
P:3CF2D::from the enemy object to the fireball object
P:3CF30::first vertical, then horizontal
P:3CF36::get OAM data offset
P:3CF39::get explosion graphics counter
P:3CF3B::do a sub to draw the explosion then leave
P:3CF3E:FireworksSoundScore:disable enemy buffer flag
P:3CF42::play fireworks/gunfire sound
P:3CF46::set part of score modifier for 500 points
P:3CF4B::jump to award points accordingly then leave
P:3CF4E:StarFlagYPosAdder:--------------------------------
P:3CF52:StarFlagXPosAdder
P:3CF56:StarFlagTileData
P:3CF5A:RunStarFlagObj:initialize enemy frenzy buffer
P:3CF5F::check star flag object task number here
P:3CF62::if greater than 5, branch to exit
P:3CF66::otherwise jump to appropriate sub
P:3CF6D:: This works pretty well to remove timer points count down
P:3CF73:GameTimerFireworks:set default state for star flag object
P:3CF75::get game timer's last digit
P:3CF7A::if last digit of game timer set to 1, skip ahead
P:3CF7C::otherwise load new value for state
P:3CF80::if last digit of game timer set to 3, skip ahead
P:3CF82::otherwise load one more potential value for state
P:3CF86::if last digit of game timer set to 6, skip ahead
P:3CF88::otherwise set value for no fireworks
P:3CF8A:SetFWC:set fireworks counter here
P:3CF8D::set whatever state we have in star flag object
P:3CF8F:IncrementSFTask1:increment star flag object task number
P:3CF9C:StarFlagExit:jmp KillAllEnemiesNoFlag\nleave
P:3CF9D:Toyota2
P:3CF9F::set select timer (used for world 8 ending only)
P:3CFA4::another short delay, then on to the next task
P:3CFAB:AwardGameTimerPoints2
P:3CFAD::check all game timer digits for any intervals left
P:3CFB9::if no time left on game timer at all, branch to next task
P:3CFBE:AwardGameTimerPoints
P:3CFC0::check all game timer digits for any intervals left
P:3CFCC::if no time left on game timer at all, branch to next task
P:3CFCE:AwardTimerCastle
P:3CFD0::check frame counter for d2 set (skip ahead
P:3CFD2::for four frames every four frames) branch if not set
P:3CFDB::load timer tick sound
P:3CFDD:NoTTick:set offset here to subtract from game timer's last digit
P:3CFDF::set adder here to $ff, or -1, to subtract one
P:3CFE1::from the last digit of the game timer
P:3CFE6::subtract digit
P:3CFEB::set now to add 50 points
P:3CFF1::per game timer interval subtracted
P:3CFFC:EndAreaPoints:load offset for mario's score by default
P:3CFFE:ELPGive:award 50 points per game timer interval
P:3D001::add four to set nybble for game timer
P:3D003::jump to print the new score and game timer
P:3D006:RaiseFlagSetoffFWorks:lda Enemy_Y_Position,x  ;check star flag's vertical position\ncmp #$72                ;against preset value\nbcc SetoffF             ;if star flag higher vertically, branch to other code\ndec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel\njmp DrawStarFlag        ;and skip this part here\ncheck fireworks counter
P:3D006:SetoffF
P:3D009::if no fireworks left to go off, skip this part
P:3D00B::if no fireworks set to go off, skip this part
P:3D00F::otherwise set fireworks object in frenzy queue
P:3D012:DrawStarFlag
P:3D013:DSFLoop:jsr RelativeEnemyPosition  ;get relative coordinates of star flag\nldy Enemy_SprDataOffset,x  ;get OAM data offset\nldx #$03                   ;do four sprites\nlda Enemy_Rel_YPos         ;get relative vertical coordinate\nclc\nadc StarFlagYPosAdder,x    ;add Y coordinate adder data\nsta Sprite_Y_Position,y    ;store as Y coordinate\nlda StarFlagTileData,x     ;get tile number\nsta Sprite_Tilenumber,y    ;store as tile number\nlda #$22                   ;set palette and background priority bits\nsta Sprite_Attributes,y    ;store as attributes\nlda Enemy_Rel_XPos         ;get relative horizontal coordinate\nclc\nadc StarFlagXPosAdder,x    ;add X coordinate adder data\nsta Sprite_X_Position,y    ;store as X coordinate\niny\niny                        ;increment OAM data offset four bytes\niny                        ;for next sprite\niny\ndex                        ;move onto next sprite\nbpl DSFLoop                ;do this until all sprites are done\nldx ObjectOffset           ;get enemy object offset and leave\nrts\njsr DrawStarFlag          ;do sub to draw star flag
P:3D013:DrawFlagSetTimer
P:3D017::set interval timer here
P:3D01A:IncrementSFTask2:move onto next task
P:3D01E:DelayToAreaEnd:jsr DrawStarFlag          ;do sub to draw star flag\nif interval timer set in previous task
P:3D021::not yet expired, branch to leave
P:3D02E::if event music buffer empty,
P:3D036:StarFlagExit2:jmp IncrementSFTask2      ;branch to increment task\notherwise leave
P:3D037:Player_Difference:--------------------------------\n$00 - used to store horizontal difference between player and piranha plant
P:3D039:MovePiranhaPlant:check enemy state
P:3D03B::if set at all, branch to leave
P:3D03D::check enemy's timer here
P:3D040::branch to end if not yet expired
P:3D042::check movement flag
P:3D044::if moving, skip to part ahead
P:3D046::if currently rising, branch 
P:3D048::to move enemy upwards out of pipe
P:3D04A::get distance between enemy object's
P:3D04C::horizontal coordinate and the player's
P:3D04D::horizontal coordinate
P:3D04F::and store here
P:3D053::subtract borrow, then leave
P:3D055::piranha plant, and branch if enemy to right of player
P:3D057::otherwise get saved horizontal difference
P:3D05B::and change to two's compliment
P:3D05E::save as new horizontal difference
P:3D060:ChkPlayerNearPipe
P:3D06E::get saved horizontal difference
P:3D073::if player within a certain distance, branch to leave
P:3D075:ReversePlantSpeed:get vertical speed
P:3D079::change to two's compliment
P:3D07C::save as new vertical speed
P:3D07E::increment to set movement flag
P:3D080:SetupToMovePPlant:get original vertical coordinate (lowest point)
P:3D083::get vertical speed
P:3D085::branch if moving downwards
P:3D087::otherwise get other vertical coordinate (highest point)
P:3D08A:RiseFallPiranhaPlant:save vertical coordinate here
P:3D097::get frame counter
P:3D09A::branch to leave if d0 set (execute code every other frame)
P:3D09C::get master timer control
P:3D09F::branch to leave if set (likely not necessary)
P:3D0A1::get current vertical coordinate
P:3D0A4::add vertical speed to move up or down
P:3D0A6::save as new vertical coordinate
P:3D0A8::compare against low or high coordinate
P:3D0AA::branch to leave if not yet reached
P:3D0AE::otherwise clear movement flag
P:3D0B2::set timer to delay piranha plant movement
P:3D0B5:PutinPipe:then leave
P:3D0B6:BalancePlatform:-------------------------------------------------------------------------------------\n$07 - spinning speed\n-------------------------------------------------------------------------------------\n$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope\n$01 - used to hold high byte of name table for rope\n$02 - used to hold page location of rope\ncheck high byte of vertical position
P:3D0BC::if far below screen, kill the object
P:3D0BF:DoBPl:get object's state (set to $ff or other platform offset)
P:3D0C1::if doing other balance platform, branch to leave
P:3D0C4:CheckBalPlatform:save offset from state as Y
P:3D0C5::get collision flag of platform
P:3D0C8::store here
P:3D0CA::get moving direction
P:3D0CE::if set, jump here
P:3D0D1:ChkForFall:check if platform is above a certain point
P:3D0D5::if not, branch elsewhere
P:3D0D7::if collision flag is set to same value as
P:3D0D9::enemy state, branch to make platforms fall
P:3D0DC::otherwise add 2 pixels to vertical position
P:3D0DE::of current platform and branch elsewhere
P:3D0E0::to make platforms stop
P:3D0E3:MakePlatformFall:make platforms fall
P:3D0E6:ChkOtherForFall:check if other platform is above a certain point
P:3D0E9::if not, branch elsewhere
P:3D0EB::if collision flag is set to same value as
P:3D0ED::enemy state, branch to make platforms fall
P:3D0F0::otherwise add 2 pixels to vertical position
P:3D0F2::of other platform and branch elsewhere
P:3D0F5::jump to stop movement and do not return
P:3D0F8:ChkToMoveBalPlat
P:3D0FB::save vertical position to stack
P:3D0FE::get collision flag
P:3D101::branch if collision
P:3D106::add $05 to contents of moveforce, whatever they be
P:3D109::store here
P:3D10D::add carry to vertical speed
P:3D10F::branch if moving downwards
P:3D111::branch elsewhere if moving upwards
P:3D115::check if there's still a little force left
P:3D117::if not enough, branch to stop movement
P:3D119::otherwise keep branch to move upwards
P:3D11B:ColFlg:if collision flag matches
P:3D11D::current enemy object offset, branch
P:3D11F:PlatUp:do a sub to move upwards
P:3D122::jump ahead to remaining code
P:3D125:PlatSt:do a sub to stop movement
P:3D128::jump ahead to remaining code
P:3D12B:PlatDn:do a sub to move downwards
P:3D12E:DoOtherPlatform:get offset of other platform
P:3D130::get old vertical coordinate from stack
P:3D132::get difference of old vs. new coordinate
P:3D135::add difference to vertical coordinate of other
P:3D138::platform to move it in the opposite direction
P:3D13B::if no collision, skip this part here
P:3D140::put offset which collision occurred here
P:3D141::and use it to position player accordingly
P:3D144:DrawEraseRope:get enemy object offset
P:3D146::check to see if current platform is
P:3D149::moving at all
P:3D14C::if not, skip all of this and branch to leave
P:3D14E::get vram buffer offset
P:3D151::if offset beyond a certain point, go ahead
P:3D153::and skip this, branch to leave
P:3D158::save two copies of vertical speed to stack
P:3D15A::do a sub to figure out where to put new bg tiles
P:3D15D::write name table address to vram buffer
P:3D15F::first the high byte, then the low
P:3D167::set length for 2 bytes
P:3D16C::if platform moving upwards, branch 
P:3D16F::to do something else
P:3D173::otherwise put tile numbers for left
P:3D176::and right sides of rope in vram buffer
P:3D17B::jump to skip this part
P:3D17E:EraseR1:put blank tiles in vram buffer
P:3D180::to erase rope
P:3D186:OtherRope:get offset of other platform from state
P:3D189::use as Y here
P:3D18A::pull second copy of vertical speed from stack
P:3D18B::invert bits to reverse speed
P:3D18D::do sub again to figure out where to put bg tiles  
P:3D190::write name table address to vram buffer
P:3D192::this time we're doing putting tiles for
P:3D195::the other platform
P:3D19C::set length again for 2 bytes
P:3D19F::pull first copy of vertical speed from stack
P:3D1A0::if moving upwards (note inversion earlier), skip this
P:3D1A4::otherwise put tile numbers for left
P:3D1A7::and right sides of rope in vram
P:3D1A9::transfer buffer
P:3D1AC::jump to skip this part
P:3D1AF:EraseR2:put blank tiles in vram buffer
P:3D1B1::to erase rope
P:3D1B7:EndRp:put null terminator at the end
P:3D1BC::add ten bytes to the vram buffer offset
P:3D1BF::and store
P:3D1C5:ExitRp:get enemy object buffer offset and leave
P:3D1C8:SetupPlatformRope:save second/third copy to stack
P:3D1C9::get horizontal coordinate
P:3D1CD::add eight pixels
P:3D1CF::if secondary hard mode flag set,
P:3D1D2::use coordinate as-is
P:3D1D5::otherwise add sixteen more pixels
P:3D1D7:GetLRp:save modified horizontal coordinate to stack
P:3D1DB::add carry to page location
P:3D1DD::and save here
P:3D1DF::pull modified horizontal coordinate
P:3D1E0::from the stack, mask out low nybble
P:3D1E2::and shift three bits to the right
P:3D1E5::store result here as part of name table low byte
P:3D1E7::get vertical coordinate
P:3D1E9::get second/third copy of vertical speed from stack
P:3D1EA::skip this part if moving downwards or not at all
P:3D1EE::add eight to vertical coordinate and
P:3D1F0::save as X
P:3D1F1:GetHRp:move vertical coordinate to A
P:3D1F2::get vram buffer offset
P:3D1F6::rotate d7 to d0 and d6 into carry
P:3D1F7::save modified vertical coordinate to stack
P:3D1F8::rotate carry to d0, thus d7 and d6 are at 2 LSB
P:3D1F9::mask out all bits but d7 and d6, then set
P:3D1FB::d5 to get appropriate high byte of name table
P:3D1FD::address, then store
P:3D1FF::get saved page location from earlier
P:3D201::mask out all but LSB
P:3D204::shift twice to the left and save with the
P:3D205::rest of the bits of the high byte, to get
P:3D207::the proper name table and the right place on it
P:3D209::get modified vertical coordinate from stack
P:3D20A::mask out low nybble and LSB of high nybble
P:3D20D::add to horizontal part saved here
P:3D20F::save as name table low byte
P:3D214::if vertical position not below the
P:3D216::bottom of the screen, we're done, branch to leave
P:3D21A::mask out d6 of low byte of name table address
P:3D21E:ExPRp:leave!
P:3D21F:InitPlatformFall:move offset of other platform from Y to X
P:3D221::get offscreen bits
P:3D226::award 1000 points to player
P:3D22C::put floatey number coordinates where player is
P:3D234::set moving direction as flag for
P:3D236::falling platforms
P:3D238:StopPlatforms:initialize vertical speed
P:3D23A::and movement force
P:3D23C::initialize vertical speed and low byte
P:3D23F::for both platforms and leave
P:3D246:PlatformFall:save offset for other platform to stack
P:3D248::make current platform fall
P:3D24C::pull offset from stack and save to X
P:3D24D::make other platform fall
P:3D252::if player not standing on either platform,
P:3D255::skip this part
P:3D257::transfer collision flag offset as offset to X
P:3D258::and position player appropriately
P:3D25B:ExPF:get enemy object buffer offset and leave
P:3D25E:YMovingPlatform:--------------------------------\nif platform moving up or down, skip ahead to
P:3D260::check on other position
P:3D265::initialize dummy variable
P:3D26A::if current vertical position => top position, branch
P:3D26D::ahead of all this
P:3D271::check for every eighth frame
P:3D275::increase vertical position every eighth frame
P:3D277:SkipIY:skip ahead to last part
P:3D27A:ChkYCenterPos:if current vertical position < central position, branch
P:3D27C::to slow ascent/move downwards
P:3D280::otherwise start slowing descent/moving upwards
P:3D286:YMDown:start slowing ascent/moving downwards
P:3D289:ChkYPCollision:if collision flag not set here, branch
P:3D28C::to leave
P:3D28E::otherwise position player appropriately
P:3D291:ExYPl:leave
P:3D292:XMovingPlatform:--------------------------------\n$00 - used as adder to position player horizontally\nload preset maximum value for secondary counter
P:3D294::do a sub to increment counters for movement
P:3D297::do a sub to move platform accordingly, and return value
P:3D29A::if no collision with player,
P:3D29D::branch ahead to leave
P:3D29F:PositionPlayerOnHPlat
P:3D2AD::add saved value from second subroutine to
P:3D2AE::current player's position to position
P:3D2B0::player accordingly in horizontal position
P:3D2B2::get player's page location
P:3D2B4::check to see if saved value here is positive or negative
P:3D2B6::if negative, branch to subtract
P:3D2B8::otherwise add carry to page location
P:3D2BA::jump to skip subtraction
P:3D2BD:PPHSubt:subtract borrow from page location
P:3D2BF:SetPVar:save result to player's page location
P:3D2C1::put saved value from second sub here to be used later
P:3D2D0::position player vertically and appropriately
P:3D2D3:ExXMP:and we are done here
P:3D2D4:DropPlatform:--------------------------------\nif no collision between platform and player
P:3D2D7::occurred, just leave without moving anything
P:3D2D9::otherwise do a sub to move platform down very quickly
P:3D2DC::do a sub to position player appropriately
P:3D2DF:RightPlatform:--------------------------------\n$00 - residual value from sub\nincrement offset for enemy offset
P:3D2E0::position object horizontally according to
P:3D2E3::counters, return with saved value in A,
P:3D2E5::sta $00                       ;store saved value here (residual code)\ncheck collision flag, if no collision between player
P:3D2E8::and platform, branch ahead, leave speed unaltered
P:3D2EC::otherwise set new speed (gets moving if motionless)
P:3D2EE::use saved value from earlier sub to position player
P:3D2F1:MoveLargeLiftPlat:--------------------------------\nexecute common to all large and small lift platforms
P:3D2F4::branch to position player correctly
P:3D2F7:MoveSmallPlatform:execute common to all large and small lift platforms
P:3D2FA::branch to position player correctly
P:3D2FD:MoveLiftPlatforms:if master timer control set, skip all of this
P:3D300::and branch to leave
P:3D305::add contents of movement amount to whatever's here
P:3D30C::add whatever vertical speed is set to current
P:3D30E::vertical position plus carry to move up or down
P:3D310::and then leave
P:3D313:ChkSmallPlatCollision:get bounding box counter saved in collision flag
P:3D316::if none found, leave player position alone
P:3D318::use to position player correctly
P:3D31B:ExLiftP:then leave
P:3D31C:OffscreenXoffset:-------------------------------------------------------------------------------------\n$00 - page location of extended left boundary\n$01 - extended left boundary position\n$02 - page location of extended right boundary\n$03 - extended right boundary position
P:3D31E:OffscreenBoundsCheck:check for cheep-cheep object
P:3D320::branch to leave if found
P:3D32B::get horizontal coordinate for left side of screen
P:3D32F::subtract 72 pixels regardless of enemy object
P:3D332::store result here
P:3D337::subtract borrow from page location of left side
P:3D339::store result here
P:3D33B::add 72 pixels to the right side horizontal coordinate
P:3D342::store result here
P:3D347::then add the carry to the page location
P:3D349::and store result here
P:3D34B::compare horizontal coordinate of the enemy object
P:3D34D::to modified horizontal left edge coordinate to get carry
P:3D351::then subtract it from the page coordinate of the enemy object
P:3D353::if enemy object is too far left, branch to erase it
P:3D355::compare horizontal coordinate of the enemy object
P:3D357::to modified horizontal right edge coordinate to get carry
P:3D35B::then subtract it from the page coordinate of the enemy object
P:3D35D::if enemy object is on the screen, leave, do not erase enemy
P:3D35F:TooFar
P:3D36E::erase object if necessary
P:3D371:ExScrnBd:leave
P:3D372:ExitFBallEnemy2:get original fireball offset and leave
P:3D375:FireballEnemyCollision:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$01 - enemy buffer offset\ncheck to see if fireball state is set at all
P:3D377::branch to leave if not
P:3D379::branch to leave also if d7 in state is set
P:3D382::get LSB of frame counter
P:3D383::branch to leave if set (do routine every other frame)
P:3D386::multiply fireball offset by four
P:3D389::then add $1c or 28 bytes to it
P:3D38B::to use fireball's bounding box coordinates 
P:3D38E:FireballEnemyCDLoop:store enemy object offset here
P:3D391::push fireball offset to the stack
P:3D394::check to see if d5 is set in enemy state
P:3D396::if so, skip to next enemy slot
P:3D398::check to see if buffer flag is set
P:3D39A::if not, skip to next enemy slot
P:3D39C::check enemy identifier
P:3D3AC::if < $24, branch to check further
P:3D3B4::if in range $24-$2a, skip to next enemy slot
P:3D3B6:GoombaDie:check for goomba identifier
P:3D3BC::if not found, continue with code
P:3D3BE::otherwise check for defeated state
P:3D3C0::if stomped or otherwise defeated,
P:3D3C2::skip to next enemy slot
P:3D3C4:NotGoomba:if any masked offscreen bits set,
P:3D3C7::skip to next enemy slot
P:3D3CA::otherwise multiply enemy offset by four
P:3D3CD::add 4 bytes to it
P:3D3CF::to use enemy's bounding box coordinates
P:3D3D0::do fireball-to-enemy collision detection
P:3D3D3::return fireball's original offset
P:3D3D5::if carry clear, no collision, thus do next enemy slot
P:3D3D9::set d7 in enemy state
P:3D3DB::get enemy offset
P:3D3DD::jump to handle fireball to enemy collision
P:3D3F9:NoFToECol
P:3D3FB::pull fireball offset from stack
P:3D3FC::put it in Y
P:3D3FD::get enemy object offset
P:3D3FF::decrement it
P:3D400::loop back until collision detection done on all enemies
P:3D402:ExitFBallEnemy:get original fireball offset and leave
P:3D404:testt
P:3D405:BowserIdentities
P:3D40D:ChkOtherEnemies1
P:3D410:HandleEnemyFBallCol:get coordinates of enemy object 
P:3D413::store value to add to A here
P:3D416::add A to value stored
P:3D418::use as enemy offset
P:3D419::load vertical coordinate lo
P:3D41B::store here
P:3D41E::load horizontal coordinate
P:3D420::subtract left edge coordinate
P:3D424::store result here
P:3D427::get current enemy object offset
P:3D429::check buffer flag for d7 set
P:3D42B::branch if not set to continue
P:3D42D::otherwise mask out high nybble and
P:3D42F::use low nybble as enemy offset
P:3D432::check enemy identifier for bowser
P:3D434::branch if found
P:3D436::otherwise retrieve current enemy offset
P:3D438:ChkBuzzyBeetle
P:3D43A::check for buzzy beetle
P:3D43C::branch if found to leave (buzzy beetles fireproof)
P:3D43E::check for bowser one more time (necessary if d7 of flag was clear)
P:3D440::if not found, branch to check other enemies
P:3D442:HurtBowser
P:3D47B::otherwise, check number of pts
P:3D47F::more than 9 pts?
P:3D483::if so, subtract 10 and add one to the 10s digit
P:3D486::instead of showing 100 pts, A0 will show, etc.
P:3D4A0:testtt
P:3D4B6::if bowser still has hit points, branch to leave
P:3D4BD::initialize vertical speed
P:3D4BF::and movement force
P:3D4C4::initialize horizontal speed
P:3D4C6::init enemy frenzy buffer
P:3D4CB::set vertical speed to make defeated bowser jump a little
P:3D4CD::use world number as offset
P:3D4D3::get enemy identifier to replace bowser with
P:3D4D6::set as new enemy identifier
P:3D4D8::set A to use starting value for state
P:3D4DA::check to see if using offset of 3 or more
P:3D4DC::branch if so
P:3D4DE::otherwise add 3 to enemy state
P:3D4E0:SetDBSte:set defeated enemy state
P:3D4E4::load bowser defeat sound
P:3D4E6::       jsr SetupVictoryMode\n       lda #$03\n       sta OperMode_Task   ;secondary mode\n       lda #$02\n       sta OperMode        ;set primary mode to autoctrl mode\n        lda #$00\n        sta OperMode_Task   ;reset secondary mode\n        lda #$02\n        sta OperMode        ;set primary mode to autoctrl mode\n        lda #$18\n        sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile\nget enemy offset
P:3D4E8::award 5000 points to player for defeating bowser
P:3D4EA::unconditional branch to award points
P:3D4EC:ChkOtherEnemies
P:3D4EE::branch to leave if bullet bill (frenzy variant) 
P:3D4F2::branch to leave if podoboo
P:3D50A::branch to leave if identifier => $15
P:3D50C:ShellOrBlockDefeat
P:3D517::check for piranha plant
P:3D52B::branch if not found
P:3D530:StnE:do yet another sub
P:3D535::mask out 2 MSB of enemy object's state
P:3D537::set d5 to defeat enemy and save as new state
P:3D543::award 200 points by default
P:3D545::check for hammer bro
P:3D549::branch if not found
P:3D54B::award 1000 points for hammer bro
P:3D54D:GoombaPoints
P:3D551::check for goomba
P:3D557::branch if not found
P:3D559::award 100 points for goomba
P:3D55E:LakituPoints
P:3D565:EnemySmackScore
P:3D568::cpy #$00
P:3D56D:Her:set number of points control for floatey numbers
P:3D572::set timer for floatey numbers
P:3D577::set vertical coordinate
P:3D57D::set horizontal coordinate and leave
P:3D580::play smack enemy sound
P:3D587:ExHCF:and now let's leave
P:3D588:StarCollisions:increment chain counter for additional enemies
P:3D58B::get chain counter for shell
P:3D598::set number of points control for floatey numbers
P:3D59D::set timer for floatey numbers
P:3D5A2::set vertical coordinate
P:3D5A8::set horizontal coordinate and leave
P:3D5AB::play smack enemy sound
P:3D5C8:PlayerHammerCollision:-------------------------------------------------------------------------------------\nget frame counter
P:3D5CA::shift d0 into carry
P:3D5CB::branch to leave if d0 not set to execute every other frame
P:3D5CD::if either master timer control
P:3D5D0::or any offscreen bits for hammer are set,
P:3D5D3::branch to leave
P:3D5D7::if not set to run player control routine
P:3D5D9::on next frame, branch to leave
P:3D5DC::multiply misc object offset by four
P:3D5DF::add 36 or $24 bytes to get proper offset
P:3D5E1::for misc object bounding box coordinates
P:3D5E2::do player-to-hammer collision detection
P:3D5E5::get misc object offset
P:3D5E7::if no collision, then branch
P:3D5E9::otherwise read collision flag
P:3D5EC::if collision flag already set, branch to leave
P:3D5F0::otherwise set collision flag now
P:3D5F5::get two's compliment of
P:3D5F7::hammer's horizontal speed
P:3D5FA::set to send hammer flying the opposite direction
P:3D5FC::if star mario invincibility timer set,
P:3D5FF::branch to leave
P:3D601::otherwise jump to hurt player, do not return
P:3D604:ClHCol:clear collision flag
P:3D609:ExPHC
P:3D60A:HandlePowerUpCollision:-------------------------------------------------------------------------------------
P:3D60F::erase the power-up object
P:3D614::award 1000 points to player by default
P:3D619::if 1-up mushroom, do not play the power-up sound
P:3D61F::play the power-up sound
P:3D627::if mushroom or fire flower, branch
P:3D62B::if 1-up mushroom, branch               
P:3D63A::into the area music queue, then leave
P:3D641::otherwise set star mario invincibility
P:3D644::timer, and load the star mario music
P:3D648:yee
P:3D64A:Shroom_PUp
P:3D64D:Flower_PUp
P:3D654::set player status to fiery
P:3D65E::run sub to change colors of player
P:3D661::ldx ObjectOffset    ;get enemy offset again, and again not necessary\nset value to be used by subroutine tree (fiery)
P:3D663::jump to set values accordingly
P:3D666:SetFor1Up:change 1000 points into 1-up instead
P:3D668::and then leave
P:3D66B:NoPUp
P:3D66C:UpToSuper
P:3D671::set player status to super
P:3D676::set value to be used by subroutine tree (super)
P:3D678:UpToFiery:set value to be used as new player state
P:3D67A::set values to stop certain things in motionrts
P:3D67D:KickedShellXSpdData:--------------------------------\n      .db $18, $e8
P:3D67D:ResidualXSpdData
P:3D67F:DemotedKoopaXSpdData
P:3D683:PlayerEnemyCollision:if player object is completely offscreen
P:3D686::vertically, leave this routine
P:3D68A::if player high vertical byte is not
P:3D68F::if on the screen, check to see how far down
P:3D691::the player is vertically
P:3D693::if down past 224th pixel row, branch to leave
P:3D695::ldx ObjectOffset\nif current enemy is offscreen by any amount,
P:3D698::go ahead and branch to leave
P:3D69C::if not set to run player control routine
P:3D69E::on next frame, branch to leave
P:3D6A2::if enemy state has d5 set, branch to leave
P:3D6A6::get enemy object buffer offset
P:3D6A8::multiply A by four, then add four
P:3D6A9::to skip player's bounding box
P:3D6AD::send to Y
P:3D6AE::get offscreen bits for enemy object
P:3D6B1::save low nybble
P:3D6B3::check for all bits set
P:3D6B5::do collision detection on player vs. enemy
P:3D6B8::ldy $06                      ;otherwise return with carry clear and Y = $0006\nget enemy object buffer offset
P:3D6BA::if collision, branch past this part here
P:3D6BF::otherwise, clear d0 of current enemy object's
P:3D6C1::collision bit
P:3D6C4:NoPECol
P:3D6C5:CheckForPUpCollision
P:3D6C7::check for power-up object
P:3D6C9::if not found, branch to next part
P:3D6CB::otherwise, unconditional jump backwards
P:3D6CE:EColl:if star mario invincibility timer expired,
P:3D6D1::perform task here, otherwise kill enemy like
P:3D6E8::hit with a shell, or from beneath
P:3D702:KickedShellPtsData
P:3D705:ShellUp
P:3D70A::sta GrabDown
P:3D717::set fireball cooldown to avoid killing it just after releasing it 
P:3D71A::play smack enemy sound
P:3D71F:HandlePECollisions:branch to leave if either is true
P:3D73F::check enemy collision bits for d0 set
P:3D742::or for being offscreen at all
P:3D744::branch to leave if either is true
P:3D748::otherwise set d0 now
P:3D74E::branch if spiny
P:3D752::branch if invincible paratroopa
P:3D756::branch if piranha plant
P:3D76A::branch if podoboo
P:3D76E::check if swimming or underwater level
P:3D773::branch if bloober
P:3D777::branch if grey cheep cheep
P:3D77B::branch if red cheep cheep
P:3D77F::branch if bullet bill
P:3D787::branch if object => $15
P:3D78B::branch if d7 of enemy state was set
P:3D78F::mask out all but 3 LSB of enemy state
P:3D793::branch if enemy is in normal or falling state
P:3D797::branch to leave if goomba or fast goomba in defeated state
P:3D7A9:Grab:check if B is pressed
P:3D7AD::branch if not
P:3D7B2::branch if grabflag is zero
P:3D7B7::compare current enemy offset with the grabbed enemy offset and branch if not equal
P:3D7B9::if grabflag zero and B pressed, set current enemy offset to grabbed offset
P:3D7C1:H
P:3D7C2:HandleSignInteraction
P:3D7C5:InjurePlayer2
P:3D7C8:ChkForPlayerInjury2
P:3D7D1::branch if grabflag is zero to kick it in the old way
P:3D7D3::lda Enemy_Y_Position,x\ncmp #$11\nbcc H\ndecrement to set grabflag to zero
P:3D7E2::check if DOWN is pressed
P:3D7E6::if so, put down shell gently
P:3D7EB::get player's facing direction
P:3D7F6:KickD:kick shell where player is facing
P:3D801::nullify enemy Y speed
P:3D805::set fireball cooldown to avoid killing the sell just after kicking it
P:3D808::load and set horizontal speed data with offset
P:3D80D::set d7 in enemy state, thus become moving shell
P:3D817::reset smack pitch
P:3D820::play smack enemy sound
P:3D824::load and set horizontal speed data with offset
P:3D82E::add three to whatever the stomp counter contains
P:3D830::to give points for kicking the shell
P:3D834::check shell enemy's timer
P:3D837::if above a certain point, branch using the points
P:3D839::data obtained from the stomp counter + 3
P:3D83B::otherwise, set points based on proximity to timer expiration
P:3D83E:KSPts:set values for floatey number now
P:3D841:ExPEC
P:3D842:GSLoop:load grab id
P:3D845::set enemy interval timer to avoid glitches
P:3D84A::load player horizontal position
P:3D84C::load player facing dir
P:3D84F::branch if not zero
P:3D852::apparently this sometimes refuses to work correctly lmao
P:3D854::add $0b pixels if right
P:3D856::load player page loc
P:3D858::add 1 if horizontal position overflowed
P:3D85A::store in enemy page loc
P:3D85F::subtract $0b pixels if left
P:3D864::load player page loc
P:3D866::subtract 1 if horizontal position underflowed
P:3D868::store in enemy page loc
P:3D86C::store player moving dir here
P:3D870::nullify this so enemy can't hurt just after kicking it
P:3D873::load player vertical position
P:3D875::load crouching flag
P:3D878::branch if crouching
P:3D87A::load player size
P:3D87D::branch if small
P:3D880::subtract 7
P:3D88E::add 6
P:3D890::set enemy vertical position
P:3D8A5:RShell
P:3D8A7::reset chain counter
P:3D8AB:ShellDown
P:3D8AD::set this
P:3D8B0::load player horizontal speed
P:3D8B2::store here
P:3D8B6::nullify enemy vertical speed
P:3D8BA::set fireball cooldown to avoid killing it just after releasing it 
P:3D8BE:KillPlayer:nullify grab flag, enemy pitch, was grabbed and old status
P:3D8D5::halt player's horizontal movement by initializing speed
P:3D8D8::set event music queue to death music
P:3D8DC::set new vertical speed
P:3D8DE::set subroutine to run on next frame
P:3D8E0::branch to set player's state and other things
P:3D8E2:InjurePlayer
P:3D8E9::check again to see if injured invincibility timer is
P:3D8EC::at zero, and branch to leave if so
P:3D8EE:ForceInjury:check player's status
P:3D8F1::branch if small
P:3D906::load player's status and store here
P:3D909::decrement player's status
P:3D90E::set injured invincibility timer
P:3D911::PAL version has lda #$10 here instead (either will work)
P:3D912::play pipedown/injury sound
P:3D914::change player's palette if necessary
P:3D917::set subroutine to run on next frame
P:3D919:SetKRout:set new player state
P:3D91B:SetPRout:load new value to run subroutine on next frame
P:3D91D::store new player state
P:3D921::set master timer control flag to halt timers
P:3D925::initialize scroll speed
P:3D928:ExInjColRoutines:get enemy offset and leave
P:3D92B:ChkForPlayerInjury:check player's vertical speed
P:3D92D::perform procedure below if player moving upwards
P:3D92F::or not at all, and branch elsewhere if moving downward
P:3D944:ChkInj:lda Player_State\nbne EnemyStomped\nPAL bugfix: Vertical difference deciding whether Mario stomped or got hit depends on the enemy\nbranch if enemy object < $07\nbranch if enemy object < $07
P:3D956::add 12 pixels to player's vertical position
P:3D95B::compare modified player's position to enemy's position
P:3D95D::branch if this player's position above (less than) enemy's
P:3D95F:ChkETmrs:check stomp timer
P:3D962::branch if set
P:3D964::check to see if injured invincibility timer still
P:3D967::counting down, and branch elsewhere to leave if so
P:3D96C::if player's relative position to the left of enemy's
P:3D96F::relative position, branch here
P:3D971::otherwise do a jump here
P:3D974:TInjE:if enemy moving towards the left,
P:3D976::branch, otherwise do a jump here
P:3D978::to turn the enemy around
P:3D97D:InjurePlayer3
P:3D980:StompedEnemyPtsData
P:3D984:EnemyStomped:check for spiny, branch to hurt player
P:3D986::if found
P:3D997::otherwise play stomp/swim sound
P:3D99D::initialize points data offset for stomped enemies
P:3D99F::branch for cheep-cheep
P:3D9AB::branch for either bullet bill object
P:3D9B3::branch for podoboo (this branch is logically impossible
P:3D9B5::for cpu to take due to earlier checking of podoboo)
P:3D9B7::increment points data offset
P:3D9B8::branch for hammer bro
P:3D9BC::increment points data offset
P:3D9BD::branch for lakitu
P:3D9C1::increment points data offset
P:3D9C2::branch if NOT bloober
P:3D9C6:EnemyStompedPts:load points data using offset in Y
P:3D9C9::set number of points control for floatey numbers
P:3D9CE::set timer for floatey numbers
P:3D9D3::set vertical coordinate
P:3D9D9::set horizontal coordinate and leave
P:3D9DF:NormalPTS:increment the stomp counter
P:3D9E2::add whatever is in the stomp counter
P:3D9E6::apparently this sometimes refuses to work correctly lmao
P:3D9E9::set number of points control for floatey numbers
P:3D9EE::set timer for floatey numbers
P:3D9F3::set vertical coordinate
P:3D9F9::set horizontal coordinate and leave
P:3D9FC::increment stomp timer of some sort
P:3DA01::save enemy movement direction to stack
P:3DA02::run sub to kill enemy
P:3DA06::return enemy movement direction from stack
P:3DA0A::set d5 in enemy state
P:3DA14::initialize vertical speed
P:3DA16::and movement force
P:3DA18::nullify vertical speed, physics-related thing,
P:3DA1B::and horizontal speed
P:3DA29:ChkForDemoteKoopa:branch elsewhere if enemy object < $0a
P:3DA3D::demote koopa paratroopas to ordinary troopas
P:3DA41::return enemy to normal state
P:3DA4A::increment the stomp counter
P:3DA4D::add whatever is in the stomp counter
P:3DA51::apparently this sometimes refuses to work correctly lmao
P:3DA54::set number of points control for floatey numbers
P:3DA59::set timer for floatey numbers
P:3DA5E::set vertical coordinate
P:3DA64::set horizontal coordinate and leave
P:3DA67::increment stomp timer of some sort
P:3DA6A::initialize vertical speed
P:3DA6C::and movement force
P:3DA71::turn enemy around if necessary
P:3DA7E::set appropriate moving speed based on direction
P:3DA80::then move onto something else
P:3DA83:RevivalRateData
P:3DA85:HandleStompedShellE:set defeated state for enemy
P:3DA89::increment the stomp counter
P:3DA8C::add whatever is in the stomp counter
P:3DA90::apparently this sometimes refuses to work correctly lmao
P:3DA93::set number of points control for floatey numbers
P:3DA98::set timer for floatey numbers
P:3DA9D::set vertical coordinate
P:3DAA3::set horizontal coordinate and leave
P:3DAA6::increment stomp timer of some sort
P:3DAA9::check primary hard mode flag
P:3DABD::load timer setting according to flag
P:3DAC0::set as enemy timer to revive stomped enemy
P:3DAC3:SetBounce
P:3DAD3:SmallBonc:set player's vertical speed for bounce
P:3DADC:BnceM:and then leave!!!
P:3DADF:ChkEnemyFaceRight:check to see if enemy is moving to the right
P:3DAE3::if not, branch
P:3DAE5::otherwise go back to hurt player
P:3DAE8:LInj:turn the enemy around, if necessary
P:3DAEB::go back to hurt player
P:3DAEE:EnemyFacePlayer:set to move right by default
P:3DAF0::get distance between enemy object's
P:3DAF2::horizontal coordinate and the player's
P:3DAF3::horizontal coordinate
P:3DAF5::and store here
P:3DAF9::subtract borrow, then leave
P:3DAFB::if enemy is to the right of player, do not increment
P:3DAFD::otherwise, increment to set to move to the left
P:3DAFE:SFcRt:set moving direction here
P:3DB00::then decrement to use as a proper offset
P:3DB02:SetupFloateyNumber:set number of points control for floatey numbers
P:3DB07::set timer for floatey numbers
P:3DB0C::set vertical coordinate
P:3DB12::set horizontal coordinate and leave
P:3DB15:ExSFN
P:3DB16:SetBitsMask:-------------------------------------------------------------------------------------\n$01 - used to hold enemy offset for second enemy
P:3DB1D:ClearBitsMask
P:3DB24:ExSFN2:get enemy object buffer offset
P:3DB26::leave
P:3DB27:EnemiesCollision
P:3DB47::if enemy object => $15, branch to leave
P:3DB4B::if lakitu, branch to leave
P:3DB5B::then check enemy state
P:3DB5D::if not set to unique state for spiny's egg, go ahead
P:3DB6E::check saved enemy state for d5 set
P:3DB72::if masked offscreen bits nonzero, branch to leave
P:3DB77::get enemy object buffer offset
P:3DB79::multiply A by four, then add four
P:3DB7A::to skip player's bounding box
P:3DB7E::send to Y
P:3DB7F::get offscreen bits for enemy object
P:3DB82::save low nybble
P:3DB84::check for all bits set
P:3DB86::first enemy we're going to compare, then decrement for second
P:3DB87::branch to leave if there are no other enemies
P:3DB89:ECLoop:save enemy object buffer offset for second enemy here
P:3DB8B::save first enemy's bounding box offset to stack
P:3DB8D::check enemy object enable flag
P:3DB8F::branch if flag not set
P:3DBA3::cmp #BulletBill_CannonVar\nbeq +\ncheck for enemy object => $15
P:3DBA5::branch if true
P:3DBAA:ReadyNextEnemy1
P:3DBB1::branch if enemy object is lakitu
P:3DBB6::branch if masked offscreen bits set
P:3DBB8::get second enemy object's bounding box offset
P:3DBB9::multiply by four, then add four
P:3DBBE::use as new contents of X
P:3DBBF::save contents of Y here
P:3DBC3::save value 1 here as counter, compare horizontal coordinates first
P:3DBC5:CollisionCoreLoop1:compare left/top coordinates
P:3DBC8::of first and second objects' bounding boxes
P:3DBCB::if first left/top => second, branch
P:3DBCD::otherwise compare to right/bottom of second
P:3DBD0::if first left/top < second right/bottom, branch elsewhere
P:3DBD2::if somehow equal, collision, thus branch
P:3DBD4::if somehow greater, check to see if bottom of
P:3DBD7::first object's bounding box is greater than its top
P:3DBDA::if somehow less, vertical wrap collision, thus branch
P:3DBDC::otherwise compare bottom of first bounding box to the top
P:3DBDF::of second box, and if equal or greater, collision, thus branch
P:3DBE1::ldy $06                      ;otherwise return with carry clear and Y = $0006\nnote horizontal wrapping never occurs
P:3DBE4:SecondBoxVerticalChk1:check to see if the vertical bottom of the box
P:3DBE7::is greater than the vertical top
P:3DBEA::if somehow less, vertical wrap collision, thus branch
P:3DBEC::otherwise compare horizontal right or vertical bottom
P:3DBEF::of first box with horizontal left or vertical top of second box
P:3DBF2::if equal or greater, collision, thus branch
P:3DBF4::ldy $06                      ;otherwise return with carry clear and Y = $0006
P:3DBF7:CollisionFound1:increment offsets on both objects to check
P:3DBF8::the vertical coordinates
P:3DBF9::decrement counter to reflect this
P:3DBFB::if counter not expired, branch to loop
P:3DBFD::otherwise we already did both sets, therefore collision, so set carry
P:3DC01:FirstBoxGreater1:compare first and second box horizontal left/vertical top again
P:3DC04::if first coordinate = second, collision, thus branch
P:3DC06::if not, compare with second object right or bottom edge
P:3DC09::if left/top of first less than or equal to right/bottom of second
P:3DC0B::then collision, thus branch
P:3DC0D::otherwise check to see if top of first box is greater than bottom
P:3DC10::if less than or equal, no collision, branch to end
P:3DC14::otherwise compare bottom of first to top of second
P:3DC17::if bottom of first is greater than top of second, vertical wrap
P:3DC1A::collision, and branch, otherwise, proceed onwards here
P:3DC1C:NoCollisionFound1:clear carry, then load value set earlier, then leave
P:3DC1D::like previous ones, if horizontal coordinates do not collide, we do
P:3DC1F::rts          ;not bother checking vertical ones, because what's the point?\nuse first enemy offset for X
P:3DC21::use second enemy offset for Y
P:3DC23::if carry clear, no collision, branch ahead of this
P:3DC3B::check both enemy states for d7 set
P:3DC40::branch if at least one of them is set
P:3DC42::load first enemy's collision-related bits
P:3DC45::check to see if bit connected to second enemy is
P:3DC48::already set, and move onto next enemy slot if set
P:3DC4D::if the bit is not set, set it now
P:3DC53:YesEC:react according to the nature of collision
P:3DC56::move onto next enemy slot
P:3DC59:NoEnemyCollision:load first enemy's collision-related bits
P:3DC5C::clear bit connected to second enemy
P:3DC5F::then move onto next enemy slot
P:3DC62:ReadyNextEnemy:get first enemy's bounding box offset from the stack
P:3DC63::use as Y again
P:3DC64::get and decrement second enemy's object buffer offset
P:3DC67::loop until all enemy slots have been checked
P:3DC69:ExitECRoutine:get enemy object buffer offset
P:3DC6B::leave
P:3DC6C:ECLoop1
P:3DC6F:ProcSecondEnemyColl2
P:3DC72:ProcEnemyCollisions:check both enemy states for d5 set
P:3DC77::if d5 is set in either state, or both, branch
P:3DC79::to leave and do nothing else at this point
P:3DC85::lda Enemy_ID,x\ncmp #BulletBill_CannonVar\nbeq ++
P:3DC87::if second enemy state < $06, branch elsewhere
P:3DC8B::check second enemy identifier for hammer bro
P:3DC8D::if hammer bro found in alt state, branch to leave
P:3DC9F::check first enemy state for d7 set
P:3DCA2::branch if d7 is clear
P:3DCA6::set number of points control for floatey numbers
P:3DCAB::set timer for floatey numbers
P:3DCB0::set vertical coordinate
P:3DCB6::set horizontal coordinate and leave
P:3DCB9::then kill enemy, then load
P:3DCBE::original offset of second enemy
P:3DCC0:ShellCollisions:move Y to X
P:3DCCD::get chain counter for shell
P:3DCD1::add four to get appropriate point offset
P:3DCDA::set number of points control for floatey numbers
P:3DCDF::set timer for floatey numbers
P:3DCE4::set vertical coordinate
P:3DCEA::set horizontal coordinate and leave
P:3DCED::load original offset of first enemy
P:3DCEF::increment chain counter for additional enemies
P:3DD0D:ExitProcessEColl
P:3DD0F::leave!!!
P:3DD10:ProcSecondEnemyColl
P:3DD25::lda Enemy_ID,y\ncmp #BulletBill_CannonVar\nbeq ++\nif first enemy state < $06, branch elsewhere
P:3DD30::check first enemy identifier for hammer bro
P:3DD33::if hammer bro found in alt state, branch to leave
P:3DD3B::otherwise, kill first enemy
P:3DD40::get chain counter for shell
P:3DD44::add four to get appropriate point offset
P:3DD48::set number of points control for floatey numbers
P:3DD4D::set timer for floatey numbers
P:3DD52::set vertical coordinate
P:3DD58::set horizontal coordinate and leave
P:3DD71::load original offset of second enemy
P:3DD73::increment chain counter for additional enemies
P:3DD8A::leave!!!
P:3DD8B:MoveEOfs:move Y ($01) to X
P:3DD8D::do the sub here using value from $01
P:3DD90::then do it again using value from $08
P:3DD92:EnemyTurnAround:check for specific enemies
P:3DD96::if piranha plant, leave
P:3DD9E::if lakitu, leave
P:3DDA2::if hammer bro, leave
P:3DDA6::if spiny, turn it around
P:3DDAA::if green paratroopa, turn it around
P:3DDBA::if any OTHER enemy object => $07, leave
P:3DDBC:RXSpd:load horizontal speed
P:3DDBE::get two's compliment for horizontal speed
P:3DDC2::store as new horizontal speed
P:3DDC6::invert moving direction and store, then leave
P:3DDC8::thus effectively turning the enemy around
P:3DDE0:ExTA:leave!!!
P:3DDEF:LargePlatformCollision:-------------------------------------------------------------------------------------\n$00 - vertical position of platform\nsave value here
P:3DDF4::check master timer control
P:3DDF7::if set, branch to leave
P:3DDF9::if d7 set in object state,
P:3DDFB::branch to leave
P:3DDFF::check enemy object identifier for
P:3DE01::balance platform, branch if not found
P:3DE05::set state as enemy offset here
P:3DE06::perform code with state offset, then original offset, in X
P:3DE09:ChkForPlayerC_LargeP:figure out if player is below a certain point
P:3DE0C::or offscreen, branch to leave if true
P:3DE0F::multiply A by four, then add four
P:3DE10::to skip player's bounding box
P:3DE14::send to Y
P:3DE15::get offscreen bits for enemy object
P:3DE18::save low nybble
P:3DE1A::check for all bits set
P:3DE1C::store vertical coordinate in
P:3DE1E::temp variable for now
P:3DE20::send offset we're on to the stack
P:3DE22::do player-to-platform collision detection
P:3DE25::retrieve offset from the stack
P:3DE27::if no collision, branch to leave
P:3DE29::otherwise collision, perform sub
P:3DE2C:ExLPC:get enemy object buffer offset and leave
P:3DE2F:ProcLPlatCollisions:--------------------------------\n$00 - counter for bounding boxes\n--------------------------------\nget difference by subtracting the top
P:3DE32::of the player's bounding box from the bottom
P:3DE33::of the platform's bounding box
P:3DE36::if difference too large or negative,
P:3DE38::branch, do not alter vertical speed of player
P:3DE3A:ChkForTopCollision:lda Player_Y_Speed           ;check to see if player's vertical speed is moving down\nbpl ChkForTopCollision       ;if so, don't mess with it\nlda #$01                     ;otherwise, set vertical\nsta Player_Y_Speed           ;speed of player to kill jump\nget difference by subtracting the top
P:3DE3D::of the platform's bounding box from the bottom
P:3DE3E::of the player's bounding box
P:3DE43::if difference not close enough, skip all of this
P:3DE47::if player's vertical speed moving upwards, skip this
P:3DE49::get saved bounding box counter from earlier
P:3DE4D::if either of the two small platform objects are found,
P:3DE4F::regardless of which one, branch to use bounding box counter
P:3DE51::as contents of collision flag
P:3DE55::otherwise use enemy object buffer offset
P:3DE56:SetCollisionFlag:get enemy object buffer offset
P:3DE58::save either bounding box counter or enemy offset here
P:3DE5D::set player state to normal then leave
P:3DE5F:PlatformSideCollisions
P:3DE60:PlayerPosSPlatData:-------------------------------------------------------------------------------------
P:3DE62:PositionPlayerOnS_Plat:use bounding box counter saved in collision flag
P:3DE63::for offset
P:3DE65::add positioning data using offset to the vertical
P:3DE66::coordinate
P:3DE69::BIT instruction opcode
P:3DE6A:PositionPlayerOnVPlat:get vertical coordinate
P:3DE6E::if certain routine being executed on this frame,
P:3DE70::skip all of this
P:3DE8C::if vertical high byte offscreen, skip this
P:3DE90::subtract 32 pixels from vertical coordinate
P:3DE91::for the player object's height
P:3DE93::save as player's new vertical coordinate
P:3DE96::subtract borrow and store as player's
P:3DE98::new vertical high byte
P:3DE9C::initialize vertical speed and low byte of force
P:3DE9E::and then leave
P:3DEA4:ExPlPos
P:3DEA5:ExPlPos2
P:3DEB4:ExPlPos3
P:3DEC1:CheckPlayerVertical:-------------------------------------------------------------------------------------\nif player object is completely offscreen
P:3DEC4::vertically, leave this routine
P:3DEC8::if player high vertical byte is not
P:3DECA::within the screen, leave this routine
P:3DECD::if on the screen, check to see how far down
P:3DECF::the player is vertically
P:3DED1:ExCPV
P:3DED2:PlayerBGUpperExtent:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00-$01 - used to hold many values, essentially temp variables\n$04 - holds lower nybble of vertical coordinate from block buffer routine\ntemp1 - used to hold block buffer adder
P:3DED4:PlayerBGCollision:if collision detection disabled flag set,
P:3DED7::branch to leave
P:3DEE4::if running routine #11 or $0b
P:3DEE6::branch to leave
P:3DEEA::if running routines $00-$03 branch to leave
P:3DEF0::load default player state for swimming
P:3DEF2::if swimming flag set,
P:3DEF5::branch ahead to set default state
P:3DEFC::if player in normal state,
P:3DEFE::branch to set default state for falling
P:3DF02::if in any other state besides climbing, skip to next part
P:3DF04:SetFallS:load default player state for falling
P:3DF06:SetPSte:set whatever player state is appropriate
P:3DF08:ChkOnScr
P:3DF0A::check player's vertical high byte for still on the screen
P:3DF0C::branch to leave if not
P:3DF16::initialize player's collision flag
P:3DF1B::check player's vertical coordinate
P:3DF1D::if not too close to the bottom of screen, continue
P:3DF1F:ExPBGCol:otherwise leave
P:3DF20:DoFootCheck1
P:3DF23:ChkCollSize:load default offset
P:3DF28::if player crouching, skip ahead
P:3DF2D::if player small, skip ahead
P:3DF2F::otherwise decrement offset for big player not crouching
P:3DF33::if swimming flag set, skip ahead
P:3DF35::otherwise decrement offset
P:3DF36:GBBAdr:get value using offset
P:3DF39::store value here
P:3DF3B::put value into Y, as offset for block buffer routine
P:3DF3C::get player's size as offset
P:3DF42::if player not crouching, branch ahead
P:3DF44::otherwise increment size as offset
P:3DF45:HeadChk
P:3DF4D::get player's vertical coordinate
P:3DF4F::compare with upper extent value based on offset
P:3DF52::if player is too high, skip this par
P:3DF61::beq ++
P:3DF66::lda Player_Y_Speed\nbeq ++\nbpl DoFootCheck1
P:3DF80::cmp #$00\nplayer, and branch if nothing above player's head
P:3DFA0:NoPuta
P:3DFBC::jmp DoFootCheck
P:3DFD3:DoFoCHK
P:3DFD3:DoFoCHK1
P:3DFD6:CheckForUpPipe
P:3DFE8::do player-to-bg collision detection on top of
P:3DFEF::do player-to-bg collision detection on top of
P:3DFF9::check to see if player touched coin with their head
P:3DFFE::if so, branch to some other part of code
P:3E022::check player's vertical speed
P:3E026::if player not moving upwards, branch elsewhere
P:3E054::check lower nybble of vertical coordinate returned
P:3E056::from collision detection routine
P:3E058::if low nybble < 4, branch
P:3E05A::jsr CheckForSolidMTiles
P:3E067:NoPuta2
P:3E08B::save metatile value into Y
P:3E08C::mask out all but 2 MSB
P:3E08F::shift and rotate d7-d6 to d1-d0
P:3E091::use as offset for metatile data
P:3E092::get original metatile value back
P:3E093::compare current metatile with solid metatiles
P:3E096::if player collided with solid metatile, branch
P:3E098:TryBump:if block bounce timer not expired,
P:3E09B::branch ahead, do not process collision
P:3E09D::otherwise do a sub to process collision
P:3E0A8::lda #$01
P:3E0AA::jump ahead to skip these other parts here
P:3E0AD:DoFoCHK8
P:3E0B0:DoPlayerSideCheck3
P:3E0B3:Burh1
P:3E0B6:Che
P:3E0BA:SolidOrClimb
P:3E0BC::branch ahead and do not play sound
P:3E0D1::otherwise load bump sound
P:3E0EC:NYSpd:set player's vertical speed to nullify\nPAL diff: Set vertical speed to 0 in water stages\n not water\njump or swim\nset player's vertical speed to nullify
P:3E0EE::jump or swim
P:3E0F3:PutOnSlope4
P:3E0FA:JmpTo4Mas
P:3E0FD:DoFootCheck
P:3E135:DoPlayerSideCheck5
P:3E138:DoFootCh
P:3E13A:DFC
P:3E13D::lda #$00\nsta DetectedFoot\nlda SwimmingFlag\nora OldSwim\nbne +\nlda Player_Y_Speed\nbmi DoPlayerSideCheck5\nget block buffer adder offset
P:3E141::check to see how low player is
P:3E143::if player is too far down on screen, skip all of this
P:3E163::do player-to-bg collision detection on bottom left of player
P:3E166::cmp #$71\nbeq Burh2
P:3E16A::check to see if player touched coin with their left foot
P:3E17B::do player-to-bg collision detection on bottom right of player
P:3E17E::save bottom right metatile here
P:3E183:micaracuando:save bottom left metatile to stack
P:3E184::do player-to-bg collision detection on bottom right of player
P:3E187::save bottom right metatile here
P:3E18A::pull bottom left metatile and save here
P:3E18C::if anything here, skip this part
P:3E18E::check for hidden coin block
P:3E190::branch to leave if found
P:3E196::check for hidden 1-up block
P:3E19E::do sub to check for hidden coin or 1-up blocks
P:3E1A0::if either found, branch
P:3E1BD:Burh2:		 ldy OldSwim\n	  bne +\n	  ldy WaterCooldown\n	  bne +\nldy SwimmingFlag\nbne +\ninc OldSwim\ninc SwimmingFlag\n	  pha\n	  jsr e\n	  pla\n	  ldy #$10\n	  sty WaterCooldown\n+:	  \n	  ldy #$01\n	  sty SwimmingFlag\n		 jmp Burh2
P:3E1BD:Fuck
P:3E1C0:PutOnSlope1
P:3E1C3:Ostia
P:3E1C4:e
P:3E1E3::lda Player_Y_Speed\nbmi x2
P:3E1FD:x2
P:3E1FE:x1
P:3E20C:Brom
P:3E282:Gay2
P:3E283:DoPlayerSideCheck4
P:3E286:Ostia2
P:3E289:Burh:otherwise check for anything in bottom right metatile
P:3E28B::and skip ahead if not
P:3E2C6:DoPlayerSideCheckte
P:3E2C9:Gay
P:3E2CD::check for hidden coin block
P:3E2CF::branch to leave if found
P:3E2D9::check for hidden 1-up block
P:3E2DD::do sub to check for hidden coin or 1-up blocks
P:3E312::check to see if player touched coin with their right foot
P:3E315::if not, skip unconditional jump and continue code
P:3E31D:PutOnSlope2
P:3E325:DoTheSpike2
P:3E328:DoPlayerSideCheck2
P:3E32F:DoPlayerSideCheck1
P:3E332:ChkFootMTile2
P:3E33C:ChkFootMTile
P:3E341::save metatile value into Y
P:3E342::mask out all but 2 MSB
P:3E345::shift and rotate d7-d6 to d1-d0
P:3E347::use as offset for metatile data
P:3E348::get original metatile value back
P:3E365::compare current metatile with climbable metatiles
P:3E368::if so, branch
P:3E36A:chorizo:check player's vertical speed
P:3E36C::if player moving upwards, branch
P:3E372::ldx WaterCooldown\nbne DoPlayerSideCheck1
P:3E37A:MIERDA2
P:3E380:ContChk2
P:3E39A::jmp SmolJmp
P:3E39D::if player did not touch axe, skip ahead
P:3E39F::otherwise jump to set modes of operation
P:3E3A2:DoTheSpike
P:3E3B7:@g
P:3E3BB:@oda
P:3E3C8:DoPlayerSideCheck6
P:3E3CB:PutOnSlope3
P:3E3CE:CargarPTimer: +1 because this decrements before reaching the check for jumping
P:3E3E4::store in queue and leave
P:3E3ED::initialize vertical speed and fractional
P:3E3EF::movement force to stop player's vertical movement
P:3E3F2::initialize enemy stomp counter
P:3E3FA:MIERDA3
P:3E40A:SmolJmp
P:3E40F:ContChk:ldy JumpspringAnimCtrl     ;if jumpspring animating right now,\nbeq +\njmp InitSteP               ;branch ahead\ncheck lower nybble of vertical coordinate returned
P:3E411::ldx FramesMissed\nbne +
P:3E413::from collision detection routine\nif lower nybble < 5, branch
P:3E421::ldy WaterCooldown\nbne DoPlayerSideCheck
P:3E429:MIERDA
P:3E44A:: jmp PutOnSlope
P:3E454::jmp SmolJmp
P:3E457::use player's moving direction as temp variable
P:3E459::jump to impede player's movement in that direction
P:3E45C:LandPlyr:jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
P:3E45E::mask out lower nybble of player's vertical position
P:3E460::and store as new vertical position to land player properly
P:3E467:eda
P:3E46C::do sub to process potential pipe entry
P:3E479::sta DetectedFoot\ninitialize vertical speed and fractional
P:3E47B::movement force to stop player's vertical movement
P:3E47E::initialize enemy stomp counter
P:3E481::lda #$00\nset player's state to normal
P:3E486:DoPlayerSideCheck
P:3E495::get block buffer adder offset
P:3E498::increment offset 2 bytes to use adders for side collisions
P:3E4A0::set value here to be used as counter
P:3E4A6:BHalf1
P:3E4A9:SideChekEx
P:3E4AA:SideCheckLoop:move onto the next one
P:3E4AB::store it
P:3E4B2::check player's vertical position
P:3E4B4::if player is in status bar area, branch ahead to skip this part
P:3E4B8::branch to leave if player is too far down
P:3E4BA::do player-to-bg collision detection on one half of player
P:3E4BD::branch ahead if nothing found
P:3E4BF::check for hidden coin block
P:3E4C1::branch to leave if found
P:3E4C3::check for hidden 1-up block
P:3E4D9::do sub to check for hidden coin or 1-up blocks
P:3E4DB::branch to leave if either found
P:3E4E9::otherwise check for pipe metatiles
P:3E4EB::if collided with sideways pipe (top), branch ahead
P:3E4EF::if collided with water pipe (top), branch ahead
P:3E508::ldy WaterCooldown\nbne BHalf
P:3E510:CheckSideMTiles1
P:3E52C::save metatile value into Y
P:3E52D::mask out all but 2 MSB
P:3E530::shift and rotate d7-d6 to d1-d0
P:3E532::use as offset for metatile data
P:3E533::get original metatile value back
P:3E548::compare current metatile with climbable metatiles
P:3E54D:BHalf:load block adder offset
P:3E54F::increment it
P:3E550::get player's vertical position
P:3E554::if too high, branch to leave
P:3E558::if too low, branch to leave
P:3E55A::do player-to-bg collision detection on other half of player
P:3E55F::check for hidden coin block
P:3E561::      branch to leave if found
P:3E563::check for hidden 1-up block
P:3E56B::ldx #$00\nstx OnSlope
P:3E56F::do sub to check for hidden coin or 1-up blocks
P:3E571::branch to leave if either found
P:3E590:: ldx WaterCooldown\nbne +
P:3E5AB:ExSCH2
P:3E5AC:Ultramas1
P:3E5C8::save metatile value into Y
P:3E5C9::mask out all but 2 MSB
P:3E5CC::shift and rotate d7-d6 to d1-d0
P:3E5CE::use as offset for metatile data
P:3E5CF::get original metatile value back
P:3E5E8::compare current metatile with climbable metatiles
P:3E5ED::if something found, branch
P:3E5EF:Ultramas:otherwise decrement counter
P:3E5F1::run code until both sides of player are checked
P:3E5F3:ExSCH:leave
P:3E5F4:SideCheckLoop1
P:3E5F7:CheckSideMTiles:check for hidden coin block
P:3E5F9::branch to leave if found
P:3E5FB::check for hidden 1-up block
P:3E617::branch to leave if either found
P:3E62A:SiPuta
P:3E62E::lda OnSlope\nbne +\ndec Player_Y_Position \njmp PutOnSlope
P:3E638::lda Player_Y_Position\nand #$0f\ncmp #$02\nbcc +++
P:3E649::save metatile value into Y
P:3E64A::mask out all but 2 MSB
P:3E64D::shift and rotate d7-d6 to d1-d0
P:3E64F::use as offset for metatile data
P:3E650::get original metatile value back
P:3E651::compare current metatile with climbable metatiles
P:3E654::if not found, skip and continue with code
P:3E666::otherwise jump to handle climbing
P:3E669:ContSChk:check to see if player touched coin
P:3E670::if not found, branch ahead to continue cude
P:3E672:: lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control\nbne ExCSM2                 ;branch to leave if set\notherwise jump to impede player's movement
P:3E675:ChkPBtm:get player's state
P:3E677::cpy #$00                   ;check for player's state set to normal\nif not, branch to impede player's movement
P:3E679::get player's facing direction
P:3E67C::if facing left, branch to impede movement
P:3E67E::otherwise check for pipe metatiles
P:3E680::if collided with sideways pipe (bottom), branch
P:3E682::if collided with water pipe (bottom), continue
P:3E684::otherwise branch to impede player's movement
P:3E686:PipeDwnS:check player's attributes
P:3E689::if already set, branch, do not play sound again
P:3E68D::otherwise load pipedown/injury sound
P:3E68F:PlyrPipe
P:3E691::set background priority bit in player attributes
P:3E6AA::get lower nybble of player's horizontal coordinate
P:3E6AC::if at zero, branch ahead to skip this part
P:3E6B8:ChkGERtn:get number of game engine routine running
P:3E6BC::if running player entrance routine or
P:3E6BE::player control routine, go ahead and branch to leave
P:3E6C4::otherwise set sideways pipe entry routine to run
P:3E6C6:ExCSM2:and leavex
P:3E6C7:StopPlayerMove:--------------------------------\n$02 - high nybble of vertical coordinate from block buffer\n$04 - low nybble of horizontal coordinate from block buffer\n$06-$07 - block buffer address\nleave
P:3E6CA:HandleCoinMetatile
P:3E6D3::load coin grab sound and leave
P:3E6D5::do sub to erase coin metatile from block buffer
P:3E6D8::increment coin tally used for 1-up blocks
P:3E6DB::give coin
P:3E6DE:HandleAxeMetatile:       ldx BowserFront_Offset\n       lda Enemy_ID,x\n       cmp #Bowser\n       bne +\n       jmp ContChk\n+\n       lda #$00            ;load blank metatile\n       sta ($06),y         ;store to remove old contents from block buffer\n       jmp RemoveCoin_Axe  ;update the screen accordingly\n       jsr SetupVictoryMode\n       lda #$03\n       sta OperMode_Task   ;reset secondary mode\n       lda #$02\n       sta OperMode        ;set primary mode to autoctrl mode\n       rts
P:3E6E0::reset secondary mode
P:3E6E5::set primary mode to autoctrl mode
P:3E6EA::set horizontal speed and continue to erase axe metatile
P:3E6F4:ErACM:lda bocata2\nbne +\ninc bocata2\nload vertical high nybble offset for block buffer
P:3E6FC::store to remove old contents from block buffer
P:3E6FE::update the screen accordingly
P:3E702:ClimbXPosAdder:--------------------------------\n$02 - high nybble of vertical coordinate from block buffer\n$04 - low nybble of horizontal coordinate from block buffer\n$06-$07 - block buffer address
P:3E705:ClimbPLocAdder
P:3E708:FlagpoleYPosData
P:3E70D:HandleClimbing
P:3E711::check low nybble of horizontal coordinate returned from
P:3E713::collision detection routine against certain values, this
P:3E715::makes actual physical part of vine or flagpole thinner
P:3E717::than 16 pixels
P:3E71B:ExHC:leave if too far left or too far right
P:3E71C:ChkForFlagpole
P:3E71E::branch to alternate code if flagpole shaft not found
P:3E720:FlagpoleCollision
P:3E722::check for end-of-level routine running
P:3E724::if running, branch to end of climbing code
P:3E728::set player's facing direction to right
P:3E72A::set scroll lock flag
P:3E72F::check for flagpole slide routine running
P:3E731::if running, branch to end of flagpole code here
P:3E733::load identifier for bullet bills (cannon variant)
P:3E735::store identifier here
P:3E737::      lda #$00\n      ldx #$05          ;check for identifier in enemy object buffer\neie:  ldy Enemy_ID,x\n      ;cpy $00           ;if not found, branch\n      bne ++\n      sta Enemy_Flag,x  ;if found, deactivate enemy object flag\n++:   dex               ;do this until all slots are checked\n      bpl eie
P:3E743::silence music
P:3E746::load flagpole sound into flagpole sound queue
P:3E74C::start at end of vertical coordinate data
P:3E750::store player's vertical coordinate here to be used later
P:3E753:ChkFlagpoleYPosLoop:compare with current vertical coordinate data
P:3E756::if player's => current, branch to use current offset
P:3E758::otherwise decrement offset to use 
P:3E759::do this until all data is checked (use last one if all checked)
P:3E75B:MtchF:store offset here to be used later
P:3E75E:RunFR
P:3E760::set value to run flagpole slide routine
P:3E765::jump to end of climbing code
P:3E768:VineCollision:check for climbing metatile used on vines
P:3E778:PutPlayerOnVine:lda Player_Y_Position     ;check player's vertical coordinate\ncmp #$20                  ;for being in status bar area\nbcs PutPlayerOnVine       ;branch if not that far up\nlda #$01\nsta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
P:3E797::set player state to climbing
P:3E79E::nullify player's horizontal speed
P:3E7A0::and fractional horizontal movement force
P:3E7AB::get player's horizontal coordinate
P:3E7AE::subtract from left side horizontal coordinate
P:3E7B3::if 16 or more pixels difference, do not alter facing direction
P:3E7B7::otherwise force player to face left
P:3E7B9:SetVXPl:get current facing direction, use as offset
P:3E7BB::get low byte of block buffer address
P:3E7BE::move low nybble to high
P:3E7C2::add pixels depending on facing direction
P:3E7C5::store as player's horizontal coordinate
P:3E7C7::get low byte of block buffer address again
P:3E7C9::if not zero, branch
P:3E7CB::load page location of right side of screen
P:3E7CF::add depending on facing location
P:3E7D2::store as player's page location
P:3E7D4:ExPVne:finally, we're done!
P:3E7D5:ClimbMTileUpperExt:--------------------------------\n--------------------------------\n$00-$01 - used to hold bottom right and bottom left metatiles (in that order)\n$00 - used as flag by ImpedePlayerMove to restrict specific movement\nChkForLandJumpSpring:\ncmp #$67				    ;do sub to check if player landed on jumpspring\nbne ExCJSp                  ;if carry not set, jumpspring not found, therefore leave\nlda DetectedFoot\nora OldDetectedFoot\nbne ExCJSp\nlda #$70\nsta VerticalForce           ;otherwise set vertical movement force for player\nlda #$f9\nsta JumpspringForce         ;set default jumpspring force\nlda Enemy_Flag,x\nbeq ++\nlda Enemy_ID,x\ncmp #JumpspringObject\nbeq +\ndex\nbpl -\njmp ExCJSp\nlda #$03\nsta JumpspringTimer         ;set jumpspring timer to be used later\nlsr\nsta JumpspringAnimCtrl      ;set jumpspring animation control to start animating\nrts                         ;and leave\n--------------------------------\n.db $24, $6d, $8a, $c6
P:3E7D5:ExCJSp
P:3E7D9:ExEBG:CheckForClimbMTiles:\n      tay            ;save metatile value into Y\n      and #%11000000 ;mask out all but 2 MSB\n      asl\n      rol            ;shift and rotate d7-d6 to d1-d0\n      rol\n      tax            ;use as offset for metatile data\n      tya            ;get original metatile value back\n      cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles\n      rts\nleave
P:3E7DA:DoEnemySideCheck44:-------------------------------------------------------------------------------------\n$06-$07 - address from block buffer routine
P:3E7DD:NoEToBGCollision1
P:3E7E0:EnemyBGCStateData
P:3E7E6:EnemyBGCXSpdData
P:3E7EA:EnemyToBGCollisionDet:check enemy state for d6 set
P:3E7EE::if set, branch to leave
P:3E7F4::add 62 pixels to enemy object's
P:3E7FC::if enemy vertical coord + 62 < 68, branch to leave
P:3E800:DoIDCheckBGColl:cpy #Spiny               ;if enemy object is not spiny, branch elsewhere\nbne DoIDCheckBGColl\nlda Enemy_Y_Position,x\ncmp #$25                 ;if enemy vertical coordinate < 36 branch to leave\nbcc NoEToBGCollision1
P:3E804::check for some other enemy object
P:3E806::branch if not found
P:3E808::otherwise jump elsewhere
P:3E80B:HBChk:check for hammer bro
P:3E80D::branch if not found
P:3E80F::otherwise jump elsewhere
P:3E812:CInvu:if enemy object is spiny, branch
P:3E816::if special power-up object, branch
P:3E822::if enemy object =>$07, branch to leave
P:3E826:YesIn
P:3E854::set flag in A for save vertical coordinate
P:3E859::set Y to check the bottom middle (8,18) of enemy object
P:3E85C::inc PlayerFoot,x\npha                         ;save contents of A to stack\nsave contents of Y here
P:3E85E::add horizontal coordinate
P:3E861::of object to value obtained using Y as offset
P:3E864::store here
P:3E866::of indirect here
P:3E871::store here and leave
P:3E873::get old contents of Y
P:3E875::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3E878::add it to value obtained using Y as offset
P:3E87B::mask out low nybble
P:3E87D::store result here
P:3E87F::use as offset for block buffer
P:3E880::check current content of block buffer
P:3E882::and store here
P:3E884::get old contents of Y again
P:3E886::pla                         ;pull A from stack\nbne +                       ;if A = 1, branch\nif A = 0, load vertical coordinate
P:3E888::and mask out high nybble
P:3E88A::store masked out result here
P:3E88C::get saved content of block buffer                       ;and leave
P:3E891::get object offset
P:3E893::check to see if object bumped into anything
P:3E895::jmp ++\nlda SprObject_X_Position,x  ;otherwise load horizontal coordinate\nand #%00001111              ;and mask out high nybble\nsta $04                     ;store masked out result here\nldx $03                     ;get saved content of block buffer                       ;and leave\nlda MetatileThingy,x\nldx ObjectOffset            ;get object offset\ncmp #$00                    ;check to see if object bumped into anything
P:3E89A::okputa
P:3E8DD:hypermas
P:3E902::if block underneath enemy, branch
P:3E905:GetBlockCoin2
P:3E916::if enemy state d7 not set, branch
P:3E91E:NoEToBGCollision
P:3E920::otherwise skip and do something else
P:3E923:LandEnemyInitState1
P:3E92C:PUPs2
P:3E92F:LandEnemyProperly1
P:3E932:NoEToBGCollisionAndSlowdown:	lda Enemy_State,x\n	asl\n	bcc +\n	dec Enemy_Y_Position,x\n	dec Enemy_Y_Position,x\n+:	dec Enemy_Y_Position,x\n	ldy #$26\n	inx\n	jsr BBChk_E\n	cmp #$71\n	beq +\n	inc Enemy_Y_Position,x\n	lda Enemy_State,x\n	asl\n	bcc +\n	inc Enemy_Y_Position,x\n	inc Enemy_Y_Position,x\n+:	rts
P:3E932:PutEnemyOnSlope2
P:3E935:Enemy_PSwitchJmp:	rts\njmp PutEnemyOnSlope\n--------------------------------\n$02 - vertical coordinate from block buffer routine
P:3E935:PutEnemyOnSlope1
P:3E938:HandleEToBGCollision:if blank $26, coins, or hidden blocks, jump, enemy falls through
P:3E93A::blank metatile used for vines?
P:3E93E::regular coin?
P:3E950::beq NoEToBGCollision\nhidden 1-up block?
P:3E980:vale:pha\nldy #$24\njsr BlockBufferChk_Enemy\ncmp #$71\nbeq PutEnemyOnSlope2\npla
P:3E9A8::check for blank metatile $23 and branch if not found
P:3E9AA::get vertical coordinate used to find block
P:3E9AC::store default blank metatile in that spot so we won't
P:3E9AE::trigger this routine accidentally again
P:3E9B9:LandEnemyProperly2
P:3E9BC:NoEToBGCollision2
P:3E9BF:PUPs
P:3E9D1::if enemy object => $15, branch ahead
P:3E9D5::if enemy object not goomba, branch ahead of this routine
P:3E9DD::do this sub to kill enemy
P:3E9E0::alter vertical speed of enemy and leave
P:3E9E4:GiveOEPoints:award 100 points for hitting block beneath enemy
P:3E9E6::set number of points control for floatey numbers
P:3E9EB::set timer for floatey numbers
P:3E9F0::set vertical coordinate
P:3E9F6::set horizontal coordinate and leave
P:3E9F9:ChkToStunEnemies
P:3E9FD::load enemy state
P:3E9FF::save high nybble
P:3EA03::set d1 of enemy state
P:3EA08::perform many comparisons on enemy object identifier
P:3EA1C::if the enemy object identifier is equal to the values
P:3EA1E::$09, $0e, $0f or $10, it will be modified, and not
P:3EA20::modified if not any of those values, note that piranha plant will
P:3EA22::always fail this test because A will still have vertical
P:3EA24::coordinate from previous addition, also these comparisons
P:3EA26::are only necessary if branching from $d7a1
P:3EA28:Demote:erase all but LSB, essentially turning enemy object
P:3EA2A::into green or red koopa troopa to demote them
P:3EA2C:SetStun:load enemy state
P:3EA2E::save high nybble
P:3EA32::set d1 of enemy state
P:3EA36::subtract two pixels from enemy's vertical position
P:3EA3A::check for bloober object
P:3EA3E::set default vertical speeds
P:3EA45:SetWYSpd:change the vertical speed
P:3EA47:SetNotW:set vertical speed now
P:3EA4B::get distance between enemy object's
P:3EA4D::horizontal coordinate and the player's
P:3EA4E::horizontal coordinate
P:3EA50::and store here
P:3EA54::subtract borrow, then leave
P:3EA56::branch if enemy is to the right of player
P:3EA58::increment Y if not
P:3EA59:ChkBBill
P:3EA5B::check for bullet bill (cannon variant)
P:3EA5F::check for bullet bill (frenzy variant)
P:3EA61::branch if either found, direction does not change
P:3EA63::store as moving direction
P:3EA65:NoCDirF:decrement and use as offset
P:3EA66::get proper horizontal speed
P:3EA69::and store, then leave
P:3EA6B:ExEBGChk
P:3EA6C:LeComparation:--------------------------------\n$04 - low nybble of vertical coordinate from block buffer routine
P:3EA6E:LandEnemyProperly
P:3EA71::check lower nybble of vertical coordinate saved earlier
P:3EA74::subtract eight pixels
P:3EA79::branch if lower nybble in range of $0d-$0f before subtract
P:3EA7D::branch if d6 in enemy state is set
P:3EA88:SChkA:if lower nybble < $0d, d7 set but d6 not set, jump here
P:3EA8B:ChkForRedKoopa1
P:3EA8E:ProcEnemyDirection:check enemy identifier for goomba
P:3EA90::branch if found
P:3EA94::check for spiny
P:3EA96::branch if not found
P:3EA9A::send enemy moving to the right by default
P:3EA9E::set horizontal speed accordingly
P:3EAA2::if timed appropriately, spiny will skip over
P:3EAA4::trying to face the player
P:3EAA6:InvtD:load 1 for enemy to face the left (inverted here)
P:3EAA8::get distance between enemy object's
P:3EAAA::horizontal coordinate and the player's
P:3EAAB::horizontal coordinate
P:3EAAD::and store here
P:3EAB1::subtract borrow, then leave
P:3EAB3::if enemy to the right of player, branch
P:3EAB5::if to the left, increment by one for enemy to face right (inverted)
P:3EAB6:CNwCDir
P:3EAB7::compare direction in A with current direction in memory
P:3EAC1::if equal, not facing in correct dir, do sub to turn around
P:3EAC4:LandEnemyInitState:initialize vertical speed
P:3EAC6::and movement force
P:3EAC8::do something here to vertical speed and something else
P:3EACD::save high nybble of vertical coordinate, and
P:3EACF::set d3, then store, probably used to set enemy object
P:3EAD1::neatly on whatever it's landing on
P:3EAD5::if d7 of enemy state is set, branch
P:3EAD9::otherwise initialize enemy state and leave
P:3EADB::note this will also turn spiny's egg into spiny
P:3EAE1:NMovShellFallBit:nullify d6 of enemy state, save other bits
P:3EAE3::and store, then leave
P:3EAE8:ChkForRedKoopa:check for red koopa troopa $03
P:3EAF4::branch if not found
P:3EAFA::if enemy found and in normal state, branch
P:3EAFD:Chk2MSBSt:save enemy state into Y
P:3EB00::branch if not set
P:3EB04::set d6
P:3EB06::jump ahead of this part
P:3EB09:GetSteFromD:load new enemy state with old as offset
P:3EB0C:SetD6Ste:set as new state
P:3EB0E:DoEnemySideCheck:--------------------------------\n$00 - used to store bitmask (not used but initialized here)\n$eb - used in DoEnemySideCheck as counter and to compare moving directions
P:3EB12::if enemy within status bar, branch to leave
P:3EB14::because there's nothing there that impedes movement
P:3EB18::start by finding block to the left of enemy ($00,$14)
P:3EB1A::set value here in what is also used as
P:3EB1C::OAM data offset
P:3EB1E:SdeCLoop:check value
P:3EB20::compare value against moving direction
P:3EB22::branch if different and do not seek block there
P:3EB24::set flag in A for save horizontal coordinate 
P:3EB32:NextSdeC:move to the next direction
P:3EB35::increment Y, loop only if Y < $18, thus we check
P:3EB37::enemy ($00, $14) and ($10, $14) pixel coordinates
P:3EB39:ExESdeC
P:3EB3A:Half
P:3EB3E:nosesabe3Under
P:3EB72:nosesabe3
P:3EB75:GetBlockCoin1
P:3EB78:PutEnemyOnSlope3
P:3EB7B:nosesabe:blank metatile used for vines?
P:3EB7F::regular coin?
P:3EB83::hidden coin block?
P:3EB93::hidden 1-up block?
P:3EBAF:cantasmal
P:3EBE6::and if so, branch ahead and do not play sound
P:3EBF1::lda to skip this pla
P:3EBF6:ChkForBump_HammerBroJ
P:3EBFA::and if so, branch ahead and do not play sound
P:3EC06::if enemy state d7 not set, branch
P:3EC31::if not, check for others blocks
P:3EC34:NoBump:check for hammer bro
P:3EC38::branch if not found
P:3EC3C::initialize value here for bitmask  
P:3EC3E::load default vertical speed for jumping
P:3EC40::jump to code that makes hammer bro jump
P:3EC43:GetBlockCoin3
P:3EC46:InvEnemyDir
P:3EC49:BreakBlock2
P:3EC4D:PaLante:if not, turn around
P:3EC4E:PaTras
P:3EC51:Webos3
P:3EC54:nosesabe2
P:3EC6A::if enemy state d7 not set, branch
P:3ECA6:rtsp
P:3ECA7:rtsp2
P:3ECA9:rtsp3
P:3ECB4:MushEJmp
P:3ECB7:StarEJmp
P:3ECBA:GetBlockCoin
P:3ECC4::if enemy state d7 not set, branch
P:3ECD9:CoinE
P:3ECDE:MultiCoin
P:3ECE8::if enemy state d7 not set, branch
P:3ECF9::set offset for empty or last misc object buffer slot
P:3ECFC::get page location saved earlier
P:3ECFE::and save as page location for misc object
P:3ED01::get low byte of block buffer offset
P:3ED04::add five pixels
P:3ED06::save as horizontal coordinate for misc object
P:3ED09::get vertical high nybble offset from earlier
P:3ED0C::remove 16 pixels
P:3ED0E::store as vertical coordinate
P:3ED14:brickshatterex
P:3ED1B:BreakBlock
P:3ED28::get horizontal coordinate for left side of screen
P:3ED2C::subtract 72 pixels regardless of enemy object
P:3ED2E::store result here
P:3ED33::subtract borrow from page location of left side
P:3ED35::store result here
P:3ED37::add 72 pixels to the right side horizontal coordinate
P:3ED3D::store result here
P:3ED42::then add the carry to the page location
P:3ED44::and store result here
P:3ED46::compare horizontal coordinate of the enemy object
P:3ED48::to modified horizontal left edge coordinate to get carry
P:3ED4C::then subtract it from the page coordinate of the enemy object
P:3ED4E::if enemy object is too far left, branch to erase it
P:3ED50::compare horizontal coordinate of the enemy object
P:3ED52::to modified horizontal right edge coordinate to get carry
P:3ED56::then subtract it from the page coordinate of the enemy object
P:3ED58::if enemy object is on the screen, leave, do not erase enemy
P:3ED98::save as horizontal coordinate for block object
P:3ED9D::add carry to page location of player
P:3ED9F::save as page location of block object
P:3EDA4::save vertical high byte of player into
P:3EDA7::get low byte of block buffer address used in same routine
P:3EDD0:ShellBumpTable:02 coin block
P:3EDD3::06 multicoins brick
P:3EDD7::0f power-up
P:3EDE0::16 star
P:3EDE7::1b 1up
P:3EDEC::1c vine
P:3EDEE:ToBreak
P:3EDFD:GetBlockCoin4
P:3EE00:BreakBlock1
P:3EE05:Webos2:coin?
P:3EE09::brick
P:3EE0D::brick with line
P:3EE11::brick
P:3EE15::brick with line
P:3EE19::if not, play bump sound
P:3EE26:ShellBumpLoop
P:3EE62:rp
P:3EE63:NothingBlock
P:3EE6A:OnOffSetE
P:3EE78:CoinE2:initialize multi-coin timer flag
P:3EE7F::if not set, set brick coin timer
P:3EE85:MultiCoinE:check brick coin timer flag
P:3EE88::if set, timer expired or counting down, thus branch
P:3EE8C::if not set, set brick coin timer
P:3EE8F::and set flag linked to it
P:3EEA3:MushE
P:3EEAD::if enemy state d7 not set, branch
P:3EEB4:StarE
P:3EEB7:P1upE
P:3EEB9:BlockPower:fun fact: set block state to 1 to make it bump
P:3EECA:VineE
P:3EEDA::get control bit
P:3EEE1:GetBlockEnemy
P:3EF07::set block bounce timer
P:3EF34::apparently this sometimes refuses to work correctly lmao
P:3EF53::save as horizontal coordinate for block object
P:3EF5D::get low byte of block buffer address used in same routine
P:3EF74:FY2
P:3EF75:DoSide1:--------------------------------\n$00 - used to hold horizontal difference between player and enemy\n-------------------------------                     ;and leave with flags set for conditional branch
P:3EF78:Enemy_PSwitchJmp2
P:3EF7B:EnemyJump:add 62 pixels to enemy object's
P:3EF7D::compare against a certain range     ;do a sub here
P:3EF7F::if enemy vertical coord + 62 < 68, branch to leave
P:3EF8D::set flag in A for save vertical coordinate
P:3EF8F::set Y to check the bottom middle (8,18) of enemy object
P:3EF95::standing on anything, then branch to same place if not
P:3EFD1::blank metatile used for vines?
P:3EFD5::regular coin?
P:3EFD9::hidden coin block?
P:3EFDD::hidden 1-up block?
P:3EFDF::branch if found
P:3F002::hiweputa
P:3F012:bru
P:3F014:bruh
P:3F01D::initialize vertical speed
P:3F01F::and movement force
P:3F021::do something here to vertical speed and something else
P:3F026::save high nybble of vertical coordinate, and
P:3F028::set d3, then store, probably used to set enemy object
P:3F02A::neatly on whatever it's landing on
P:3F02E::make the paratroopa jump again
P:3F030:DoSid2
P:3F033:FY3
P:3F034:DoSide
P:3F07D:NoPe:blank metatile used for vines?
P:3F081::regular coin?
P:3F085::hidden coin block?
P:3F0BD:Oetu
P:3F0C1:Boi
P:3F0C1:XD2
P:3F0C8::check for horizontal blockage, then leave
P:3F0CB:FY4
P:3F0CC:NoUnderHammerBro2
P:3F0CF:HammerBroBGColl:--------------------------------\nset flag in A for save vertical coordinate
P:3F0D1::set Y to check the bottom middle (8,18) of enemy object
P:3F11A::regular coin?
P:3F129::check for blank metatile $23 and branch if not found
P:3F12D:KillEnemyAboveBlock:tu puta madre
P:3F133::do this sub to kill enemy
P:3F136::alter vertical speed of enemy and leave
P:3F13A:FY
P:3F13B:UnderHammerBro:check timer used by hammer bro
P:3F13E::branch if not expired
P:3F142::save d7 and d3 from enemy state, nullify other bits
P:3F144::and store
P:3F146::initialize vertical speed
P:3F148::and movement force
P:3F14A::do something here to vertical speed and something else
P:3F14F::save high nybble of vertical coordinate, and
P:3F151::set d3, then store, probably used to set enemy object
P:3F153::neatly on whatever it's landing on
P:3F155::then check for horizontal blockage and leave
P:3F158:NoUnderHammerBro:if hammer bro is not standing on anything, set d0
P:3F15A::in the enemy state to indicate jumping or falling, then leave
P:3F15F:ChkAboveEnemy
P:3F167:ClearBounceFlag2
P:3F169::clear bouncing flag by default
P:3F16C:FireballBGCollision:-------------------------------------------------------------------------------------\ncheck fireball's vertical coordinate
P:3F170::if within the status bar area of the screen, branch ahead
P:3F172::set offset for block buffer adder data
P:3F176::add seven bytes to use
P:3F179::set A to return vertical coordinate
P:3F17B::save contents of A to stack
P:3F17C::save contents of Y here
P:3F17E::add horizontal coordinate
P:3F181::of object to value obtained using Y as offset
P:3F184::store here
P:3F186::of indirect here
P:3F191::store here and leave
P:3F193::get old contents of Y
P:3F195::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3F198::add it to value obtained using Y as offset
P:3F19B::mask out low nybble
P:3F19D::store result here
P:3F19F::use as offset for block buffer
P:3F1A0::check current content of block buffer
P:3F1A2::and store here
P:3F1A4::get old contents of Y again
P:3F1A6::pull A from stack
P:3F1A7::if A = 1, branch
P:3F1A9::if A = 0, load vertical coordinate
P:3F1AB::and mask out high nybble
P:3F1AD::store masked out result here
P:3F1B4::get object offset
P:3F1B6::check to see if object bumped into anything
P:3F1BB:FY5
P:3F1BE:ClearBounceFlag3
P:3F1C1:xc1:otherwise load horizontal coordinate
P:3F1C3::and mask out high nybble
P:3F1C5::store masked out result here
P:3F1C9::and leave
P:3F1CC::get object offset
P:3F1CE::check to see if object bumped into anything
P:3F1D0::if nothing underneath fireball, branch
P:3F1D2::blank metatile used for vines?
P:3F1D6::hidden coin block?
P:3F20B::regular coin?
P:3F216::hidden 1-up block?
P:3F218::branch if any found
P:3F21C::branch if any found
P:3F23F::if fireball's vertical speed set to move upwards,
P:3F241::branch to set exploding bit in fireball's state
P:3F243::if bouncing flag already set,
P:3F245::branch to set exploding bit in fireball's state
P:3F252::otherwise set vertical speed to move upwards (give it bounce)
P:3F256::set bouncing flag
P:3F25A::modify vertical coordinate to land it properly
P:3F25C::store as new vertical coordinate
P:3F25E:NSFn
P:3F25F:ClearBounceFlag:leave
P:3F261::clear bouncing flag by default
P:3F263::leave
P:3F264:InitFireballExplode
P:3F266::set exploding flag in fireball's state
P:3F26A::load bump sound
P:3F26C::leave
P:3F26D:BlockBufferChk_Enemy:-------------------------------------------------------------------------------------\n$02 - modified y coordinate\n$03 - stores metatile involved in block buffer collisions\n$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate\n$05 - modified x coordinate\n$06-$07 - block buffer address
P:3F26E::inc PlayerFoot,x
P:3F271:BlockBufferChk_FBall:ResidualMiscObjectCode:\n      txa\n      clc           ;supposedly used once to set offset for\n      adc #$0d      ;miscellaneous objects\n      tax\n      ldy #$1b      ;supposedly used once to set offset for block buffer data\n      jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection\nset offset for block buffer adder data
P:3F275::add seven bytes to use
P:3F278:ResJmpM:set A to return vertical coordinate
P:3F27A:BBChk_E:save contents of A to stack
P:3F27B::save contents of Y here
P:3F27D::add horizontal coordinate
P:3F280::of object to value obtained using Y as offset
P:3F283::store here
P:3F285::of indirect here
P:3F290::store here and leave
P:3F292::get old contents of Y
P:3F294::jsr TheLagMaker			   ;if need to lag the game to an unplayable level, uncomment this\nget vertical coordinate of object
P:3F297::add it to value obtained using Y as offset
P:3F29A::mask out low nybble                  ;subtract 32 pixels for the status bar
P:3F29C::store result here
P:3F29E::use as offset for block buffer
P:3F29F::check current content of block buffer
P:3F2A1::and store here
P:3F2A3::get old contents of Y again
P:3F2A5::pull A from stack
P:3F2A6::if A = 1, branch
P:3F2A8::if A = 0, load vertical coordinate
P:3F2AA::and mask out high nybble
P:3F2AC::store masked out result here
P:3F2AE::get saved content of block buffer                       ;and leave
P:3F2B3::get object offset
P:3F2B8:xc:otherwise load horizontal coordinate
P:3F2BA::and mask out high nybble
P:3F2BC::store masked out result here
P:3F2BE::get saved content of block buffer                       ;and leave
P:3F2C3::get object offset
P:3F2C8:VineYPosAdder:-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00 - offset to vine Y coordinate adder\n$02 - offset to sprite data
P:3F2CA:DrawVine:save offset here
P:3F2CC::get relative vertical coordinate
P:3F2D0::add value using offset in Y to get value
P:3F2D3::get offset to vine
P:3F2D6::get sprite data offset
P:3F2D9::store sprite data offset here
P:3F2DB::stack six sprites on top of each other vertically
P:3F2DE::get relative horizontal coordinate
P:3F2E1::store in first, third and fifth sprites
P:3F2EB::add six pixels to second, fourth and sixth sprites
P:3F2ED::to give characteristic staggered vine shape to
P:3F2F0::our vertical stack of sprites
P:3F2F6::set bg priority and palette attribute bits
P:3F2F8::set in first, third and fifth sprites
P:3F301::additionally, set horizontal flip bit
P:3F303::for second, fourth and sixth sprites
P:3F30C::set tiles for six sprites
P:3F30E:VineTL:set tile number for sprite
P:3F313::move offset to next sprite data
P:3F317::move onto next sprite
P:3F318::loop until all sprites are done
P:3F31A::get original offset
P:3F31C::get offset to vine adding data
P:3F31E::if offset not zero, skip this part
P:3F322::set other tile number for top of vine
P:3F325:SkpVTop:start with the first sprite again
P:3F327:ChkFTop:get original starting vertical coordinate
P:3F32B::subtract top-most sprite's Y coordinate
P:3F32E::if two coordinates are less than 100/$64 pixels
P:3F330::apart, skip this to leave sprite alone
P:3F334::otherwise move sprite offscreen
P:3F337:NextVSp:move offset to next OAM data
P:3F33B::move onto next sprite
P:3F33C::do this until all sprites are checked
P:3F340::return offset set earlier
P:3F343:DrawHammer:-------------------------------------------------------------------------------------\nget misc object OAM data offset
P:3F349::if master timer control set, skip this part
P:3F34B::otherwise get hammer's state
P:3F34D::mask out d7
P:3F34F::check to see if set to 1 yet
P:3F351::if so, branch
P:3F353:ForceHPose:reset offset here
P:3F355::do unconditional branch to rendering part
P:3F357:GetHPose:get frame counter
P:3F359::move d3-d2 to d1-d0
P:3F35B::mask out all but d1-d0 (changes every four frames)
P:3F35D::use as timing offset
P:3F35E:RenderH:get relative vertical coordinate
P:3F362::add first sprite vertical adder based on offset
P:3F365::store as sprite Y coordinate for first sprite
P:3F369::add second sprite vertical adder based on offset
P:3F36C::store as sprite Y coordinate for second sprite
P:3F36F::get relative horizontal coordinate
P:3F373::add first sprite horizontal adder based on offset
P:3F376::store as sprite X coordinate for first sprite
P:3F37A::add second sprite horizontal adder based on offset
P:3F37D::store as sprite X coordinate for second sprite
P:3F383::get and store tile number of first sprite
P:3F389::get and store tile number of second sprite
P:3F38F::get and store attribute bytes for both
P:3F392::note in this case they use the same data
P:3F395::get misc object offset
P:3F39A::check offscreen bits
P:3F39C::if all bits clear, leave object alone
P:3F3A0::otherwise nullify misc object state
P:3F3A4::and into first row sprites
P:3F3AA:NoHOffscr:leave
P:3F3AB:FlagpoleGfxHandler:-------------------------------------------------------------------------------------\n$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)\n$02 - used to hold Y coordinate for floatey number\n$03 - residual byte used for flip (but value set here affects nothing)\n$04 - attribute byte for floatey number\n$05 - used as X coordinate for floatey number\nget sprite data offset for flagpole flag
P:3F3AE::get relative horizontal coordinate
P:3F3B1::store as X coordinate for first sprite
P:3F3B5::add eight pixels and store
P:3F3B7::as X coordinate for second and third sprites
P:3F3BE::add twelve more pixels and
P:3F3C0::store here to be used later by floatey number
P:3F3C2::get vertical coordinate
P:3F3C4::and into first row sprites
P:3F3C7::and do sub to dump into first and second sprites
P:3F3CA::add eight pixels
P:3F3CC::and store into third sprite
P:3F3CF::get vertical coordinate for floatey number
P:3F3D2::store it here
P:3F3D6::set value for flip which will not be used, and
P:3F3D8::attribute byte for floatey number
P:3F3DA::set attribute bytes for all three sprites
P:3F3E5::put triangle shaped tile
P:3F3E8::into first and third sprites
P:3F3ED::put skull tile into second sprite
P:3F3F0::get vertical coordinate at time of collision
P:3F3F3::if zero, branch ahead
P:3F3F6::add 12 bytes to sprite data offset
P:3F3F9::put back in Y
P:3F3FA::get offset used to award points for touching flagpole
P:3F3FD::multiply by 2 to get proper offset here
P:3F3FF::get appropriate tile data
P:3F407::use it to render floatey number
P:3F40A:ChkFlagOffscreen:get object offset for flag
P:3F40C::get OAM data offset
P:3F40F::get offscreen bits
P:3F412::mask out all but d3-d1
P:3F414::if none of these bits set, branch to leave
P:3F416:MoveSixSpritesOffscreen:-------------------------------------------------------------------------------------\nset offscreen coordinate if jumping here
P:3F418:DumpSixSpr:dump A contents
P:3F41B::into third row sprites
P:3F41E:DumpFourSpr:into second row sprites
P:3F421:DumpThreeSpr
P:3F424:DumpTwoSpr:and into first row sprites
P:3F42A:ExitDumpSpr
P:3F42B:DrawLargePlatform:-------------------------------------------------------------------------------------\nget OAM data offset
P:3F42E::store here
P:3F430::add 3 to it for offset
P:3F431::to X coordinate
P:3F433::get horizontal relative coordinate
P:3F436::store X coordinates using A as base, stack horizontally
P:3F43B::get vertical coordinate
P:3F43D::dump into first four sprites as Y coordinate
P:3F443::check for castle-type level
P:3F447::check for secondary hard mode flag set
P:3F44A::branch if not set elsewhere
P:3F44C:ShrinkPlatform:load offscreen coordinate if flag set or castle-type level
P:3F44E:SetLast2Platform:get OAM data offset
P:3F451::store vertical coordinate or offscreen
P:3F454::coordinate into last two sprites as Y coordinate
P:3F457::load default tile for platform (girder)
P:3F45C::if cloud level override flag not set, use
P:3F45E::otherwise load other tile for platform (puff)
P:3F460:SetPlatformTilenum:get enemy object buffer offset
P:3F462::increment Y for tile offset
P:3F463::dump tile number into all six sprites
P:3F466::set palette controls
P:3F468::increment Y for sprite attributes
P:3F469::dump attributes into all six sprites
P:3F46C::increment X for enemy objects
P:3F46D::get offscreen bits again
P:3F471::get OAM data offset
P:3F474::rotate d7 into carry, save remaining
P:3F475::bits to the stack
P:3F478::if d7 was set, move first sprite offscreen
P:3F47D:SChk2:get bits from stack
P:3F47E::rotate d6 into carry
P:3F47F::save to stack
P:3F482::if d6 was set, move second sprite offscreen
P:3F487:SChk3:get bits from stack
P:3F488::rotate d5 into carry
P:3F489::save to stack
P:3F48C::if d5 was set, move third sprite offscreen
P:3F491:SChk4:get bits from stack
P:3F492::rotate d4 into carry
P:3F493::save to stack
P:3F496::if d4 was set, move fourth sprite offscreen
P:3F49B:SChk5:get bits from stack
P:3F49C::rotate d3 into carry
P:3F49D::save to stack
P:3F4A0::if d3 was set, move fifth sprite offscreen
P:3F4A5:SChk6:get bits from stack
P:3F4A6::rotate d2 into carry
P:3F4A7::save to stack
P:3F4AB::if d2 was set, move sixth sprite offscreen
P:3F4AE:SLChk:check d7 of offscreen bits
P:3F4B1::and if d7 is not set, skip sub
P:3F4B4::otherwise branch to move all sprites offscreen
P:3F4B7:ExDLPl
P:3F4B8:MovePlayerVertically:-------------------------------------------------------------------------------------\nleave\nset X for player offset
P:3F4BD::if master timer control set, branch ahead
P:3F4BF:NoJSChk:lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating\nbne +                   ;branch to leave if so\ndump vertical force 
P:3F4C4::set maximum vertical speed here
P:3F4C6::then jump to move player vertically
P:3F4C9:MoveEnemyHorizontally:increment offset for enemy offset
P:3F4CA::position object horizontally according to
P:3F4CD:SignDoStuff
P:3F4EA:InitBlock_XY_Pos:--------------------------------\nget player's horizontal coordinate
P:3F4ED::add eight pixels
P:3F4EF::mask out low nybble to give 16-pixel correspondence
P:3F4F1::save as horizontal coordinate for block object
P:3F4F5::add carry to page location of player
P:3F4F7::save as page location of block object
P:3F4F9::save elsewhere to be used later
P:3F4FE::save vertical high byte of player into
P:3F500::vertical high byte of block object and leave
P:3F501:DrawEnemyObjRow:load two tiles of enemy graphics
P:3F509:DrawOneSpriteRow
P:3F50B::draw them\n first sprite is not blank, branch\n second sprite is not blank, branch\n move the (blank) sprites offscreen\ndraw them
P:3F50F:DrawSpriteObject:get saved flip control bits
P:3F512::move d1 into carry
P:3F515::if d1 not set, branch
P:3F517::store first tile into second sprite
P:3F51A::and second into first sprite
P:3F51F::activate horizontal flip OAM attribute
P:3F521::and unconditionally branch
P:3F523:NoHFlip:store first tile into first sprite
P:3F526::and second into second sprite
P:3F52B::clear bit for horizontal flip
P:3F52D:SetHFAt:add other OAM attributes if necessary
P:3F52F::store sprite attributes
P:3F535::now the y coordinates
P:3F537::note because they are
P:3F53A::side by side, they are the same
P:3F53F::store x coordinate, then
P:3F542::add 8 pixels and store another to
P:3F543::put them side by side
P:3F548::add eight pixels to the next y
P:3F54A::coordinate
P:3F54F::add eight to the offset in Y to
P:3F550::move to the next two sprites
P:3F554::increment offset to return it to the
P:3F555::routine that called this subroutine
P:3F557:DefaultBlockObjTiles:-------------------------------------------------------------------------------------\n$00-$01 - tile numbers\n$02 - relative Y position\n$03 - horizontal flip flag (not used here)\n$04 - attributes\n$05 - relative X position\nbrick w/ line (these are sprite tiles, not BG!)
P:3F55C:DrawBlock:get relative vertical coordinate of block object
P:3F55F::store here
P:3F561::get relative horizontal coordinate of block object
P:3F564::store here
P:3F568::set attribute byte here
P:3F56B::set horizontal flip bit here (will not be used)
P:3F56D::get sprite data offset
P:3F570::reset X for use as offset to tile data
P:3F572:DBlkLoop:get left tile number
P:3F575::set here
P:3F577::get right tile number
P:3F57A::do sub to write tile numbers to first row of sprites
P:3F57D::check incremented offset
P:3F57F::and loop back until all four sprites are done
P:3F581::get block object offset
P:3F583::get sprite data offset
P:3F589::check for ground level type area
P:3F58B::if found, branch to next part
P:3F58F::otherwise remove brick tiles with lines
P:3F592::and replace then with lineless brick tiles
P:3F595:ChkRep:lda Cbolla,x\nbne +\ncheck replacement metatile
P:3F59C::if not used block metatile, then
P:3F59E::branch ahead to use current graphics
P:3F5A0::set A for used block tile
P:3F5A2::increment Y to write to tile bytes
P:3F5A3::into second row sprites
P:3F5A9::and into first row sprites
P:3F5AF::return Y to original offset
P:3F5B0::set palette bits
P:3F5B5::check for ground level type area again
P:3F5B6::if found, use current palette bits
P:3F5B8::otherwise set to $01
P:3F5B9:SetBFlip:put block object offset back in X
P:3F5BB::store attribute byte as-is in first sprite
P:3F5C0::set horizontal flip bit for second sprite
P:3F5C5::set both flip bits for fourth sprite
P:3F5CA::set vertical flip bit for third sprite
P:3F5CD:BlkOffscr:get offscreen bits for block object
P:3F5D0::save to stack
P:3F5D1::check to see if d2 in offscreen bits are set
P:3F5D3::if not set, branch, otherwise move sprites offscreen
P:3F5D5::move offscreen two OAMs
P:3F5D7::on the right side
P:3F5DD:PullOfsB:pull offscreen bits from stack
P:3F5DE:ChkLeftCo:check to see if d3 in offscreen bits are set
P:3F5E0::if not set, branch, otherwise move sprites offscreen
P:3F5E2:MoveColOffscreen:move offscreen two OAMs
P:3F5E4::on the left side (or two rows of enemy on either side
P:3F5E7::if branched here from enemy graphics handler)
P:3F5EA:ExDBlk
P:3F5EB:Parallax:-------------------------------------------------------------------------------------\n$00 - used to hold palette bits for attribute byte or relative X position\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\nunderground
P:3F5F7::castle
P:3F603:ResetOffsetParallax
P:3F605::reset parallax and continue
P:3F608:MakeParallax
P:3F627::branch if AreaType not underground or castle
P:3F634::do parallax
P:3F64D::set no-parallax CHR
P:3F66A:SprObjectOffscrChk:get enemy buffer offset
P:3F66C::check offscreen information
P:3F670::shift three times to the right
P:3F671::which puts d2 into carry
P:3F672::save to stack
P:3F673::branch if not set
P:3F675::set for right column sprites
P:3F677::add A to enemy object OAM data offset
P:3F67B::use as offset
P:3F67C::move offscreen two OAMs
P:3F67E::on the left side (or two rows of enemy on either side
P:3F681::if branched here from enemy graphics handler)
P:3F684::move third row sprite in column offscreen
P:3F687:LcChk:get from stack
P:3F688::move d3 to carry
P:3F689::save to stack
P:3F68A::branch if not set
P:3F68C::set for left column sprites,
P:3F68E::add A to enemy object OAM data offset
P:3F692::use as offset
P:3F693::move offscreen two OAMs
P:3F695::on the left side (or two rows of enemy on either side
P:3F698::if branched here from enemy graphics handler)
P:3F69B::move third row sprite in column offscreen
P:3F69E:Row3C:get from stack again
P:3F69F::move d5 to carry this time
P:3F6A1::save to stack again
P:3F6A2::branch if carry not set
P:3F6A4::set for third row of sprites
P:3F6A6::add A to enemy object OAM data offset
P:3F6AA::use as offset
P:3F6AD::and into first row sprites
P:3F6B3:Row23C:get from stack
P:3F6B4::move d6 into carry
P:3F6B5::save to stack
P:3F6B8::set for second and third rows
P:3F6BA::add A to enemy object OAM data offset
P:3F6BE::use as offset
P:3F6C1::and into first row sprites
P:3F6C7:AllRowC:get from stack once more
P:3F6C8::move d7 into carry
P:3F6CB::add A to enemy object OAM data offset
P:3F6CF::use as offset
P:3F6D2::and into first row sprites
P:3F6DA::check enemy identifier for podoboo
P:3F6DC::skip this part if found, we do not want to erase podoboo!
P:3F6E4::check high byte of vertical position
P:3F6E6::if not yet past the bottom of the screen, branch
P:3F6F9::what it says
P:3F6FC:ExEGHandler
P:3F6FD:AreaParallax
P:3F6FF:WorldPaletteLUT
P:3F708:CheckForCoinMTiles:-------------------------------------------------------------------------------------
P:3F70F::check for regular coin
P:3F711::branch if found
P:3F713::otherwise clear carry and leave
P:3F714:CoinSd
P:3F727:SmallPlatformCollision:------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00 - used to store player's vertical offscreen bits\ntiles arranged in order, 2 tiles per row, top to bottom\n-------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------\n$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames\n$02 - vertical position\n$03 - facing direction, used as horizontal flip control\n$04 - attributes\n$05 - horizontal position\n$07 - number of rows to draw\nthese also used in IntermediatePlayerData\nif master timer control set,
P:3F72A::branch to leave
P:3F72C::otherwise initialize collision flag
P:3F72F::do a sub to see if player is below a certain point
P:3F732::or entirely offscreen, and branch to leave if true
P:3F736::load counter here for 2 bounding boxes
P:3F738:ChkSmallPlatLoop:get enemy object offset
P:3F73A::get enemy object buffer offset
P:3F73C::multiply A by four, then add four
P:3F73D::to skip player's bounding box
P:3F741::send to Y
P:3F742::get offscreen bits for enemy object
P:3F745::save low nybble
P:3F747::check for all bits set
P:3F749::if d1 of offscreen lower nybble bits was set
P:3F74B::then branch to leave
P:3F74D::check top of platform's bounding box for being
P:3F750::above a specific point
P:3F752::if so, branch, don't do collision detection
P:3F754::otherwise, perform player-to-platform collision detection
P:3F757::skip ahead if collision
P:3F759:MoveBoundBox:move bounding box vertical coordinates
P:3F75C::128 pixels downwards
P:3F76B::decrement counter we set earlier
P:3F76D::loop back until both bounding boxes are checked
P:3F76F:ExSPC:get enemy object buffer offset, then leave
P:3F772:ProcSPlatCollisions:return enemy object buffer offset to X, then continue
P:3F777:JumpEngineOthersTemp:-------------------------------------------------------------------------------------\n$00 - used as temp variable to hold offscreen bits\n--------------------------------\n(these apply to these three subsections)\n$04 - used to store proper offset\n$05 - used as adder in DividePDiff\n$06 - used to store preset value used to compare to pixel difference in $07\n$07 - used to store difference between coordinates of object and screen edges\n--------------------------------\n-------------------------------------------------------------------------------------\n$04 - address low to jump address\n$05 - address high to jump address\n$06 - jump address low\n$07 - jump address high
P:3F78B::shift bit from contents of A
P:3F78D::pull saved return address from stack
P:3F78E::save to indirect
P:3F794::load pointer from indirect
P:3F796::note that if an RTS is performed in next routine
P:3F798::it will return to the execution before the sub
P:3F799::that called this routine
P:3F79D::jump to the address we loaded
P:3F7A0:JumpEngine:shift bit from contents of A
P:3F7A2::pull saved return address from stack
P:3F7A3::save to indirect
P:3F7A9::load pointer from indirect
P:3F7AB::note that if an RTS is performed in next routine
P:3F7AD::it will return to the execution before the sub
P:3F7AE::that called this routine
P:3F7B2::jump to the address we loaded
P:3F7B5:Reset: $FFFC-$FFFD reset vector new location, & bankswap to $4058 to load MMC3's setups
P:3F7C5:RunPauseMenu:InitEnemyRoutines1:\n		lda #$04\n		jsr BankSwap\n		ldx ObjectOffset\n		lda Enemy_ID,x\n		jsr InitEnemyRoutines\n		jmp RestoreBank
P:3F7D0:RunStuff
P:3F7DB:MoveSpritesOffscreen
P:3F7E6:_GetAreaMusic
P:3F7F1:LoadAreaPointer
P:3F7FC:InitPodoboo2
P:3F807:GetAreaDataAddrs
P:3F812:AreaParserTaskHandler1
P:3F81D:ProcLoopCommand1
P:3F828:InitEnemyRoutines1
P:3F837:SetupTextbox1
P:3F842:EnemyGfxHandler
P:3F84D:GameOverMenu1
P:3F858:RestoreBank: restores $10-$4000 rom, back to $8000-$BFFF ram (4CAAF2)
P:3F85D:RestoreBank1: restores $10-$4000 rom, back to $8000-$BFFF ram (4CAAF2)
P:3F862::get saved content of block buffer
P:3F868:BankSwapCore
P:3F86A:BankSwap: continue to BankSwap\nbankswap routine (A9## 20B0F2)
P:3F86D:Ostia3
P:3F897:StatusBarData: top score display on title screen
P:3F899:: player score
P:3F89D:: coin tally
P:3F8A1:: game timer
P:3F8A5:StatusBarOffset
P:3F8AC:InitializeMemory: Below are some wrappers for core routines\n They have been moved to the "Core" bank, used for\n Self-contained routines that probably won't change\n much.
P:3F8AF:ReadJoypads
P:3F8B8:InitializeNameTables
P:3F8C1:CopyToAllPlayers:DemoEngine:\n       jsr BankSwapCore\n       jsr _DemoEngine\n       jmp RestoreBank\n Routines from handlePlayerData.asm\njsr BankSwapCore\njsr _LoadPlayerData\njmp RestoreBank\njsr BankSwapCore\njsr _SavePlayerData\njmp RestoreBank\njsr BankSwapCore\njsr _WipePlayerData\njmp RestoreBank
P:3F8C1:LoadPlayerData
P:3F8C1:SavePlayerData
P:3F8C1:WipePlayerData
P:3F8C2:handleSound:tay\njsr BankSwapCore\njsr _CopyToAllPlayers\njmp RestoreBank\n Having issue with this one.\nProcessWhirlpools:\njsr BankSwapCore\n       jmp _ProcessWhirlpools\nrts\njmp RestoreBank\njmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return\ninclude code\whirlpools.asm\n-------------------------------------------------------------------------------------
P:3F8D0:RNG:shitty rng
P:3F8D4::get first memory location of LSFR bytes
P:3F8D7::mask out all but d1
P:3F8D9::save here
P:3F8DB::get second memory location
P:3F8DE::mask out all but d1
P:3F8E0::perform exclusive-OR on d1 from first and second bytes
P:3F8E2::if neither or both are set, carry will be clear
P:3F8E5::if one or the other is set, carry will be set
P:3F8E6:RotPRandomBit:rotate carry into d7, and rotate last bit into carry
P:3F8F1::increment to next byte
P:3F8F2::decrement for loop
P:3F8F6:RNG_call: thx nesdev for the rng
P:3F8F9::store copy of high byte
P:3F8FA:: compute seed+1 ($39>>1 = %11100)\nshift to consume zeroes on left...
P:3F8FD::now recreate the remaining bits in reverse order... %111
P:3F908::recombine with original low byte
P:3F90E:: compute seed+0 ($39 = %111001)\noriginal high byte
P:3F924:FlagpoleScoreNumTiles
P:3F92E:ExplosionTiles
P:3F931:PlayerStarting_X_Pos
P:3F935:AltYPosOffset
P:3F937:PlayerStarting_Y_Pos
P:3F940:PlayerBGPriorityData
P:3F948:GameTimerData:dummy byte, used as part of bg priority data
P:3F94C:GameTimerSec
P:3F950:ForceThing
P:3F954:LevelSelectAreasOffsets
P:3F978:IRQ:_FamiToneMusicPlay:\n		pha\n		lda #BANK_SOUND\n		jsr Ostia3\n		pla\n		jsr FamiToneMusicPlay\n		lda currentBank\n		jmp BankSwap\n_FamitoneInit:\n		lda #BANK_SOUND\n		jsr Ostia3\n		jsr FamiToneInit\n		lda currentBank\n		jmp BankSwap\nif USEIRQ == 1\nendif\nsei
P:3F979::lda $00\npha
P:3F9B4:ThirdIRQ_
P:3F9E7:Exitante
P:3FA00:SecondIRQ
P:3FA04::delay HBLANK
P:3FA07::7 cycles per loop
P:3FA0E::delay HBLANK
P:3FA2B::HBLANK starts here
P:3FA43::x doesnt matter
P:3FA7B::lda #%00001010\nsta PPU_CTRL_REG2\nsta Mirror_PPU_CTRL_REG2\nlda #%00001100\nsta PPU_ADDRESS\nlda #$01\nsta PPU_SCROLL_REG\nlda #$00\nsta PPU_SCROLL_REG\nsta PPU_ADDRESS
P:3FA97:ThirdIRQ
P:3FAD1:FourthIRQ
P:3FAF5:EndIRQ
P:3FAF9::pla\nsta $00
P:3FAFA::cli
P:3FAFB:WriteBufferToScreen:-------------------------------------------------------------------------------------\n$00 - vram buffer address table low\n$01 - vram buffer address table high\nWriteBufferToScreen1:\n               sta PPU_ADDRESS           ;store high byte of vram address\n               iny\n               lda ($00),y               ;load next byte (second)\n               sta PPU_ADDRESS           ;store low byte of vram address\n               iny\n               lda ($00),y               ;load next byte (third)\n               asl                       ;shift to left and save in stack\n               pha\n               lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,\n               ora #%00000100            ;set ppu to increment by 32 by default\n               bcs SetupWrites1           ;if d7 of third byte was clear, ppu will\n               and #%11101011            ;only increment by 1\nSetupWrites1:  sta PPU_CTRL_REG1         ;write contents of A to PPU register 1\n               sta Mirror_PPU_CTRL_REG1  ;and its mirror\n               pla                       ;pull from stack and shift to left again\n               asl\n               bcc GetLength1             ;if d6 of third byte was clear, do not repeat byte\n               ora #%00000010            ;otherwise set d1 and increment Y\n               iny\nGetLength1:    lsr                       ;shift back to the right to get proper length\n               lsr                       ;note that d1 will now be in carry\n               tax\nOutputToVRAM1: bcs RepeatByte1            ;if carry set, repeat loading the same byte\n               iny                       ;otherwise increment Y to load next byte\nRepeatByte1:   lda ($00),y               ;load more data from buffer and write to vram\n			   jmp WriteArea\nH23:		   sta PPU_DATA\n               dex                       ;done writing?\n               bne OutputToVRAM1\n			   jmp +\nWriteArea:\n		  php\n		  cpy #$06\n		  bne H24\n		  pha		  \n		  lda AreaType\n		  cmp #$02\n		  bcs Cont\n		  pla\nH24:	  plp\n		  jmp H23\nCont:\n		  pla\n		  lda AreaType\n		  cmp #$02\n		  beq +\n		  lda #$2d\n		  plp\n		  jmp H23\n+:		  lda #$0c\n		  plp\n		  jmp H23\nstore high byte of vram address
P:3FAFF::load next byte (second)
P:3FB01::store low byte of vram address
P:3FB05::load next byte (third)
P:3FB07::shift to left and save in stack
P:3FB09::load mirror of $2000,
P:3FB0C::set ppu to increment by 32 by default
P:3FB0E::if d7 of third byte was clear, ppu will
P:3FB10::only increment by 1
P:3FB12:SetupWrites:write contents of A to PPU register 1
P:3FB15::and its mirror
P:3FB18::pull from stack and shift to left again
P:3FB1A::if d6 of third byte was clear, do not repeat byte
P:3FB1C::otherwise set d1 and increment Y
P:3FB1F:GetLength:shift back to the right to get proper length
P:3FB20::note that d1 will now be in carry
P:3FB22:OutputToVRAM:if carry set, repeat loading the same byte
P:3FB24::otherwise increment Y to load next byte
P:3FB25:RepeatByte:load more data from buffer and write to vram
P:3FB2A::done writing?
P:3FB2F::add end length plus one to the indirect at $00
P:3FB31::to allow this routine to read another set of updates
P:3FB39::sets vram address to $3f00
P:3FB43::then reinitializes it for some reason
P:3FB46:UpdateScreen:reset flip-flop
P:3FB49::load first byte from indirect as a pointer
P:3FB4D::if byte is zero we have no further updates to make here
P:3FB4F::ldx VRAM_Buffer_AddrCtrl\ncpx #$09\nbeq WriteBufferToScreen2\ncpx #$0a\nbeq WriteBufferToScreen2\ncpx #$0b\nbeq WriteBufferToScreen2
P:3FB52:InitScroll:jmp WriteBufferToScreen1\nstore contents of A into scroll registers
P:3FB52:WriteBufferToScreen2
P:3FB55::and end whatever subroutine led us here
P:3FB6B:WritePPUReg1:-------------------------------------------------------------------------------------\nwrite contents of A to PPU register 1
P:3FB6E::and its mirror
P:3FB72:: This is just here to show how much free space is in this spot in the list file.
P:3FB74::-------------------------------------------------------------------------------------\nINTERRUPT VECTORS
P:3FFFA:Vectors
R:0000:BLANK_SPRITE_MOD
R:0000:BOUNDBOX_FIX
R:0000:CHEATS
R:0000:CHEAT_LEVEL_SKIP
R:0000:CHEAT_NO_INJURY
R:0000:CHEAT_REMOVE_TIMER
R:0000:CHEAT_START_FIERY
R:0000:CHEAT_WORLD_SELECT
R:0000:CHEEPCHEEP_FIX
R:0000:DPCM
R:0000:EXTRA_BOUNCE
R:0000:Enablew1l1PiranhaPlants
R:0000:GreenKoopa
R:0000:IMPORT_LEVELS
R:0000:INFINITE_LIVES
R:0000:JUMPSPRING_FIX2
R:0000:Koopa
R:0000:Level1
R:0000:MINUS_WORLD_FIX
R:0000:PLAYER_COLLISION_FIX
R:0000:SKIP_INTERMEDIATE
R:0000:SKIP_TITLE
R:0000:START_WORLD
R:0000:TEST_LUIGI
R:0000:TEST_PLAYER
R:0000:TIM_GRUNT
R:0000:TitleScreenModeValue
R:0000:USEIRQ
R:0000:WATER_SPEED_FIX
R:0000:WORLD9_PIPE_FIX
R:0000:World1
R:0000:_temp
R:0000:shufflelevels
R:0001:BATTERY
R:0001:DEMO_FEATURES
R:0001:DeathMusic
R:0001:DemotedRPTroopa
R:0001:GAME_OVER_MENU
R:0001:GameModeValue
R:0001:GroundMusic
R:0001:JUMPSPRING_FIX
R:0001:LIVES_FIX
R:0001:LUIGI_PALETTE_DX
R:0001:LUIGI_PHYSICS
R:0001:Level2
R:0001:Right_Dir
R:0001:SKID_SFX
R:0001:SOUND
R:0001:SPINYFIX
R:0001:START_LEVEL
R:0001:Sfx_BigJump
R:0001:Sfx_BrickShatter
R:0001:Sfx_CoinGrab
R:0001:Unlock9Steps
R:0001:World2
R:0002:BANK_SOUND
R:0002:BuzzyBeetle
R:0002:GameOverMusic
R:0002:Left_Dir
R:0002:Level3
R:0002:NumberOfCharacters
R:0002:Sfx_BowserFlame
R:0002:Sfx_Bump
R:0002:Sfx_GrowPowerUp
R:0002:VictoryModeValue
R:0002:WaterMusic
R:0002:World3
R:0003:BANK_CORE
R:0003:GameOverModeValue
R:0003:Level4
R:0003:RedKoopa
R:0003:World4
R:0004:Down_Dir
R:0004:GrabState
R:0004:KoopaShell
R:0004:SecHardModeWorld
R:0004:Sfx_EnemyStomp
R:0004:Sfx_GrowVine
R:0004:UndergroundMusic
R:0004:VictoryMusic
R:0004:World5
R:0005:HammerBro
R:0005:World6
R:0006:Goomba
R:0006:World7
R:0007:Bloober
R:0007:FinalWorld
R:0007:World8
R:0008:BulletBill_FrenzyVar
R:0008:CastleMusic
R:0008:EndOfCastleMusic
R:0008:ObjectOffset
R:0008:Sfx_Blast
R:0008:Sfx_EnemySmack
R:0008:Up_Dir
R:0008:World9
R:0009:FastGoomba
R:0009:FrameCounter
R:000A:A_B_Buttons
R:000A:FirstLevelBank
R:000A:GreyCheepCheep
R:000B:RedCheepCheep
R:000B:Up_Down_Buttons
R:000C:Left_Right_Buttons
R:000C:Podoboo
R:000C:Sfx_PSwitchOut
R:000D:PiranhaPlant
R:000D:PreviousA_B_Buttons
R:000E:GameEngineSubroutine
R:000E:GreenParatroopaJump
R:000F:Enemy_Flag
R:000F:RedParatroopa
R:0010:AltGameOverMusic
R:0010:BLOOPER_DISTANCE
R:0010:CloudMusic
R:0010:GreenParatroopaFly
R:0010:Sfx_PipeDown_Injury
R:0010:Sfx_TimerTick
R:0010:Start_Button
R:0011:Lakitu
R:0012:Spiny
R:0013:BlackParatroopa
R:0014:FlyCheepCheepFrenzy
R:0014:FlyingCheepCheep
R:0015:BowserFlame
R:0015:Enemy_ID
R:0016:Fireworks
R:0017:BBill_CCheep_Frenzy
R:0018:Sfx_EnemySmackOr
R:0018:Stop_Frenzy
R:0019:RedKoopaShell
R:001B:Player_State
R:001B:SprObject_State
R:001C:Enemy_State
R:0020:EndOfLevelMusic
R:0020:PipeIntroMusic
R:0020:RedPiranhaPlant
R:0020:Select_Button
R:0020:Sfx_Fireball
R:0020:Sfx_PowerUpGrab
R:0021:UDPiranhaPlant
R:0022:Fireball_State
R:0022:RUDPiranhaPlant
R:0024:Block_State
R:0028:Misc_State
R:002D:Bowser
R:002E:PowerUpObject
R:002F:VineObject
R:0030:FlagpoleFlagObject
R:0031:PlayerFacingDir
R:0031:StarFlagObject
R:0032:FirebarSpinDirection
R:0032:JumpspringObject
R:0033:BulletBill_CannonVar
R:0035:RetainerObject
R:0037:DestinationPageLoc
R:0038:VictoryWalkControl
R:0039:PowerUpType
R:003A:FireballBouncingFlag
R:003C:HammerBroJumpTimer
R:0040:B_Button
R:0040:Sfx_ExtraLife
R:0040:Sfx_Flagpole
R:0040:Sign
R:0040:StarPowerMusic
R:0040:TimeRunningOutMusic
R:0041:ScrollLockEnemy
R:0042:BBillSpawner
R:0042:Player_MovingDir
R:0043:Enemy_MovingDir
R:0043:LastEnemyID
R:0043:PltRem
R:0049:Player_X_Speed
R:0049:SprObject_X_Speed
R:004A:BlooperMoveSpeed
R:004A:CheepCheepMoveMFlag
R:004A:Enemy_X_Speed
R:004A:ExplosionGfxCounter
R:004A:FirebarSpinState_Low
R:004A:Jumpspring_FixedYPos
R:004A:LakituMoveSpeed
R:004A:PiranhaPlant_Y_Speed
R:004A:RedPTroopaCenterYPos
R:004A:XMoveSecondaryCounter
R:004A:YPlatformCenterYPos
R:0050:Fireball_X_Speed
R:0052:Block_X_Speed
R:0056:Misc_X_Speed
R:005F:PSwitchMusic
R:005F:Player_PageLoc
R:005F:SprObject_PageLoc
R:0060:Enemy_PageLoc
R:0066:Fireball_PageLoc
R:0068:Block_PageLoc
R:006C:Misc_PageLoc
R:0075:Bubble_PageLoc
R:0078:Player_X_Position
R:0078:SprObject_X_Position
R:0079:Enemy_X_Position
R:007F:Fireball_X_Position
R:007F:UP
R:0080:A_Button
R:0080:LEFT
R:0080:Sfx_BowserFall
R:0080:Sfx_SmallJump
R:0080:Silence
R:0081:Block_X_Position
R:0081:DOWN
R:0082:RIGHT
R:0083:Abutton
R:0084:Bbutton
R:0085:Misc_X_Position
R:008E:Bubble_X_Position
R:0091:Player_Y_Speed
R:0091:SprObject_Y_Speed
R:0092:BlooperMoveCounter
R:0092:Enemy_Y_Speed
R:0092:FirebarSpinState_High
R:0092:LakituMoveDirection
R:0092:PiranhaPlant_MoveFlag
R:0092:XMovePrimaryCounter
R:0098:Fireball_Y_Speed
R:009A:Block_Y_Speed
R:009E:Misc_Y_Speed
R:00A7:Player_Y_HighPos
R:00A7:SprObject_Y_HighPos
R:00A8:Enemy_Y_HighPos
R:00AE:Fireball_Y_HighPos
R:00B0:Block_Y_HighPos
R:00B4:Misc_Y_HighPos
R:00BD:Bubble_Y_HighPos
R:00C0:ContinueMenuSelect
R:00C0:Player_Y_Position
R:00C0:SprObject_Y_Position
R:00C1:Enemy_Y_Position
R:00C7:Fireball_Y_Position
R:00C9:Block_Y_Position
R:00CD:Misc_Y_Position
R:00D6:Bubble_Y_Position
R:00D6:WarmBootOffset
R:00D9:AreaData
R:00D9:AreaDataLow
R:00DA:AreaDataHigh
R:00DB:EnemyData
R:00DB:EnemyDataLow
R:00DC:EnemyDataHigh
R:00DD:temp1
R:00DE:temp2
R:00DF:temp3
R:00E0:temp4
R:00E1:NoteLenLookupTblOfs
R:00E2:Square1SoundBuffer
R:00E3:Square2SoundBuffer
R:00E4:NoiseSoundBuffer
R:00E5:AreaMusicBuffer
R:00E6:MusicData
R:00E6:MusicDataLow
R:00E7:MusicDataHigh
R:00E8:MusicOffset_Square2
R:00E9:MusicOffset_Square1
R:00EA:MusicOffset_Triangle
R:00EB:PauseSoundQueue
R:00EC:AreaMusicQueue
R:00ED:EventMusicQueue
R:00EE:NoiseSoundQueue
R:00EF:Square2SoundQueue
R:00F0:Square1SoundQueue
R:00F1:skipNMI
R:00FE:ColdBootOffset
R:0109:VerticalFlipFlag
R:010D:FlagpoleFNum_Y_Pos
R:010E:FlagpoleFNum_YMFDummy
R:010F:FlagpoleScore
R:0110:FloateyNum_Control
R:0117:FloateyNum_X_Pos
R:011E:FloateyNum_Y_Pos
R:0125:ShellChainCounter
R:012C:FloateyNum_Timer
R:0134:DigitModifier
R:0200:Sprite_Data
R:0200:Sprite_Y_Position
R:0201:Sprite_Tilenumber
R:0202:Sprite_Attributes
R:0203:Sprite_X_Position
R:0388:FirebarSpinSpeed
R:0398:VineFlagOffset
R:0399:VineHeight
R:039A:VineObjOffset
R:039D:VineStart_Y_Position
R:03A0:BalPlatformAlignment
R:03A1:Platform_X_Scroll
R:03A2:HammerThrowingTimer
R:03A2:PlatformCollisionFlag
R:03AD:Player_Rel_XPos
R:03AD:SprObject_Rel_XPos
R:03AE:Enemy_Rel_XPos
R:03AF:Fireball_Rel_XPos
R:03B0:Bubble_Rel_XPos
R:03B1:Block_Rel_XPos
R:03B3:Misc_Rel_XPos
R:03B8:Player_Rel_YPos
R:03B8:SprObject_Rel_YPos
R:03B9:Enemy_Rel_YPos
R:03BA:Fireball_Rel_YPos
R:03BB:Bubble_Rel_YPos
R:03BC:Block_Rel_YPos
R:03BE:Misc_Rel_YPos
R:03C4:Player_SprAttrib
R:03C4:SprObject_SprAttrib
R:03C5:Enemy_SprAttrib
R:03D0:Player_OffscreenBits
R:03D0:SprObject_OffscrBits
R:03D1:Enemy_OffscreenBits
R:03D2:FBall_OffscreenBits
R:03D3:Bubble_OffscreenBits
R:03D4:Block_OffscreenBits
R:03D6:Misc_OffscreenBits
R:03D8:EnemyOffscrBitsMasked
R:03E4:Block_Orig_YPos
R:03E6:Block_BBuf_Low
R:03E8:Block_Metatile
R:03EA:Block_PageLoc2
R:03EC:Block_RepFlag
R:03EE:SprDataOffset_Ctrl
R:03F0:Block_ResidualCounter
R:03F1:Block_Orig_XPos
R:03F9:AttributeBuffer
R:0400:SprObject_X_MoveForce
R:0401:Enemy_X_MoveForce
R:0401:RedPTroopaOrigXPos
R:0401:YPlatformTopYPos
R:0416:Player_YMF_Dummy
R:0416:SprObject_YMF_Dummy
R:0417:BowserFlamePRandomOfs
R:0417:Enemy_YMF_Dummy
R:0417:PiranhaPlantUpYPos
R:042C:Bubble_YMF_Dummy
R:0433:Player_Y_MoveForce
R:0433:SprObject_Y_MoveForce
R:0434:CheepCheepOrigYPos
R:0434:Enemy_Y_MoveForce
R:0434:PiranhaPlantDownYPos
R:043C:Block_Y_MoveForce
R:0450:MaximumLeftSpeed
R:0456:MaximumRightSpeed
R:046A:Cannon_Offset
R:046A:Whirlpool_Offset
R:046B:Cannon_PageLoc
R:046B:Whirlpool_PageLoc
R:0471:Cannon_X_Position
R:0471:Whirlpool_LeftExtent
R:0477:Cannon_Y_Position
R:0477:Whirlpool_Length
R:047D:Cannon_Timer
R:047D:Whirlpool_Flag
R:0483:BowserHitPoints
R:0484:StompChainCounter
R:0490:Player_CollisionBits
R:0491:Enemy_CollisionBits
R:0499:Player_BoundBoxCtrl
R:0499:SprObj_BoundBoxCtrl
R:049A:Enemy_BoundBoxCtrl
R:04A0:Fireball_BoundBoxCtrl
R:04A2:Misc_BoundBoxCtrl
R:04AC:BoundingBox_UL_Corner
R:04AC:BoundingBox_UL_XPos
R:04AD:BoundingBox_UL_YPos
R:04AE:BoundingBox_DR_XPos
R:04AE:BoundingBox_LR_Corner
R:04AF:BoundingBox_DR_YPos
R:04B0:EnemyBoundingBoxCoord
R:0500:AreaObjOffsetBuffer
R:0501:ExtraShit
R:0510:AreaObjectLength
R:0520:MushroomLedgeHalfLen
R:0530:ExtendedLength
R:0540:ExtendedMetatile
R:0541:ExtraShit2
R:0550:ExtendedHeight
R:0563:BowserBodyControls
R:0564:BowserFeetCounter
R:0565:BowserMovementSpeed
R:0566:BowserOrigXPos
R:0567:BowserFlameTimerCtrl
R:0568:BowserFront_Offset
R:0569:BridgeCollapseOffset
R:056A:BowserGfxFlag
R:0581:ExtraShit3
R:05A1:ExtraShit4
R:05C1:TextboxID
R:05C2:CurrentChar
R:05C3:IncrementedTxtHAdd
R:05C4:IRQnum
R:05C5:Old8000
R:05C6:StartedTextBox
R:05C7:SomeOffset
R:05C8:TextBoxYScroll
R:05C9:ScrollText
R:05CA:songPlaying
R:05CB:EndTimer
R:05CC:LastCHR3
R:05CD:TimesScrolled
R:05CE:PlayerOnVine
R:05CF:OldSavedJoypadBits
R:05D0:LevelParserOffset
R:05D1:LevelSelectNumber
R:05D2:EnemyOffsetPage
R:05F0:EnemyOnSlope
R:0600:ClearRemainings
R:0601:TextBoxYScroll1
R:0602:OldTextboxID
R:0603:wea32
R:0604:clearVRAM
R:069E:Cbolla
R:06A0:BlockBufferColumnPos
R:06A1:MetatileBuffer
R:06AE:HammerEnemyOffset
R:06B7:JumpCoinMiscOffset
R:06BC:BrickCoinTimerFlag
R:06BE:Misc_Collision_Flag
R:06CB:EnemyFrenzyBuffer
R:06CC:SecondaryHardMode
R:06CD:EnemyFrenzyQueue
R:06CE:FireballCounter
R:06CF:DuplicateObj_Offset
R:06D1:LakituReappearTimer
R:06D3:NumberofGroupEnemies
R:06D4:ColorRotateOffset
R:06D5:PlayerGfxOffset
R:06D6:WarpZoneControl
R:06D7:FireworksCounter
R:06D9:MultiLoopCorrectCntr
R:06DA:MultiLoopPassCntr
R:06DB:JumpspringForce
R:06DC:MaxRangeFromOrigin
R:06DD:BitMFilter
R:06DE:ChangeAreaTimer
R:06E0:SprShuffleAmtOffset
R:06E1:SprShuffleAmt
R:06E4:Player_SprDataOffset
R:06E4:SprDataOffset
R:06E5:Enemy_SprDataOffset
R:06EC:Alt_SprDataOffset
R:06EC:Block_SprDataOffset
R:06EE:Bubble_SprDataOffset
R:06F1:FBall_SprDataOffset
R:06F3:Misc_SprDataOffset
R:06FC:SavedJoypad1Bits
R:06FC:SavedJoypadBits
R:06FD:SavedJoypad2Bits
R:06FF:Player_X_Scroll
R:0700:Player_XSpeedAbsolute
R:0701:FrictionAdderHigh
R:0702:FrictionAdderLow
R:0703:RunningSpeed
R:0704:SwimmingFlag
R:0705:Player_X_MoveForce
R:0706:DiffToHaltJump
R:0707:JumpOrigin_Y_HighPos
R:0708:JumpOrigin_Y_Position
R:0709:VerticalForce
R:070A:VerticalForceDown
R:070B:PlayerChangeSizeFlag
R:070C:PlayerAnimTimerSet
R:070D:PlayerAnimCtrl
R:070E:JumpspringAnimCtrl
R:070F:FlagpoleCollisionYPos
R:0710:PlayerEntranceCtrl
R:0711:FireballThrowingTimer
R:0712:DeathMusicLoaded
R:0713:FlagpoleSoundQueue
R:0714:CrouchingFlag
R:0715:GameTimerSetting
R:0716:DisableCollisionDet
R:0717:DemoAction
R:0718:DemoActionTimer
R:0719:PrimaryMsgCounter
R:071A:ScreenEdge_PageLoc
R:071A:ScreenLeft_PageLoc
R:071B:ScreenRight_PageLoc
R:071C:ScreenEdge_X_Pos
R:071C:ScreenLeft_X_Pos
R:071D:ScreenRight_X_Pos
R:071E:ColumnSets
R:071F:AreaParserTaskNum
R:0720:CurrentNTAddr_High
R:0721:CurrentNTAddr_Low
R:0722:IRQDisable
R:0723:ScrollLock
R:0725:CurrentPageLoc
R:0726:CurrentColumnPos
R:0727:TerrainControl
R:0728:BackloadingFlag
R:0729:BehindAreaParserFlag
R:072A:AreaObjectPageLoc
R:072B:AreaObjectPageSel
R:072C:AreaDataOffset
R:0733:AreaStyle
R:0734:StaircaseControl
R:0735:AreaObjectHeight
R:0739:EnemyDataOffset
R:073A:EnemyObjectPageLoc
R:073B:EnemyObjectPageSel
R:073C:ScreenRoutineTask
R:073D:ScrollThirtyTwo
R:073F:HorizontalScroll
R:0740:VerticalScroll
R:0741:ForegroundScenery
R:0742:BackgroundScenery
R:0743:CloudTypeOverride
R:0744:BackgroundColorCtrl
R:0745:LoopCommand
R:0746:StarFlagTaskControl
R:0747:TimerControl
R:0748:CoinTallyFor1Ups
R:0749:SecondaryMsgCounter
R:074A:JoypadBitMask
R:074E:AreaType
R:074F:AreaAddrsLOffset
R:0750:AreaPointer
R:0751:EntrancePage
R:0752:AltEntranceControl
R:0753:CurrentPlayer
R:0754:PlayerSize
R:0755:Player_Pos_ForScroll
R:0756:PlayerStatus
R:0757:FetchNewGameTimerFlag
R:0758:JoypadOverride
R:0759:GameTimerExpiredFlag
R:075A:NumberofLives
R:075A:OnscreenPlayerInfo
R:075B:HalfwayPage
R:075C:LevelNumber
R:075D:Hidden1UpFlag
R:075E:CoinTally
R:075F:WorldNumber
R:0760:AreaNumber
R:0765:Player_OldCollisionBits
R:0766:OffScr_WorldNumber
R:0767:OffScr_AreaNumber
R:0768:ScrollFractional
R:0769:DisableIntermediate
R:076A:PrimaryHardMode
R:076B:WorldSelectNumber
R:0770:OperMode
R:0772:OperMode_Task
R:0773:VRAM_Buffer_AddrCtrl
R:0774:DisableScreenFlag
R:0775:ScrollAmount
R:0776:GamePauseStatus
R:0777:GamePauseTimer
R:0778:Mirror_PPU_CTRL_REG1
R:0779:Mirror_PPU_CTRL_REG2
R:077A:NumberOfPlayers
R:077B:NameTableSelect
R:077C:IRQAckFlag
R:077F:IntervalTimerControl
R:0780:SelectTimer
R:0780:Timers
R:0781:PlayerAnimTimer
R:0782:JumpSwimTimer
R:0783:RunningTimer
R:0784:BlockBounceTimer
R:0785:SideCollisionTimer
R:0786:JumpspringTimer
R:0787:GameTimerCtrlTimer
R:0789:ClimbSideTimer
R:078A:EnemyFrameTimer
R:0790:BowserFireBreathTimer
R:0791:StompTimer
R:0792:AirBubbleTimer
R:0792:FrenzyEnemyTimer
R:0795:ScrollIntervalTimer
R:0796:EnemyIntervalTimer
R:079D:UnusedTimer
R:079E:InjuryTimer
R:079F:StarInvincibleTimer
R:07A0:ScreenTimer
R:07A1:WorldEndTimer
R:07A2:DemoTimer
R:07A7:PseudoRandomBitReg
R:07B0:MusicOffset_Noise
R:07B0:SoundMemory
R:07B1:EventMusicBuffer
R:07B2:PauseSoundBuffer
R:07B3:Squ2_NoteLenBuffer
R:07B4:Squ2_NoteLenCounter
R:07B5:Squ2_EnvelopeDataCtrl
R:07B6:Squ1_NoteLenCounter
R:07B7:Squ1_EnvelopeDataCtrl
R:07B8:Tri_NoteLenBuffer
R:07B9:Tri_NoteLenCounter
R:07BA:Noise_BeatLenCounter
R:07BB:Squ1_SfxLenCounter
R:07BD:Squ2_SfxLenCounter
R:07BE:Sfx_SecondaryCounter
R:07BF:Noise_SfxLenCounter
R:07C0:DAC_Counter
R:07C1:NoiseDataLoopbackOfs
R:07C4:NoteLengthTblAdder
R:07C5:AreaMusicBuffer_Alt
R:07C6:PauseModeFlag
R:07C7:GroundMusicHeaderOfs
R:07CA:AltRegContentFlag
R:07D7:DisplayDigits
R:07D7:TopScoreDisplay
R:07DD:PlayerScoreDisplay
R:07DD:ScoreAndCoinDisplay
R:07EB:PlayerCoinDisplay
R:07F8:GameTimerDisplay
R:07FF:WarmBootValidation
R:0ABE:LevelDataOffset
G:2000:PPU_CTRL_REG1
G:2001:PPU_CTRL_REG2
G:2002:PPU_STATUS
G:2003:PPU_SPR_ADDR
G:2004:PPU_SPR_DATA
G:2005:PPU_SCROLL_REG
G:2006:PPU_ADDRESS
G:2007:PPU_DATA
G:4000:SND_REGISTER
G:4000:SND_SQUARE1_REG
G:4004:SND_SQUARE2_REG
G:4008:SND_TRIANGLE_REG
G:400C:SND_NOISE_REG
G:4010:SND_DELTA_REG
G:4014:SPR_DMA
G:4015:SND_MASTERCTRL_REG
G:4016:JOYPAD_PORT
G:4016:JOYPAD_PORT1
G:4017:JOYPAD_PORT2
W:0000:ChangeBankR
W:0001:ChangeBankRDelay
W:0002:SuppressJumpNoise
W:0003:UnlockWorld9
W:0004:GrabFlag
W:0005:temp5
W:0006:HurryUp
W:0007:UnknownHurryUp
W:0008:GrabID
W:001D:GrabDown
W:001E:eastereggflag
W:001F:StarChainCounter
W:0020:debug
W:0021:FlipGFX
W:0022:FlipTimer
W:0023:dontinc
W:0024:RemoveChain
W:0025:EnemyDefeatPitch
W:0026:DoNotChangeSize
W:0027:PFlag
W:0028:PTimer
W:0029:WaterReplace
W:002A:temp6
W:002B:temp7
W:002C:temp8
W:002D:peo
W:002E:FballCooldown
W:0030:OldStatus
W:0031:ExplosionTimerCounter
W:0032:BlockUsed
W:0034:temp9
W:0035:BowserKilled
W:0036:ParallaxOffset
W:0037:World9Debug
W:0038:StartTimer
W:0039:Flag1kCoins
W:0050:WaitForReset
W:0051:tempA
W:0052:HardModeFlag
W:0053:OnOffBits
W:0054:OnOffFlag
W:0056:tempB
W:0057:tempC
W:0058:tempD
W:0059:LakituRespawning
W:005A:WaterCooldown
W:005B:Tortilla
W:005C:lag
W:005D:LagFrameYes
W:005E:OldSwim
W:005F:bocata
W:0060:bocata2
W:0061:bocata3
W:0062:FrameCaunter
W:0065:DebugSwim
W:0065:PlayerFoot
W:006B:OnSlope
W:0071:TwoFoot
W:0077:OneSecTimer
W:0078:GrabUp
W:0079:CrouchingFlag2
W:007A:Webito
W:007B:EntranceCoolDown
W:007C:DontDecPT
W:007D:sleeping
W:007E:EvenFrame
W:007F:DetectedFoot
W:0080:OldDetectedFoot
W:0081:TimerWa
W:0082:currentBank
W:0084:ContinueWriting
W:0085:CurrentText
W:0086:OldWriting
W:0087:test
W:0088:dontchecklag
W:0089:dou
W:008A:Wea
W:008B:ClimbingSlope
W:008C:temp2a
W:008D:temp3a
W:008E:temp4a
W:008F:temp5a
W:0090:temp6a
W:0091:pspeed
W:0092:pspeeddelay
W:0093:pspeedsound
W:0094:tickid
W:0095:oldpspeed
W:0096:framesfour
W:0097:dontdecrementagain
W:0098:ScrollThirtyTwoOG
W:0099:olddirscroll
W:009A:stopload
W:009B:Player_X_ColumnLoc
W:009C:bbl2
W:009F:Block_BBuf_High
W:00A1:dont
W:00A2:scrolldir
W:00A3:tempXD
W:00A4:dontscroll
W:00A5:iwantdie
W:00A6:ScrollLockPageLoc
W:00A7:ScrollLockColumnPos
W:00A8:WarpZoneCheck
W:00A9:ScrollLeftLock
W:00AA:Player_X_Column
W:00AB:GlobalSaveOffset
W:00AC:Saved_X_Position
W:014C:Saved_Y_Position
W:01AC:Saved_PageLoc
W:024C:Saved_State
W:02AC:Saved_isDefeated
W:034C:Saved_ID
W:03AC:OldPageLoc
W:03AD:OldHorizontalScroll
W:03AE:OldNameTableSelect
W:03AF:TouchingFloor
W:03B0:TouchingCeiling
W:03B1:PlatformTimer
W:03B2:timerupthing
W:03B3:ChangeBankRDelay2
W:03B4:BrickCoinTimer
W:03B5:DisableScreenFlag2
W:03B6:waitforit
W:03B7:SetupPause
W:03B8:PreviousUp_Down_Buttons
W:03B9:SettingSelec
W:03BA:OldSettingSelec
W:03BB:DoFin
W:03BC:BackgroundColorCtrlFP
W:03BD:FlagpoleEnemyPage
W:03BE:FlagpoleEnemyCol
W:03BF:OnPlatform
W:03C0:OnWater
W:03C1:OrigMetatile
W:03C4:SavedOffset
W:03CA:FlagpoleOnScreen
W:03CC:tempE
W:03CD:AreaPages
W:03DD:Averveamos
W:03DE:WasLocked
W:03DF:ScrollLeftFlag
W:03E0:AutoScrollFlag
W:03E1:AutoScrollFlag2
W:03E2:OldScrollLeftFlag
W:03E3:OldSquare1SoundBuffer
W:03E4:OldMirror_PPU_CTRLREG1
W:03E5:OldVerticalScroll
W:03E6:tempF
W:03E7:tempG
W:03E8:SideCollisionAdder
W:03E9:FramesMissed
W:03EA:GroundedTimer
W:03EB:lagframedetect
W:03EC:DecodingLevel
W:03ED:FloateyNum_PageLoc
W:03ED:PagesPages
W:0400:VRAM_Buffer1_Offset
W:0401:VRAM_Buffer1
W:04E0:VRAM_Buffer2_Offset
W:04E1:VRAM_Buffer2
W:0600:Block_Buffer_1
W:0700:Block_Buffer_2
W:1E00:CHR0
W:1E00:save_playerData
W:1E01:CHR1
W:1E02:CHR2
W:1E03:CHR3
W:1E04:CHR4
W:1E05:CHR5
W:1E06:LevelBank
W:1E07:seed
W:1E09:VineGrabCooldown
W:1E0A:TitleScreenSelect
W:1E0B:FirstFrame
W:1E0C:FirstBootFlag
W:1E0D:DontRepeat
W:1E0E:Cannon_Creator
W:1E13:WorldPalette
W:1E14:TheresPal3
W:1E15:OldPal3
W:1E19:dumbflag
W:1E1A:FloateyShit
W:1E1F:DontJump
W:1E20:BowserGotHit
W:1E21:PCooldown
W:1F00:SavedScore
W:1F06:SettingsBits
W:1F0A:WorldSelectEnableFlag
W:1F10:TopMaxedOut
W:1F11:ContinueWorld
W:1F12:ContinueLevel
W:1F13:ContinueScore
W:1F1A:ContinueCoins
W:1F1E:ContinuePwrup
W:1F1F:ContinueCoinTally
W:1FBC:SavedWord
G:8722:MusicHeaderOffsetData
G:8723:MHD
G:9CB4:OriginalLevelDataStart
G:B8B4:SwimTileRepOffset
R:0006:AnteFinalText
R:0007:FinalText
R:0042:save_Validate_value
W:1F00:save_TopScore
W:1FBF:save_Validate
R:0100:I
R:0000:powerup
R:0001:ExLVLID
R:0001:coin
R:0002:hcoin
R:0003:h1up
R:0004:bpowerup
R:0005:bvine
R:0006:bstar
R:0007:bcoins
R:0008:WarpFlag
R:0008:b1up
R:000B:custom
R:000C:Objects2Flag
R:000C:hpowerup
R:000D:Objects3Flag
R:000D:hstar
R:000E:star
R:000F:Objects4Flag
R:000F:PageSkip
R:000F:oneup
R:0010:Objects1Flag
R:0037:TwoGoombas
R:0038:ThreeGoombas
R:0080:PageFlag
R:008D:ONOFFS
R:0000:Y_Scroll
G:D933:addr
G:EF33:adrr
